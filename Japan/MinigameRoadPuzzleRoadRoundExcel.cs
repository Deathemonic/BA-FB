// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace Japan
{

using global::System;
using global::System.Collections.Generic;
using global::Kuroko.Crypto;
using global::Google.FlatBuffers;

public struct MinigameRoadPuzzleRoadRoundExcel : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static MinigameRoadPuzzleRoadRoundExcel GetRootAsMinigameRoadPuzzleRoadRoundExcel(ByteBuffer _bb) { return GetRootAsMinigameRoadPuzzleRoadRoundExcel(_bb, new MinigameRoadPuzzleRoadRoundExcel()); }
  public static MinigameRoadPuzzleRoadRoundExcel GetRootAsMinigameRoadPuzzleRoadRoundExcel(ByteBuffer _bb, MinigameRoadPuzzleRoadRoundExcel obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public MinigameRoadPuzzleRoadRoundExcel __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public long EventContentId { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetLong(o + __p.bb_pos) : (long)0; } }
  public long UniqueId { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetLong(o + __p.bb_pos) : (long)0; } }
  public int Round { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public bool IsLoop { get { int o = __p.__offset(10); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public long EnterScenarioGroupId { get { int o = __p.__offset(12); return o != 0 ? __p.bb.GetLong(o + __p.bb_pos) : (long)0; } }
  public long EndScenarioGroupId { get { int o = __p.__offset(14); return o != 0 ? __p.bb.GetLong(o + __p.bb_pos) : (long)0; } }
  public long MapGroupId { get { int o = __p.__offset(16); return o != 0 ? __p.bb.GetLong(o + __p.bb_pos) : (long)0; } }
  public long RoundReward { get { int o = __p.__offset(18); return o != 0 ? __p.bb.GetLong(o + __p.bb_pos) : (long)0; } }
  public long AdditionalRewardID(int j) { int o = __p.__offset(20); return o != 0 ? __p.bb.GetLong(__p.__vector(o) + j * 8) : (long)0; }
  public int AdditionalRewardIDLength { get { int o = __p.__offset(20); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<long> GetAdditionalRewardIDBytes() { return __p.__vector_as_span<long>(20, 8); }
#else
  public ArraySegment<byte>? GetAdditionalRewardIDBytes() { return __p.__vector_as_arraysegment(20); }
#endif
  public long[] GetAdditionalRewardIDArray() { return __p.__vector_as_array<long>(20); }
  public int AdditionalRewardAmount(int j) { int o = __p.__offset(22); return o != 0 ? __p.bb.GetInt(__p.__vector(o) + j * 4) : (int)0; }
  public int AdditionalRewardAmountLength { get { int o = __p.__offset(22); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<int> GetAdditionalRewardAmountBytes() { return __p.__vector_as_span<int>(22, 4); }
#else
  public ArraySegment<byte>? GetAdditionalRewardAmountBytes() { return __p.__vector_as_arraysegment(22); }
#endif
  public int[] GetAdditionalRewardAmountArray() { return __p.__vector_as_array<int>(22); }

  public static Offset<Japan.MinigameRoadPuzzleRoadRoundExcel> CreateMinigameRoadPuzzleRoadRoundExcel(FlatBufferBuilder builder,
      long EventContentId = 0,
      long UniqueId = 0,
      int Round = 0,
      bool IsLoop = false,
      long EnterScenarioGroupId = 0,
      long EndScenarioGroupId = 0,
      long MapGroupId = 0,
      long RoundReward = 0,
      VectorOffset AdditionalRewardIDOffset = default(VectorOffset),
      VectorOffset AdditionalRewardAmountOffset = default(VectorOffset)) {
    builder.StartTable(10);
    MinigameRoadPuzzleRoadRoundExcel.AddRoundReward(builder, RoundReward);
    MinigameRoadPuzzleRoadRoundExcel.AddMapGroupId(builder, MapGroupId);
    MinigameRoadPuzzleRoadRoundExcel.AddEndScenarioGroupId(builder, EndScenarioGroupId);
    MinigameRoadPuzzleRoadRoundExcel.AddEnterScenarioGroupId(builder, EnterScenarioGroupId);
    MinigameRoadPuzzleRoadRoundExcel.AddUniqueId(builder, UniqueId);
    MinigameRoadPuzzleRoadRoundExcel.AddEventContentId(builder, EventContentId);
    MinigameRoadPuzzleRoadRoundExcel.AddAdditionalRewardAmount(builder, AdditionalRewardAmountOffset);
    MinigameRoadPuzzleRoadRoundExcel.AddAdditionalRewardID(builder, AdditionalRewardIDOffset);
    MinigameRoadPuzzleRoadRoundExcel.AddRound(builder, Round);
    MinigameRoadPuzzleRoadRoundExcel.AddIsLoop(builder, IsLoop);
    return MinigameRoadPuzzleRoadRoundExcel.EndMinigameRoadPuzzleRoadRoundExcel(builder);
  }

  public static void StartMinigameRoadPuzzleRoadRoundExcel(FlatBufferBuilder builder) { builder.StartTable(10); }
  public static void AddEventContentId(FlatBufferBuilder builder, long eventContentId) { builder.AddLong(0, eventContentId, 0); }
  public static void AddUniqueId(FlatBufferBuilder builder, long uniqueId) { builder.AddLong(1, uniqueId, 0); }
  public static void AddRound(FlatBufferBuilder builder, int round) { builder.AddInt(2, round, 0); }
  public static void AddIsLoop(FlatBufferBuilder builder, bool isLoop) { builder.AddBool(3, isLoop, false); }
  public static void AddEnterScenarioGroupId(FlatBufferBuilder builder, long enterScenarioGroupId) { builder.AddLong(4, enterScenarioGroupId, 0); }
  public static void AddEndScenarioGroupId(FlatBufferBuilder builder, long endScenarioGroupId) { builder.AddLong(5, endScenarioGroupId, 0); }
  public static void AddMapGroupId(FlatBufferBuilder builder, long mapGroupId) { builder.AddLong(6, mapGroupId, 0); }
  public static void AddRoundReward(FlatBufferBuilder builder, long roundReward) { builder.AddLong(7, roundReward, 0); }
  public static void AddAdditionalRewardID(FlatBufferBuilder builder, VectorOffset additionalRewardIDOffset) { builder.AddOffset(8, additionalRewardIDOffset.Value, 0); }
  public static VectorOffset CreateAdditionalRewardIDVector(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddLong(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateAdditionalRewardIDVectorBlock(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateAdditionalRewardIDVectorBlock(FlatBufferBuilder builder, ArraySegment<long> data) { builder.StartVector(8, data.Count, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateAdditionalRewardIDVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<long>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartAdditionalRewardIDVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddAdditionalRewardAmount(FlatBufferBuilder builder, VectorOffset additionalRewardAmountOffset) { builder.AddOffset(9, additionalRewardAmountOffset.Value, 0); }
  public static VectorOffset CreateAdditionalRewardAmountVector(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddInt(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateAdditionalRewardAmountVectorBlock(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateAdditionalRewardAmountVectorBlock(FlatBufferBuilder builder, ArraySegment<int> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateAdditionalRewardAmountVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<int>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartAdditionalRewardAmountVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<Japan.MinigameRoadPuzzleRoadRoundExcel> EndMinigameRoadPuzzleRoadRoundExcel(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Japan.MinigameRoadPuzzleRoadRoundExcel>(o);
  }
  public MinigameRoadPuzzleRoadRoundExcelT UnPack() {
    var _o = new MinigameRoadPuzzleRoadRoundExcelT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(MinigameRoadPuzzleRoadRoundExcelT _o) {
		byte[] key = TableEncryptionService.CreateKey("MinigameRoadPuzzleRoadRound");
    _o.EventContentId = TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((long)this.EventContentId, key) : this.EventContentId;
    _o.UniqueId = TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((long)this.UniqueId, key) : this.UniqueId;
    _o.Round = TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((int)this.Round, key) : this.Round;
    _o.IsLoop = TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((bool)this.IsLoop, key) : this.IsLoop;
    _o.EnterScenarioGroupId = TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((long)this.EnterScenarioGroupId, key) : this.EnterScenarioGroupId;
    _o.EndScenarioGroupId = TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((long)this.EndScenarioGroupId, key) : this.EndScenarioGroupId;
    _o.MapGroupId = TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((long)this.MapGroupId, key) : this.MapGroupId;
    _o.RoundReward = TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((long)this.RoundReward, key) : this.RoundReward;
    _o.AdditionalRewardID = new List<long>();
    for (var _j = 0; _j < this.AdditionalRewardIDLength; ++_j) {_o.AdditionalRewardID.Add(TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((long)this.AdditionalRewardID(_j), key) : this.AdditionalRewardID(_j));}
    _o.AdditionalRewardAmount = new List<int>();
    for (var _j = 0; _j < this.AdditionalRewardAmountLength; ++_j) {_o.AdditionalRewardAmount.Add(TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((int)this.AdditionalRewardAmount(_j), key) : this.AdditionalRewardAmount(_j));}
  }
  public static Offset<Japan.MinigameRoadPuzzleRoadRoundExcel> Pack(FlatBufferBuilder builder, MinigameRoadPuzzleRoadRoundExcelT _o) {
    if (_o == null) return default(Offset<Japan.MinigameRoadPuzzleRoadRoundExcel>);
		byte[] key = TableEncryptionService.CreateKey("MinigameRoadPuzzleRoadRound");
		var _EventContentId = TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((long)_o.EventContentId, key) : _o.EventContentId;
		var _UniqueId = TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((long)_o.UniqueId, key) : _o.UniqueId;
		var _Round = TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((int)_o.Round, key) : _o.Round;
		var _IsLoop = TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((bool)_o.IsLoop, key) : _o.IsLoop;
		var _EnterScenarioGroupId = TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((long)_o.EnterScenarioGroupId, key) : _o.EnterScenarioGroupId;
		var _EndScenarioGroupId = TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((long)_o.EndScenarioGroupId, key) : _o.EndScenarioGroupId;
		var _MapGroupId = TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((long)_o.MapGroupId, key) : _o.MapGroupId;
		var _RoundReward = TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((long)_o.RoundReward, key) : _o.RoundReward;
    var _AdditionalRewardID = default(VectorOffset);
    if (_o.AdditionalRewardID != null) {
      var __AdditionalRewardID = _o.AdditionalRewardID.Select(x => TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((long)x, key) : x).ToArray();
      _AdditionalRewardID = CreateAdditionalRewardIDVector(builder, __AdditionalRewardID);
    }
    var _AdditionalRewardAmount = default(VectorOffset);
    if (_o.AdditionalRewardAmount != null) {
      var __AdditionalRewardAmount = _o.AdditionalRewardAmount.Select(x => TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((int)x, key) : x).ToArray();
      _AdditionalRewardAmount = CreateAdditionalRewardAmountVector(builder, __AdditionalRewardAmount);
    }
    return CreateMinigameRoadPuzzleRoadRoundExcel(
      builder,
      TableEncryptionService.UseEncryption ? _EventContentId : _o.EventContentId,
      TableEncryptionService.UseEncryption ? _UniqueId : _o.UniqueId,
      TableEncryptionService.UseEncryption ? _Round : _o.Round,
      TableEncryptionService.UseEncryption ? _IsLoop : _o.IsLoop,
      TableEncryptionService.UseEncryption ? _EnterScenarioGroupId : _o.EnterScenarioGroupId,
      TableEncryptionService.UseEncryption ? _EndScenarioGroupId : _o.EndScenarioGroupId,
      TableEncryptionService.UseEncryption ? _MapGroupId : _o.MapGroupId,
      TableEncryptionService.UseEncryption ? _RoundReward : _o.RoundReward,
      _AdditionalRewardID,
      _AdditionalRewardAmount);
  }
}

public class MinigameRoadPuzzleRoadRoundExcelT
{
  public long EventContentId { get; set; }
  public long UniqueId { get; set; }
  public int Round { get; set; }
  public bool IsLoop { get; set; }
  public long EnterScenarioGroupId { get; set; }
  public long EndScenarioGroupId { get; set; }
  public long MapGroupId { get; set; }
  public long RoundReward { get; set; }
  public List<long> AdditionalRewardID { get; set; }
  public List<int> AdditionalRewardAmount { get; set; }

  public MinigameRoadPuzzleRoadRoundExcelT() {
    this.EventContentId = 0;
    this.UniqueId = 0;
    this.Round = 0;
    this.IsLoop = false;
    this.EnterScenarioGroupId = 0;
    this.EndScenarioGroupId = 0;
    this.MapGroupId = 0;
    this.RoundReward = 0;
    this.AdditionalRewardID = null;
    this.AdditionalRewardAmount = null;
  }
}


static public class MinigameRoadPuzzleRoadRoundExcelVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*EventContentId*/, 8 /*long*/, 8, false)
      && verifier.VerifyField(tablePos, 6 /*UniqueId*/, 8 /*long*/, 8, false)
      && verifier.VerifyField(tablePos, 8 /*Round*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 10 /*IsLoop*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 12 /*EnterScenarioGroupId*/, 8 /*long*/, 8, false)
      && verifier.VerifyField(tablePos, 14 /*EndScenarioGroupId*/, 8 /*long*/, 8, false)
      && verifier.VerifyField(tablePos, 16 /*MapGroupId*/, 8 /*long*/, 8, false)
      && verifier.VerifyField(tablePos, 18 /*RoundReward*/, 8 /*long*/, 8, false)
      && verifier.VerifyVectorOfData(tablePos, 20 /*AdditionalRewardID*/, 8 /*long*/, false)
      && verifier.VerifyVectorOfData(tablePos, 22 /*AdditionalRewardAmount*/, 4 /*int*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}

}
