// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace Global
{

using global::System;
using global::System.Collections.Generic;
using global::Kuroko.Crypto;
using global::Google.FlatBuffers;

public struct CharacterAIExcel : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static CharacterAIExcel GetRootAsCharacterAIExcel(ByteBuffer _bb) { return GetRootAsCharacterAIExcel(_bb, new CharacterAIExcel()); }
  public static CharacterAIExcel GetRootAsCharacterAIExcel(ByteBuffer _bb, CharacterAIExcel obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public CharacterAIExcel __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public long Id { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetLong(o + __p.bb_pos) : (long)0; } }
  public Global.EngageType EngageType { get { int o = __p.__offset(6); return o != 0 ? (Global.EngageType)__p.bb.GetInt(o + __p.bb_pos) : Global.EngageType.SearchAndMove; } }
  public Global.PositioningType Positioning { get { int o = __p.__offset(8); return o != 0 ? (Global.PositioningType)__p.bb.GetInt(o + __p.bb_pos) : Global.PositioningType.CloseToObstacle; } }
  public bool CheckCanUseAutoSkill { get { int o = __p.__offset(10); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public long DistanceReduceRatioObstaclePath { get { int o = __p.__offset(12); return o != 0 ? __p.bb.GetLong(o + __p.bb_pos) : (long)0; } }
  public long DistanceReduceObstaclePath { get { int o = __p.__offset(14); return o != 0 ? __p.bb.GetLong(o + __p.bb_pos) : (long)0; } }
  public long DistanceReduceRatioFormationPath { get { int o = __p.__offset(16); return o != 0 ? __p.bb.GetLong(o + __p.bb_pos) : (long)0; } }
  public long DistanceReduceFormationPath { get { int o = __p.__offset(18); return o != 0 ? __p.bb.GetLong(o + __p.bb_pos) : (long)0; } }
  public long MinimumPositionGap { get { int o = __p.__offset(20); return o != 0 ? __p.bb.GetLong(o + __p.bb_pos) : (long)0; } }
  public bool CanUseObstacleOfKneelMotion { get { int o = __p.__offset(22); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool CanUseObstacleOfStandMotion { get { int o = __p.__offset(24); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool HasTargetSwitchingMotion { get { int o = __p.__offset(26); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }

  public static Offset<Global.CharacterAIExcel> CreateCharacterAIExcel(FlatBufferBuilder builder,
      long Id = 0,
      Global.EngageType EngageType = Global.EngageType.SearchAndMove,
      Global.PositioningType Positioning = Global.PositioningType.CloseToObstacle,
      bool CheckCanUseAutoSkill = false,
      long DistanceReduceRatioObstaclePath = 0,
      long DistanceReduceObstaclePath = 0,
      long DistanceReduceRatioFormationPath = 0,
      long DistanceReduceFormationPath = 0,
      long MinimumPositionGap = 0,
      bool CanUseObstacleOfKneelMotion = false,
      bool CanUseObstacleOfStandMotion = false,
      bool HasTargetSwitchingMotion = false) {
    builder.StartTable(12);
    CharacterAIExcel.AddMinimumPositionGap(builder, MinimumPositionGap);
    CharacterAIExcel.AddDistanceReduceFormationPath(builder, DistanceReduceFormationPath);
    CharacterAIExcel.AddDistanceReduceRatioFormationPath(builder, DistanceReduceRatioFormationPath);
    CharacterAIExcel.AddDistanceReduceObstaclePath(builder, DistanceReduceObstaclePath);
    CharacterAIExcel.AddDistanceReduceRatioObstaclePath(builder, DistanceReduceRatioObstaclePath);
    CharacterAIExcel.AddId(builder, Id);
    CharacterAIExcel.AddPositioning(builder, Positioning);
    CharacterAIExcel.AddEngageType(builder, EngageType);
    CharacterAIExcel.AddHasTargetSwitchingMotion(builder, HasTargetSwitchingMotion);
    CharacterAIExcel.AddCanUseObstacleOfStandMotion(builder, CanUseObstacleOfStandMotion);
    CharacterAIExcel.AddCanUseObstacleOfKneelMotion(builder, CanUseObstacleOfKneelMotion);
    CharacterAIExcel.AddCheckCanUseAutoSkill(builder, CheckCanUseAutoSkill);
    return CharacterAIExcel.EndCharacterAIExcel(builder);
  }

  public static void StartCharacterAIExcel(FlatBufferBuilder builder) { builder.StartTable(12); }
  public static void AddId(FlatBufferBuilder builder, long id) { builder.AddLong(0, id, 0); }
  public static void AddEngageType(FlatBufferBuilder builder, Global.EngageType engageType) { builder.AddInt(1, (int)engageType, 0); }
  public static void AddPositioning(FlatBufferBuilder builder, Global.PositioningType positioning) { builder.AddInt(2, (int)positioning, 0); }
  public static void AddCheckCanUseAutoSkill(FlatBufferBuilder builder, bool checkCanUseAutoSkill) { builder.AddBool(3, checkCanUseAutoSkill, false); }
  public static void AddDistanceReduceRatioObstaclePath(FlatBufferBuilder builder, long distanceReduceRatioObstaclePath) { builder.AddLong(4, distanceReduceRatioObstaclePath, 0); }
  public static void AddDistanceReduceObstaclePath(FlatBufferBuilder builder, long distanceReduceObstaclePath) { builder.AddLong(5, distanceReduceObstaclePath, 0); }
  public static void AddDistanceReduceRatioFormationPath(FlatBufferBuilder builder, long distanceReduceRatioFormationPath) { builder.AddLong(6, distanceReduceRatioFormationPath, 0); }
  public static void AddDistanceReduceFormationPath(FlatBufferBuilder builder, long distanceReduceFormationPath) { builder.AddLong(7, distanceReduceFormationPath, 0); }
  public static void AddMinimumPositionGap(FlatBufferBuilder builder, long minimumPositionGap) { builder.AddLong(8, minimumPositionGap, 0); }
  public static void AddCanUseObstacleOfKneelMotion(FlatBufferBuilder builder, bool canUseObstacleOfKneelMotion) { builder.AddBool(9, canUseObstacleOfKneelMotion, false); }
  public static void AddCanUseObstacleOfStandMotion(FlatBufferBuilder builder, bool canUseObstacleOfStandMotion) { builder.AddBool(10, canUseObstacleOfStandMotion, false); }
  public static void AddHasTargetSwitchingMotion(FlatBufferBuilder builder, bool hasTargetSwitchingMotion) { builder.AddBool(11, hasTargetSwitchingMotion, false); }
  public static Offset<Global.CharacterAIExcel> EndCharacterAIExcel(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Global.CharacterAIExcel>(o);
  }
  public CharacterAIExcelT UnPack() {
    var _o = new CharacterAIExcelT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(CharacterAIExcelT _o) {
		byte[] key = TableEncryptionService.CreateKey("CharacterAI");
    _o.Id = TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((long)this.Id, key) : this.Id;
    _o.EngageType = TableEncryptionService.UseEncryption ? (Global.EngageType)TableEncryptionService.Convert((int)this.EngageType, key) : this.EngageType;
    _o.Positioning = TableEncryptionService.UseEncryption ? (Global.PositioningType)TableEncryptionService.Convert((int)this.Positioning, key) : this.Positioning;
    _o.CheckCanUseAutoSkill = TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((bool)this.CheckCanUseAutoSkill, key) : this.CheckCanUseAutoSkill;
    _o.DistanceReduceRatioObstaclePath = TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((long)this.DistanceReduceRatioObstaclePath, key) : this.DistanceReduceRatioObstaclePath;
    _o.DistanceReduceObstaclePath = TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((long)this.DistanceReduceObstaclePath, key) : this.DistanceReduceObstaclePath;
    _o.DistanceReduceRatioFormationPath = TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((long)this.DistanceReduceRatioFormationPath, key) : this.DistanceReduceRatioFormationPath;
    _o.DistanceReduceFormationPath = TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((long)this.DistanceReduceFormationPath, key) : this.DistanceReduceFormationPath;
    _o.MinimumPositionGap = TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((long)this.MinimumPositionGap, key) : this.MinimumPositionGap;
    _o.CanUseObstacleOfKneelMotion = TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((bool)this.CanUseObstacleOfKneelMotion, key) : this.CanUseObstacleOfKneelMotion;
    _o.CanUseObstacleOfStandMotion = TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((bool)this.CanUseObstacleOfStandMotion, key) : this.CanUseObstacleOfStandMotion;
    _o.HasTargetSwitchingMotion = TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((bool)this.HasTargetSwitchingMotion, key) : this.HasTargetSwitchingMotion;
  }
  public static Offset<Global.CharacterAIExcel> Pack(FlatBufferBuilder builder, CharacterAIExcelT _o) {
    if (_o == null) return default(Offset<Global.CharacterAIExcel>);
		byte[] key = TableEncryptionService.CreateKey("CharacterAI");
		var _Id = TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((long)_o.Id, key) : _o.Id;
		var _EngageType = TableEncryptionService.UseEncryption ? (Global.EngageType)TableEncryptionService.Convert((int)_o.EngageType, key) : _o.EngageType;
		var _Positioning = TableEncryptionService.UseEncryption ? (Global.PositioningType)TableEncryptionService.Convert((int)_o.Positioning, key) : _o.Positioning;
		var _CheckCanUseAutoSkill = TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((bool)_o.CheckCanUseAutoSkill, key) : _o.CheckCanUseAutoSkill;
		var _DistanceReduceRatioObstaclePath = TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((long)_o.DistanceReduceRatioObstaclePath, key) : _o.DistanceReduceRatioObstaclePath;
		var _DistanceReduceObstaclePath = TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((long)_o.DistanceReduceObstaclePath, key) : _o.DistanceReduceObstaclePath;
		var _DistanceReduceRatioFormationPath = TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((long)_o.DistanceReduceRatioFormationPath, key) : _o.DistanceReduceRatioFormationPath;
		var _DistanceReduceFormationPath = TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((long)_o.DistanceReduceFormationPath, key) : _o.DistanceReduceFormationPath;
		var _MinimumPositionGap = TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((long)_o.MinimumPositionGap, key) : _o.MinimumPositionGap;
		var _CanUseObstacleOfKneelMotion = TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((bool)_o.CanUseObstacleOfKneelMotion, key) : _o.CanUseObstacleOfKneelMotion;
		var _CanUseObstacleOfStandMotion = TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((bool)_o.CanUseObstacleOfStandMotion, key) : _o.CanUseObstacleOfStandMotion;
		var _HasTargetSwitchingMotion = TableEncryptionService.UseEncryption ? TableEncryptionService.Convert((bool)_o.HasTargetSwitchingMotion, key) : _o.HasTargetSwitchingMotion;
    return CreateCharacterAIExcel(
      builder,
      TableEncryptionService.UseEncryption ? _Id : _o.Id,
      TableEncryptionService.UseEncryption ? _EngageType : _o.EngageType,
      TableEncryptionService.UseEncryption ? _Positioning : _o.Positioning,
      TableEncryptionService.UseEncryption ? _CheckCanUseAutoSkill : _o.CheckCanUseAutoSkill,
      TableEncryptionService.UseEncryption ? _DistanceReduceRatioObstaclePath : _o.DistanceReduceRatioObstaclePath,
      TableEncryptionService.UseEncryption ? _DistanceReduceObstaclePath : _o.DistanceReduceObstaclePath,
      TableEncryptionService.UseEncryption ? _DistanceReduceRatioFormationPath : _o.DistanceReduceRatioFormationPath,
      TableEncryptionService.UseEncryption ? _DistanceReduceFormationPath : _o.DistanceReduceFormationPath,
      TableEncryptionService.UseEncryption ? _MinimumPositionGap : _o.MinimumPositionGap,
      TableEncryptionService.UseEncryption ? _CanUseObstacleOfKneelMotion : _o.CanUseObstacleOfKneelMotion,
      TableEncryptionService.UseEncryption ? _CanUseObstacleOfStandMotion : _o.CanUseObstacleOfStandMotion,
      TableEncryptionService.UseEncryption ? _HasTargetSwitchingMotion : _o.HasTargetSwitchingMotion);
  }
}

public class CharacterAIExcelT
{
  public long Id { get; set; }
  public Global.EngageType EngageType { get; set; }
  public Global.PositioningType Positioning { get; set; }
  public bool CheckCanUseAutoSkill { get; set; }
  public long DistanceReduceRatioObstaclePath { get; set; }
  public long DistanceReduceObstaclePath { get; set; }
  public long DistanceReduceRatioFormationPath { get; set; }
  public long DistanceReduceFormationPath { get; set; }
  public long MinimumPositionGap { get; set; }
  public bool CanUseObstacleOfKneelMotion { get; set; }
  public bool CanUseObstacleOfStandMotion { get; set; }
  public bool HasTargetSwitchingMotion { get; set; }

  public CharacterAIExcelT() {
    this.Id = 0;
    this.EngageType = Global.EngageType.SearchAndMove;
    this.Positioning = Global.PositioningType.CloseToObstacle;
    this.CheckCanUseAutoSkill = false;
    this.DistanceReduceRatioObstaclePath = 0;
    this.DistanceReduceObstaclePath = 0;
    this.DistanceReduceRatioFormationPath = 0;
    this.DistanceReduceFormationPath = 0;
    this.MinimumPositionGap = 0;
    this.CanUseObstacleOfKneelMotion = false;
    this.CanUseObstacleOfStandMotion = false;
    this.HasTargetSwitchingMotion = false;
  }
}


static public class CharacterAIExcelVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Id*/, 8 /*long*/, 8, false)
      && verifier.VerifyField(tablePos, 6 /*EngageType*/, 4 /*Global.EngageType*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*Positioning*/, 4 /*Global.PositioningType*/, 4, false)
      && verifier.VerifyField(tablePos, 10 /*CheckCanUseAutoSkill*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 12 /*DistanceReduceRatioObstaclePath*/, 8 /*long*/, 8, false)
      && verifier.VerifyField(tablePos, 14 /*DistanceReduceObstaclePath*/, 8 /*long*/, 8, false)
      && verifier.VerifyField(tablePos, 16 /*DistanceReduceRatioFormationPath*/, 8 /*long*/, 8, false)
      && verifier.VerifyField(tablePos, 18 /*DistanceReduceFormationPath*/, 8 /*long*/, 8, false)
      && verifier.VerifyField(tablePos, 20 /*MinimumPositionGap*/, 8 /*long*/, 8, false)
      && verifier.VerifyField(tablePos, 22 /*CanUseObstacleOfKneelMotion*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 24 /*CanUseObstacleOfStandMotion*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 26 /*HasTargetSwitchingMotion*/, 1 /*bool*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}

}
