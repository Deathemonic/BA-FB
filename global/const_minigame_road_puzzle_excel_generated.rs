// automatically generated by the FlatBuffers compiler, do not modify
// @generated
#![allow(unused_imports, dead_code)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum ConstMinigameRoadPuzzleExcelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ConstMinigameRoadPuzzleExcel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConstMinigameRoadPuzzleExcel<'a> {
  type Inner = ConstMinigameRoadPuzzleExcel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ConstMinigameRoadPuzzleExcel<'a> {
  pub const VT_ROADPUZZLEMAPBOUNDARYOFFSETLEFT: flatbuffers::VOffsetT = 4;
  pub const VT_ROADPUZZLEMAPBOUNDARYOFFSETRIGHT: flatbuffers::VOffsetT = 6;
  pub const VT_ROADPUZZLEMAPBOUNDARYOFFSETTOP: flatbuffers::VOffsetT = 8;
  pub const VT_ROADPUZZLEMAPBOUNDARYOFFSETBOTTOM: flatbuffers::VOffsetT = 10;
  pub const VT_ROADPUZZLEMAPCENTEROFFSETX: flatbuffers::VOffsetT = 12;
  pub const VT_ROADPUZZLEMAPCENTEROFFSETY: flatbuffers::VOffsetT = 14;
  pub const VT_CAMERAANGLE: flatbuffers::VOffsetT = 16;
  pub const VT_CAMERAZOOMMAX: flatbuffers::VOffsetT = 18;
  pub const VT_CAMERAZOOMMIN: flatbuffers::VOffsetT = 20;
  pub const VT_CAMERAZOOMDEFAULT: flatbuffers::VOffsetT = 22;
  pub const VT_STAGELOADINGPROGRESSTIME: flatbuffers::VOffsetT = 24;
  pub const VT_TILEROTATIONDEGREE: flatbuffers::VOffsetT = 26;
  pub const VT_STARTSTAGEINDEX: flatbuffers::VOffsetT = 28;
  pub const VT_LOOPSTAGEINDEX: flatbuffers::VOffsetT = 30;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ConstMinigameRoadPuzzleExcel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ConstMinigameRoadPuzzleExcelArgs
  ) -> flatbuffers::WIPOffset<ConstMinigameRoadPuzzleExcel<'bldr>> {
    let mut builder = ConstMinigameRoadPuzzleExcelBuilder::new(_fbb);
    let key = table_encryption_service::create_key(b"ConstMinigameRoadPuzzle");
      let x = args.LoopStageIndex;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_LoopStageIndex(x);
      let x = args.StartStageIndex;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_StartStageIndex(x);
      let x = args.TileRotationDegree;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_TileRotationDegree(x);
      let x = args.StageLoadingProgressTime;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_StageLoadingProgressTime(x);
      let x = args.CameraZoomDefault;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_CameraZoomDefault(x);
      let x = args.CameraZoomMin;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_CameraZoomMin(x);
      let x = args.CameraZoomMax;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_CameraZoomMax(x);
      let x = args.CameraAngle;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_CameraAngle(x);
      let x = args.RoadPuzzleMapCenterOffsetY;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_RoadPuzzleMapCenterOffsetY(x);
      let x = args.RoadPuzzleMapCenterOffsetX;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_RoadPuzzleMapCenterOffsetX(x);
      let x = args.RoadPuzzleMapBoundaryOffsetBottom;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_RoadPuzzleMapBoundaryOffsetBottom(x);
      let x = args.RoadPuzzleMapBoundaryOffsetTop;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_RoadPuzzleMapBoundaryOffsetTop(x);
      let x = args.RoadPuzzleMapBoundaryOffsetRight;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_RoadPuzzleMapBoundaryOffsetRight(x);
      let x = args.RoadPuzzleMapBoundaryOffsetLeft;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_RoadPuzzleMapBoundaryOffsetLeft(x);
    builder.finish()
  }

  pub fn unpack(&self) -> ConstMinigameRoadPuzzleExcelT {
    let key = table_encryption_service::create_key(b"ConstMinigameRoadPuzzle");
      let RoadPuzzleMapBoundaryOffsetLeft = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.RoadPuzzleMapBoundaryOffsetLeft(), &key)
      } else {
        self.RoadPuzzleMapBoundaryOffsetLeft()
      };
      let RoadPuzzleMapBoundaryOffsetRight = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.RoadPuzzleMapBoundaryOffsetRight(), &key)
      } else {
        self.RoadPuzzleMapBoundaryOffsetRight()
      };
      let RoadPuzzleMapBoundaryOffsetTop = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.RoadPuzzleMapBoundaryOffsetTop(), &key)
      } else {
        self.RoadPuzzleMapBoundaryOffsetTop()
      };
      let RoadPuzzleMapBoundaryOffsetBottom = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.RoadPuzzleMapBoundaryOffsetBottom(), &key)
      } else {
        self.RoadPuzzleMapBoundaryOffsetBottom()
      };
      let RoadPuzzleMapCenterOffsetX = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.RoadPuzzleMapCenterOffsetX(), &key)
      } else {
        self.RoadPuzzleMapCenterOffsetX()
      };
      let RoadPuzzleMapCenterOffsetY = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.RoadPuzzleMapCenterOffsetY(), &key)
      } else {
        self.RoadPuzzleMapCenterOffsetY()
      };
      let CameraAngle = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.CameraAngle(), &key)
      } else {
        self.CameraAngle()
      };
      let CameraZoomMax = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.CameraZoomMax(), &key)
      } else {
        self.CameraZoomMax()
      };
      let CameraZoomMin = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.CameraZoomMin(), &key)
      } else {
        self.CameraZoomMin()
      };
      let CameraZoomDefault = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.CameraZoomDefault(), &key)
      } else {
        self.CameraZoomDefault()
      };
      let StageLoadingProgressTime = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.StageLoadingProgressTime(), &key)
      } else {
        self.StageLoadingProgressTime()
      };
      let TileRotationDegree = self.TileRotationDegree();
      let StartStageIndex = self.StartStageIndex();
      let LoopStageIndex = self.LoopStageIndex();
    ConstMinigameRoadPuzzleExcelT {
      RoadPuzzleMapBoundaryOffsetLeft,
      RoadPuzzleMapBoundaryOffsetRight,
      RoadPuzzleMapBoundaryOffsetTop,
      RoadPuzzleMapBoundaryOffsetBottom,
      RoadPuzzleMapCenterOffsetX,
      RoadPuzzleMapCenterOffsetY,
      CameraAngle,
      CameraZoomMax,
      CameraZoomMin,
      CameraZoomDefault,
      StageLoadingProgressTime,
      TileRotationDegree,
      StartStageIndex,
      LoopStageIndex,
    }
  }

  #[inline]
  pub fn RoadPuzzleMapBoundaryOffsetLeft(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ConstMinigameRoadPuzzleExcel::VT_ROADPUZZLEMAPBOUNDARYOFFSETLEFT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn RoadPuzzleMapBoundaryOffsetRight(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ConstMinigameRoadPuzzleExcel::VT_ROADPUZZLEMAPBOUNDARYOFFSETRIGHT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn RoadPuzzleMapBoundaryOffsetTop(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ConstMinigameRoadPuzzleExcel::VT_ROADPUZZLEMAPBOUNDARYOFFSETTOP, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn RoadPuzzleMapBoundaryOffsetBottom(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ConstMinigameRoadPuzzleExcel::VT_ROADPUZZLEMAPBOUNDARYOFFSETBOTTOM, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn RoadPuzzleMapCenterOffsetX(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ConstMinigameRoadPuzzleExcel::VT_ROADPUZZLEMAPCENTEROFFSETX, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn RoadPuzzleMapCenterOffsetY(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ConstMinigameRoadPuzzleExcel::VT_ROADPUZZLEMAPCENTEROFFSETY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn CameraAngle(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ConstMinigameRoadPuzzleExcel::VT_CAMERAANGLE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn CameraZoomMax(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ConstMinigameRoadPuzzleExcel::VT_CAMERAZOOMMAX, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn CameraZoomMin(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ConstMinigameRoadPuzzleExcel::VT_CAMERAZOOMMIN, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn CameraZoomDefault(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ConstMinigameRoadPuzzleExcel::VT_CAMERAZOOMDEFAULT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn StageLoadingProgressTime(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ConstMinigameRoadPuzzleExcel::VT_STAGELOADINGPROGRESSTIME, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn TileRotationDegree(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstMinigameRoadPuzzleExcel::VT_TILEROTATIONDEGREE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn StartStageIndex(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstMinigameRoadPuzzleExcel::VT_STARTSTAGEINDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn LoopStageIndex(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstMinigameRoadPuzzleExcel::VT_LOOPSTAGEINDEX, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ConstMinigameRoadPuzzleExcel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("RoadPuzzleMapBoundaryOffsetLeft", Self::VT_ROADPUZZLEMAPBOUNDARYOFFSETLEFT, false)?
     .visit_field::<f32>("RoadPuzzleMapBoundaryOffsetRight", Self::VT_ROADPUZZLEMAPBOUNDARYOFFSETRIGHT, false)?
     .visit_field::<f32>("RoadPuzzleMapBoundaryOffsetTop", Self::VT_ROADPUZZLEMAPBOUNDARYOFFSETTOP, false)?
     .visit_field::<f32>("RoadPuzzleMapBoundaryOffsetBottom", Self::VT_ROADPUZZLEMAPBOUNDARYOFFSETBOTTOM, false)?
     .visit_field::<f32>("RoadPuzzleMapCenterOffsetX", Self::VT_ROADPUZZLEMAPCENTEROFFSETX, false)?
     .visit_field::<f32>("RoadPuzzleMapCenterOffsetY", Self::VT_ROADPUZZLEMAPCENTEROFFSETY, false)?
     .visit_field::<f32>("CameraAngle", Self::VT_CAMERAANGLE, false)?
     .visit_field::<f32>("CameraZoomMax", Self::VT_CAMERAZOOMMAX, false)?
     .visit_field::<f32>("CameraZoomMin", Self::VT_CAMERAZOOMMIN, false)?
     .visit_field::<f32>("CameraZoomDefault", Self::VT_CAMERAZOOMDEFAULT, false)?
     .visit_field::<f32>("StageLoadingProgressTime", Self::VT_STAGELOADINGPROGRESSTIME, false)?
     .visit_field::<i32>("TileRotationDegree", Self::VT_TILEROTATIONDEGREE, false)?
     .visit_field::<i32>("StartStageIndex", Self::VT_STARTSTAGEINDEX, false)?
     .visit_field::<i32>("LoopStageIndex", Self::VT_LOOPSTAGEINDEX, false)?
     .finish();
    Ok(())
  }
}
pub struct ConstMinigameRoadPuzzleExcelArgs {
    pub RoadPuzzleMapBoundaryOffsetLeft: f32,
    pub RoadPuzzleMapBoundaryOffsetRight: f32,
    pub RoadPuzzleMapBoundaryOffsetTop: f32,
    pub RoadPuzzleMapBoundaryOffsetBottom: f32,
    pub RoadPuzzleMapCenterOffsetX: f32,
    pub RoadPuzzleMapCenterOffsetY: f32,
    pub CameraAngle: f32,
    pub CameraZoomMax: f32,
    pub CameraZoomMin: f32,
    pub CameraZoomDefault: f32,
    pub StageLoadingProgressTime: f32,
    pub TileRotationDegree: i32,
    pub StartStageIndex: i32,
    pub LoopStageIndex: i32,
}
impl<'a> Default for ConstMinigameRoadPuzzleExcelArgs {
  #[inline]
  fn default() -> Self {
    ConstMinigameRoadPuzzleExcelArgs {
      RoadPuzzleMapBoundaryOffsetLeft: 0.0,
      RoadPuzzleMapBoundaryOffsetRight: 0.0,
      RoadPuzzleMapBoundaryOffsetTop: 0.0,
      RoadPuzzleMapBoundaryOffsetBottom: 0.0,
      RoadPuzzleMapCenterOffsetX: 0.0,
      RoadPuzzleMapCenterOffsetY: 0.0,
      CameraAngle: 0.0,
      CameraZoomMax: 0.0,
      CameraZoomMin: 0.0,
      CameraZoomDefault: 0.0,
      StageLoadingProgressTime: 0.0,
      TileRotationDegree: 0,
      StartStageIndex: 0,
      LoopStageIndex: 0,
    }
  }
}

impl Serialize for ConstMinigameRoadPuzzleExcel<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("ConstMinigameRoadPuzzleExcel", 14)?;
      s.serialize_field("RoadPuzzleMapBoundaryOffsetLeft", &self.RoadPuzzleMapBoundaryOffsetLeft())?;
      s.serialize_field("RoadPuzzleMapBoundaryOffsetRight", &self.RoadPuzzleMapBoundaryOffsetRight())?;
      s.serialize_field("RoadPuzzleMapBoundaryOffsetTop", &self.RoadPuzzleMapBoundaryOffsetTop())?;
      s.serialize_field("RoadPuzzleMapBoundaryOffsetBottom", &self.RoadPuzzleMapBoundaryOffsetBottom())?;
      s.serialize_field("RoadPuzzleMapCenterOffsetX", &self.RoadPuzzleMapCenterOffsetX())?;
      s.serialize_field("RoadPuzzleMapCenterOffsetY", &self.RoadPuzzleMapCenterOffsetY())?;
      s.serialize_field("CameraAngle", &self.CameraAngle())?;
      s.serialize_field("CameraZoomMax", &self.CameraZoomMax())?;
      s.serialize_field("CameraZoomMin", &self.CameraZoomMin())?;
      s.serialize_field("CameraZoomDefault", &self.CameraZoomDefault())?;
      s.serialize_field("StageLoadingProgressTime", &self.StageLoadingProgressTime())?;
      s.serialize_field("TileRotationDegree", &self.TileRotationDegree())?;
      s.serialize_field("StartStageIndex", &self.StartStageIndex())?;
      s.serialize_field("LoopStageIndex", &self.LoopStageIndex())?;
    s.end()
  }
}

pub struct ConstMinigameRoadPuzzleExcelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ConstMinigameRoadPuzzleExcelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_RoadPuzzleMapBoundaryOffsetLeft(&mut self, RoadPuzzleMapBoundaryOffsetLeft: f32) {
    self.fbb_.push_slot::<f32>(ConstMinigameRoadPuzzleExcel::VT_ROADPUZZLEMAPBOUNDARYOFFSETLEFT, RoadPuzzleMapBoundaryOffsetLeft, 0.0);
  }
  #[inline]
  pub fn add_RoadPuzzleMapBoundaryOffsetRight(&mut self, RoadPuzzleMapBoundaryOffsetRight: f32) {
    self.fbb_.push_slot::<f32>(ConstMinigameRoadPuzzleExcel::VT_ROADPUZZLEMAPBOUNDARYOFFSETRIGHT, RoadPuzzleMapBoundaryOffsetRight, 0.0);
  }
  #[inline]
  pub fn add_RoadPuzzleMapBoundaryOffsetTop(&mut self, RoadPuzzleMapBoundaryOffsetTop: f32) {
    self.fbb_.push_slot::<f32>(ConstMinigameRoadPuzzleExcel::VT_ROADPUZZLEMAPBOUNDARYOFFSETTOP, RoadPuzzleMapBoundaryOffsetTop, 0.0);
  }
  #[inline]
  pub fn add_RoadPuzzleMapBoundaryOffsetBottom(&mut self, RoadPuzzleMapBoundaryOffsetBottom: f32) {
    self.fbb_.push_slot::<f32>(ConstMinigameRoadPuzzleExcel::VT_ROADPUZZLEMAPBOUNDARYOFFSETBOTTOM, RoadPuzzleMapBoundaryOffsetBottom, 0.0);
  }
  #[inline]
  pub fn add_RoadPuzzleMapCenterOffsetX(&mut self, RoadPuzzleMapCenterOffsetX: f32) {
    self.fbb_.push_slot::<f32>(ConstMinigameRoadPuzzleExcel::VT_ROADPUZZLEMAPCENTEROFFSETX, RoadPuzzleMapCenterOffsetX, 0.0);
  }
  #[inline]
  pub fn add_RoadPuzzleMapCenterOffsetY(&mut self, RoadPuzzleMapCenterOffsetY: f32) {
    self.fbb_.push_slot::<f32>(ConstMinigameRoadPuzzleExcel::VT_ROADPUZZLEMAPCENTEROFFSETY, RoadPuzzleMapCenterOffsetY, 0.0);
  }
  #[inline]
  pub fn add_CameraAngle(&mut self, CameraAngle: f32) {
    self.fbb_.push_slot::<f32>(ConstMinigameRoadPuzzleExcel::VT_CAMERAANGLE, CameraAngle, 0.0);
  }
  #[inline]
  pub fn add_CameraZoomMax(&mut self, CameraZoomMax: f32) {
    self.fbb_.push_slot::<f32>(ConstMinigameRoadPuzzleExcel::VT_CAMERAZOOMMAX, CameraZoomMax, 0.0);
  }
  #[inline]
  pub fn add_CameraZoomMin(&mut self, CameraZoomMin: f32) {
    self.fbb_.push_slot::<f32>(ConstMinigameRoadPuzzleExcel::VT_CAMERAZOOMMIN, CameraZoomMin, 0.0);
  }
  #[inline]
  pub fn add_CameraZoomDefault(&mut self, CameraZoomDefault: f32) {
    self.fbb_.push_slot::<f32>(ConstMinigameRoadPuzzleExcel::VT_CAMERAZOOMDEFAULT, CameraZoomDefault, 0.0);
  }
  #[inline]
  pub fn add_StageLoadingProgressTime(&mut self, StageLoadingProgressTime: f32) {
    self.fbb_.push_slot::<f32>(ConstMinigameRoadPuzzleExcel::VT_STAGELOADINGPROGRESSTIME, StageLoadingProgressTime, 0.0);
  }
  #[inline]
  pub fn add_TileRotationDegree(&mut self, TileRotationDegree: i32) {
    self.fbb_.push_slot::<i32>(ConstMinigameRoadPuzzleExcel::VT_TILEROTATIONDEGREE, TileRotationDegree, 0);
  }
  #[inline]
  pub fn add_StartStageIndex(&mut self, StartStageIndex: i32) {
    self.fbb_.push_slot::<i32>(ConstMinigameRoadPuzzleExcel::VT_STARTSTAGEINDEX, StartStageIndex, 0);
  }
  #[inline]
  pub fn add_LoopStageIndex(&mut self, LoopStageIndex: i32) {
    self.fbb_.push_slot::<i32>(ConstMinigameRoadPuzzleExcel::VT_LOOPSTAGEINDEX, LoopStageIndex, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ConstMinigameRoadPuzzleExcelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ConstMinigameRoadPuzzleExcelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ConstMinigameRoadPuzzleExcel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ConstMinigameRoadPuzzleExcel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ConstMinigameRoadPuzzleExcel");
      ds.field("RoadPuzzleMapBoundaryOffsetLeft", &self.RoadPuzzleMapBoundaryOffsetLeft());
      ds.field("RoadPuzzleMapBoundaryOffsetRight", &self.RoadPuzzleMapBoundaryOffsetRight());
      ds.field("RoadPuzzleMapBoundaryOffsetTop", &self.RoadPuzzleMapBoundaryOffsetTop());
      ds.field("RoadPuzzleMapBoundaryOffsetBottom", &self.RoadPuzzleMapBoundaryOffsetBottom());
      ds.field("RoadPuzzleMapCenterOffsetX", &self.RoadPuzzleMapCenterOffsetX());
      ds.field("RoadPuzzleMapCenterOffsetY", &self.RoadPuzzleMapCenterOffsetY());
      ds.field("CameraAngle", &self.CameraAngle());
      ds.field("CameraZoomMax", &self.CameraZoomMax());
      ds.field("CameraZoomMin", &self.CameraZoomMin());
      ds.field("CameraZoomDefault", &self.CameraZoomDefault());
      ds.field("StageLoadingProgressTime", &self.StageLoadingProgressTime());
      ds.field("TileRotationDegree", &self.TileRotationDegree());
      ds.field("StartStageIndex", &self.StartStageIndex());
      ds.field("LoopStageIndex", &self.LoopStageIndex());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ConstMinigameRoadPuzzleExcelT {
  pub RoadPuzzleMapBoundaryOffsetLeft: f32,
  pub RoadPuzzleMapBoundaryOffsetRight: f32,
  pub RoadPuzzleMapBoundaryOffsetTop: f32,
  pub RoadPuzzleMapBoundaryOffsetBottom: f32,
  pub RoadPuzzleMapCenterOffsetX: f32,
  pub RoadPuzzleMapCenterOffsetY: f32,
  pub CameraAngle: f32,
  pub CameraZoomMax: f32,
  pub CameraZoomMin: f32,
  pub CameraZoomDefault: f32,
  pub StageLoadingProgressTime: f32,
  pub TileRotationDegree: i32,
  pub StartStageIndex: i32,
  pub LoopStageIndex: i32,
}
impl Default for ConstMinigameRoadPuzzleExcelT {
  fn default() -> Self {
    Self {
      RoadPuzzleMapBoundaryOffsetLeft: 0.0,
      RoadPuzzleMapBoundaryOffsetRight: 0.0,
      RoadPuzzleMapBoundaryOffsetTop: 0.0,
      RoadPuzzleMapBoundaryOffsetBottom: 0.0,
      RoadPuzzleMapCenterOffsetX: 0.0,
      RoadPuzzleMapCenterOffsetY: 0.0,
      CameraAngle: 0.0,
      CameraZoomMax: 0.0,
      CameraZoomMin: 0.0,
      CameraZoomDefault: 0.0,
      StageLoadingProgressTime: 0.0,
      TileRotationDegree: 0,
      StartStageIndex: 0,
      LoopStageIndex: 0,
    }
  }
}
impl ConstMinigameRoadPuzzleExcelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ConstMinigameRoadPuzzleExcel<'b>> {
    let RoadPuzzleMapBoundaryOffsetLeft = self.RoadPuzzleMapBoundaryOffsetLeft;
    let RoadPuzzleMapBoundaryOffsetRight = self.RoadPuzzleMapBoundaryOffsetRight;
    let RoadPuzzleMapBoundaryOffsetTop = self.RoadPuzzleMapBoundaryOffsetTop;
    let RoadPuzzleMapBoundaryOffsetBottom = self.RoadPuzzleMapBoundaryOffsetBottom;
    let RoadPuzzleMapCenterOffsetX = self.RoadPuzzleMapCenterOffsetX;
    let RoadPuzzleMapCenterOffsetY = self.RoadPuzzleMapCenterOffsetY;
    let CameraAngle = self.CameraAngle;
    let CameraZoomMax = self.CameraZoomMax;
    let CameraZoomMin = self.CameraZoomMin;
    let CameraZoomDefault = self.CameraZoomDefault;
    let StageLoadingProgressTime = self.StageLoadingProgressTime;
    let TileRotationDegree = self.TileRotationDegree;
    let StartStageIndex = self.StartStageIndex;
    let LoopStageIndex = self.LoopStageIndex;
    ConstMinigameRoadPuzzleExcel::create(_fbb, &ConstMinigameRoadPuzzleExcelArgs{
      RoadPuzzleMapBoundaryOffsetLeft,
      RoadPuzzleMapBoundaryOffsetRight,
      RoadPuzzleMapBoundaryOffsetTop,
      RoadPuzzleMapBoundaryOffsetBottom,
      RoadPuzzleMapCenterOffsetX,
      RoadPuzzleMapCenterOffsetY,
      CameraAngle,
      CameraZoomMax,
      CameraZoomMin,
      CameraZoomDefault,
      StageLoadingProgressTime,
      TileRotationDegree,
      StartStageIndex,
      LoopStageIndex,
    })
  }
}
