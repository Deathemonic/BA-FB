// automatically generated by the FlatBuffers compiler, do not modify
// @generated
#![allow(unused_imports, dead_code)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum WorldRaidStageExcelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct WorldRaidStageExcel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WorldRaidStageExcel<'a> {
  type Inner = WorldRaidStageExcel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> WorldRaidStageExcel<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_USEBOSSINDEX: flatbuffers::VOffsetT = 6;
  pub const VT_USEBOSSAIPHASESYNC: flatbuffers::VOffsetT = 8;
  pub const VT_WORLDRAIDBOSSGROUPID: flatbuffers::VOffsetT = 10;
  pub const VT_PORTRAITPATH: flatbuffers::VOffsetT = 12;
  pub const VT_BGPATH: flatbuffers::VOffsetT = 14;
  pub const VT_RAIDCHARACTERID: flatbuffers::VOffsetT = 16;
  pub const VT_BOSSCHARACTERID: flatbuffers::VOffsetT = 18;
  pub const VT_ASSISTCHARACTERLIMITCOUNT: flatbuffers::VOffsetT = 20;
  pub const VT_WORLDRAIDDIFFICULTY: flatbuffers::VOffsetT = 22;
  pub const VT_DIFFICULTYOPENCONDITION: flatbuffers::VOffsetT = 24;
  pub const VT_RAIDENTERAMOUNT: flatbuffers::VOffsetT = 26;
  pub const VT_REENTERAMOUNT: flatbuffers::VOffsetT = 28;
  pub const VT_BATTLEDURATION: flatbuffers::VOffsetT = 30;
  pub const VT_GROUNDID: flatbuffers::VOffsetT = 32;
  pub const VT_RAIDBATTLEENDREWARDGROUPID: flatbuffers::VOffsetT = 34;
  pub const VT_RAIDREWARDGROUPID: flatbuffers::VOffsetT = 36;
  pub const VT_BATTLEREADYTIMELINEPATH: flatbuffers::VOffsetT = 38;
  pub const VT_BATTLEREADYTIMELINEPHASESTART: flatbuffers::VOffsetT = 40;
  pub const VT_BATTLEREADYTIMELINEPHASEEND: flatbuffers::VOffsetT = 42;
  pub const VT_VICTORYTIMELINEPATH: flatbuffers::VOffsetT = 44;
  pub const VT_PHASECHANGETIMELINEPATH: flatbuffers::VOffsetT = 46;
  pub const VT_TIMELINEPHASE: flatbuffers::VOffsetT = 48;
  pub const VT_ENTERSCENARIOKEY: flatbuffers::VOffsetT = 50;
  pub const VT_CLEARSCENARIOKEY: flatbuffers::VOffsetT = 52;
  pub const VT_USEFIXEDECHELON: flatbuffers::VOffsetT = 54;
  pub const VT_FIXEDECHELONID: flatbuffers::VOffsetT = 56;
  pub const VT_ISRAIDSCENARIOBATTLE: flatbuffers::VOffsetT = 58;
  pub const VT_SHOWSKILLCARD: flatbuffers::VOffsetT = 60;
  pub const VT_BOSSBGINFOKEY: flatbuffers::VOffsetT = 62;
  pub const VT_DAMAGETOWORLDBOSS: flatbuffers::VOffsetT = 64;
  pub const VT_ALLYPASSIVESKILL: flatbuffers::VOffsetT = 66;
  pub const VT_ALLYPASSIVESKILLLEVEL: flatbuffers::VOffsetT = 68;
  pub const VT_SAVECURRENTLOCALBOSSHP: flatbuffers::VOffsetT = 70;
  pub const VT_ECHELONEXTENSIONTYPE: flatbuffers::VOffsetT = 72;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    WorldRaidStageExcel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args WorldRaidStageExcelArgs<'args>
  ) -> flatbuffers::WIPOffset<WorldRaidStageExcel<'bldr>> {
    let mut builder = WorldRaidStageExcelBuilder::new(_fbb);
    let key = table_encryption_service::create_key(b"WorldRaidStage");
      let x = args.DamageToWorldBoss;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_DamageToWorldBoss(x);
      let x = args.FixedEchelonId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_FixedEchelonId(x);
      let x = args.ClearScenarioKey;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_ClearScenarioKey(x);
      let x = args.EnterScenarioKey;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_EnterScenarioKey(x);
      let x = args.TimeLinePhase;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_TimeLinePhase(x);
      let x = args.RaidRewardGroupId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_RaidRewardGroupId(x);
      let x = args.RaidBattleEndRewardGroupId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_RaidBattleEndRewardGroupId(x);
      let x = args.GroundId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_GroundId(x);
      let x = args.BattleDuration;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_BattleDuration(x);
      let x = args.ReEnterAmount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_ReEnterAmount(x);
      let x = args.RaidEnterAmount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_RaidEnterAmount(x);
      let x = args.AssistCharacterLimitCount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_AssistCharacterLimitCount(x);
      let x = args.RaidCharacterId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_RaidCharacterId(x);
      let x = args.WorldRaidBossGroupId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_WorldRaidBossGroupId(x);
      let x = args.Id;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_Id(x);
      let x = args.EchelonExtensionType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_EchelonExtensionType(x);
      if let Some(x) = args.AllyPassiveSkillLevel {
        builder.add_AllyPassiveSkillLevel(x);
      }
      if let Some(x) = args.AllyPassiveSkill {
        builder.add_AllyPassiveSkill(x);
      }
      let x = args.BossBGInfoKey;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_uint(x, &key) } else { x };
      builder.add_BossBGInfoKey(x);
      if let Some(x) = args.PhaseChangeTimelinePath {
        builder.add_PhaseChangeTimelinePath(x);
      }
      if let Some(x) = args.VictoryTimelinePath {
        builder.add_VictoryTimelinePath(x);
      }
      if let Some(x) = args.BattleReadyTimelinePhaseEnd {
        builder.add_BattleReadyTimelinePhaseEnd(x);
      }
      if let Some(x) = args.BattleReadyTimelinePhaseStart {
        builder.add_BattleReadyTimelinePhaseStart(x);
      }
      if let Some(x) = args.BattleReadyTimelinePath {
        builder.add_BattleReadyTimelinePath(x);
      }
      let x = args.WorldRaidDifficulty;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_WorldRaidDifficulty(x);
      if let Some(x) = args.BossCharacterId {
        builder.add_BossCharacterId(x);
      }
      if let Some(x) = args.BGPath {
        builder.add_BGPath(x);
      }
      if let Some(x) = args.PortraitPath {
        builder.add_PortraitPath(x);
      }
      builder.add_SaveCurrentLocalBossHP(args.SaveCurrentLocalBossHP);
      builder.add_ShowSkillCard(args.ShowSkillCard);
      builder.add_IsRaidScenarioBattle(args.IsRaidScenarioBattle);
      builder.add_UseFixedEchelon(args.UseFixedEchelon);
      builder.add_DifficultyOpenCondition(args.DifficultyOpenCondition);
      builder.add_UseBossAIPhaseSync(args.UseBossAIPhaseSync);
      builder.add_UseBossIndex(args.UseBossIndex);
    builder.finish()
  }

  pub fn unpack(&self) -> WorldRaidStageExcelT {
    let key = table_encryption_service::create_key(b"WorldRaidStage");
      let Id = self.Id();
      let UseBossIndex = self.UseBossIndex();
      let UseBossAIPhaseSync = self.UseBossAIPhaseSync();
      let WorldRaidBossGroupId = self.WorldRaidBossGroupId();
    let PortraitPath = self.PortraitPath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let BGPath = self.BGPath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let RaidCharacterId = self.RaidCharacterId();
    let BossCharacterId = self.BossCharacterId().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_long(*val, &key) } else { *val }).collect()
    });
      let AssistCharacterLimitCount = self.AssistCharacterLimitCount();
      let WorldRaidDifficulty = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.WorldRaidDifficulty(), &key)
      } else {
        self.WorldRaidDifficulty()
      };
      let DifficultyOpenCondition = self.DifficultyOpenCondition();
      let RaidEnterAmount = self.RaidEnterAmount();
      let ReEnterAmount = self.ReEnterAmount();
      let BattleDuration = self.BattleDuration();
      let GroundId = self.GroundId();
      let RaidBattleEndRewardGroupId = self.RaidBattleEndRewardGroupId();
      let RaidRewardGroupId = self.RaidRewardGroupId();
    let BattleReadyTimelinePath = self.BattleReadyTimelinePath().map(|x| {
      x.iter().map(|s| if table_encryption_service::use_encryption() { table_encryption_service::convert_string(s, &key).unwrap() } else { s.to_string() }).collect()
    });
    let BattleReadyTimelinePhaseStart = self.BattleReadyTimelinePhaseStart().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_int(*val, &key) } else { *val }).collect()
    });
    let BattleReadyTimelinePhaseEnd = self.BattleReadyTimelinePhaseEnd().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_int(*val, &key) } else { *val }).collect()
    });
    let VictoryTimelinePath = self.VictoryTimelinePath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let PhaseChangeTimelinePath = self.PhaseChangeTimelinePath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let TimeLinePhase = self.TimeLinePhase();
      let EnterScenarioKey = self.EnterScenarioKey();
      let ClearScenarioKey = self.ClearScenarioKey();
      let UseFixedEchelon = self.UseFixedEchelon();
      let FixedEchelonId = self.FixedEchelonId();
      let IsRaidScenarioBattle = self.IsRaidScenarioBattle();
      let ShowSkillCard = self.ShowSkillCard();
      let BossBGInfoKey = self.BossBGInfoKey();
      let DamageToWorldBoss = self.DamageToWorldBoss();
    let AllyPassiveSkill = self.AllyPassiveSkill().map(|x| {
      x.iter().map(|s| if table_encryption_service::use_encryption() { table_encryption_service::convert_string(s, &key).unwrap() } else { s.to_string() }).collect()
    });
    let AllyPassiveSkillLevel = self.AllyPassiveSkillLevel().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_int(*val, &key) } else { *val }).collect()
    });
      let SaveCurrentLocalBossHP = self.SaveCurrentLocalBossHP();
      let EchelonExtensionType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.EchelonExtensionType(), &key)
      } else {
        self.EchelonExtensionType()
      };
    WorldRaidStageExcelT {
      Id,
      UseBossIndex,
      UseBossAIPhaseSync,
      WorldRaidBossGroupId,
      PortraitPath,
      BGPath,
      RaidCharacterId,
      BossCharacterId,
      AssistCharacterLimitCount,
      WorldRaidDifficulty,
      DifficultyOpenCondition,
      RaidEnterAmount,
      ReEnterAmount,
      BattleDuration,
      GroundId,
      RaidBattleEndRewardGroupId,
      RaidRewardGroupId,
      BattleReadyTimelinePath,
      BattleReadyTimelinePhaseStart,
      BattleReadyTimelinePhaseEnd,
      VictoryTimelinePath,
      PhaseChangeTimelinePath,
      TimeLinePhase,
      EnterScenarioKey,
      ClearScenarioKey,
      UseFixedEchelon,
      FixedEchelonId,
      IsRaidScenarioBattle,
      ShowSkillCard,
      BossBGInfoKey,
      DamageToWorldBoss,
      AllyPassiveSkill,
      AllyPassiveSkillLevel,
      SaveCurrentLocalBossHP,
      EchelonExtensionType,
    }
  }

  #[inline]
  pub fn Id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(WorldRaidStageExcel::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn UseBossIndex(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(WorldRaidStageExcel::VT_USEBOSSINDEX, Some(false)).unwrap()}
  }
  #[inline]
  pub fn UseBossAIPhaseSync(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(WorldRaidStageExcel::VT_USEBOSSAIPHASESYNC, Some(false)).unwrap()}
  }
  #[inline]
  pub fn WorldRaidBossGroupId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(WorldRaidStageExcel::VT_WORLDRAIDBOSSGROUPID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn PortraitPath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WorldRaidStageExcel::VT_PORTRAITPATH, None)}
  }
  #[inline]
  pub fn BGPath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WorldRaidStageExcel::VT_BGPATH, None)}
  }
  #[inline]
  pub fn RaidCharacterId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(WorldRaidStageExcel::VT_RAIDCHARACTERID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn BossCharacterId(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(WorldRaidStageExcel::VT_BOSSCHARACTERID, None)}
  }
  #[inline]
  pub fn AssistCharacterLimitCount(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(WorldRaidStageExcel::VT_ASSISTCHARACTERLIMITCOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn WorldRaidDifficulty(&self) -> WorldRaidDifficulty {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<WorldRaidDifficulty>(WorldRaidStageExcel::VT_WORLDRAIDDIFFICULTY, Some(WorldRaidDifficulty::None)).unwrap()}
  }
  #[inline]
  pub fn DifficultyOpenCondition(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(WorldRaidStageExcel::VT_DIFFICULTYOPENCONDITION, Some(false)).unwrap()}
  }
  #[inline]
  pub fn RaidEnterAmount(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(WorldRaidStageExcel::VT_RAIDENTERAMOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ReEnterAmount(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(WorldRaidStageExcel::VT_REENTERAMOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn BattleDuration(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(WorldRaidStageExcel::VT_BATTLEDURATION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn GroundId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(WorldRaidStageExcel::VT_GROUNDID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn RaidBattleEndRewardGroupId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(WorldRaidStageExcel::VT_RAIDBATTLEENDREWARDGROUPID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn RaidRewardGroupId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(WorldRaidStageExcel::VT_RAIDREWARDGROUPID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn BattleReadyTimelinePath(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(WorldRaidStageExcel::VT_BATTLEREADYTIMELINEPATH, None)}
  }
  #[inline]
  pub fn BattleReadyTimelinePhaseStart(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(WorldRaidStageExcel::VT_BATTLEREADYTIMELINEPHASESTART, None)}
  }
  #[inline]
  pub fn BattleReadyTimelinePhaseEnd(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(WorldRaidStageExcel::VT_BATTLEREADYTIMELINEPHASEEND, None)}
  }
  #[inline]
  pub fn VictoryTimelinePath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WorldRaidStageExcel::VT_VICTORYTIMELINEPATH, None)}
  }
  #[inline]
  pub fn PhaseChangeTimelinePath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WorldRaidStageExcel::VT_PHASECHANGETIMELINEPATH, None)}
  }
  #[inline]
  pub fn TimeLinePhase(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(WorldRaidStageExcel::VT_TIMELINEPHASE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EnterScenarioKey(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(WorldRaidStageExcel::VT_ENTERSCENARIOKEY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ClearScenarioKey(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(WorldRaidStageExcel::VT_CLEARSCENARIOKEY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn UseFixedEchelon(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(WorldRaidStageExcel::VT_USEFIXEDECHELON, Some(false)).unwrap()}
  }
  #[inline]
  pub fn FixedEchelonId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(WorldRaidStageExcel::VT_FIXEDECHELONID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn IsRaidScenarioBattle(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(WorldRaidStageExcel::VT_ISRAIDSCENARIOBATTLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn ShowSkillCard(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(WorldRaidStageExcel::VT_SHOWSKILLCARD, Some(false)).unwrap()}
  }
  #[inline]
  pub fn BossBGInfoKey(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(WorldRaidStageExcel::VT_BOSSBGINFOKEY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn DamageToWorldBoss(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(WorldRaidStageExcel::VT_DAMAGETOWORLDBOSS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn AllyPassiveSkill(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(WorldRaidStageExcel::VT_ALLYPASSIVESKILL, None)}
  }
  #[inline]
  pub fn AllyPassiveSkillLevel(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(WorldRaidStageExcel::VT_ALLYPASSIVESKILLLEVEL, None)}
  }
  #[inline]
  pub fn SaveCurrentLocalBossHP(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(WorldRaidStageExcel::VT_SAVECURRENTLOCALBOSSHP, Some(false)).unwrap()}
  }
  #[inline]
  pub fn EchelonExtensionType(&self) -> EchelonExtensionType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<EchelonExtensionType>(WorldRaidStageExcel::VT_ECHELONEXTENSIONTYPE, Some(EchelonExtensionType::Base)).unwrap()}
  }
}

impl flatbuffers::Verifiable for WorldRaidStageExcel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("Id", Self::VT_ID, false)?
     .visit_field::<bool>("UseBossIndex", Self::VT_USEBOSSINDEX, false)?
     .visit_field::<bool>("UseBossAIPhaseSync", Self::VT_USEBOSSAIPHASESYNC, false)?
     .visit_field::<i64>("WorldRaidBossGroupId", Self::VT_WORLDRAIDBOSSGROUPID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PortraitPath", Self::VT_PORTRAITPATH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("BGPath", Self::VT_BGPATH, false)?
     .visit_field::<i64>("RaidCharacterId", Self::VT_RAIDCHARACTERID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("BossCharacterId", Self::VT_BOSSCHARACTERID, false)?
     .visit_field::<i64>("AssistCharacterLimitCount", Self::VT_ASSISTCHARACTERLIMITCOUNT, false)?
     .visit_field::<WorldRaidDifficulty>("WorldRaidDifficulty", Self::VT_WORLDRAIDDIFFICULTY, false)?
     .visit_field::<bool>("DifficultyOpenCondition", Self::VT_DIFFICULTYOPENCONDITION, false)?
     .visit_field::<i64>("RaidEnterAmount", Self::VT_RAIDENTERAMOUNT, false)?
     .visit_field::<i64>("ReEnterAmount", Self::VT_REENTERAMOUNT, false)?
     .visit_field::<i64>("BattleDuration", Self::VT_BATTLEDURATION, false)?
     .visit_field::<i64>("GroundId", Self::VT_GROUNDID, false)?
     .visit_field::<i64>("RaidBattleEndRewardGroupId", Self::VT_RAIDBATTLEENDREWARDGROUPID, false)?
     .visit_field::<i64>("RaidRewardGroupId", Self::VT_RAIDREWARDGROUPID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("BattleReadyTimelinePath", Self::VT_BATTLEREADYTIMELINEPATH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("BattleReadyTimelinePhaseStart", Self::VT_BATTLEREADYTIMELINEPHASESTART, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("BattleReadyTimelinePhaseEnd", Self::VT_BATTLEREADYTIMELINEPHASEEND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("VictoryTimelinePath", Self::VT_VICTORYTIMELINEPATH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PhaseChangeTimelinePath", Self::VT_PHASECHANGETIMELINEPATH, false)?
     .visit_field::<i64>("TimeLinePhase", Self::VT_TIMELINEPHASE, false)?
     .visit_field::<i64>("EnterScenarioKey", Self::VT_ENTERSCENARIOKEY, false)?
     .visit_field::<i64>("ClearScenarioKey", Self::VT_CLEARSCENARIOKEY, false)?
     .visit_field::<bool>("UseFixedEchelon", Self::VT_USEFIXEDECHELON, false)?
     .visit_field::<i64>("FixedEchelonId", Self::VT_FIXEDECHELONID, false)?
     .visit_field::<bool>("IsRaidScenarioBattle", Self::VT_ISRAIDSCENARIOBATTLE, false)?
     .visit_field::<bool>("ShowSkillCard", Self::VT_SHOWSKILLCARD, false)?
     .visit_field::<u32>("BossBGInfoKey", Self::VT_BOSSBGINFOKEY, false)?
     .visit_field::<i64>("DamageToWorldBoss", Self::VT_DAMAGETOWORLDBOSS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("AllyPassiveSkill", Self::VT_ALLYPASSIVESKILL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("AllyPassiveSkillLevel", Self::VT_ALLYPASSIVESKILLLEVEL, false)?
     .visit_field::<bool>("SaveCurrentLocalBossHP", Self::VT_SAVECURRENTLOCALBOSSHP, false)?
     .visit_field::<EchelonExtensionType>("EchelonExtensionType", Self::VT_ECHELONEXTENSIONTYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct WorldRaidStageExcelArgs<'a> {
    pub Id: i64,
    pub UseBossIndex: bool,
    pub UseBossAIPhaseSync: bool,
    pub WorldRaidBossGroupId: i64,
    pub PortraitPath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub BGPath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub RaidCharacterId: i64,
    pub BossCharacterId: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub AssistCharacterLimitCount: i64,
    pub WorldRaidDifficulty: WorldRaidDifficulty,
    pub DifficultyOpenCondition: bool,
    pub RaidEnterAmount: i64,
    pub ReEnterAmount: i64,
    pub BattleDuration: i64,
    pub GroundId: i64,
    pub RaidBattleEndRewardGroupId: i64,
    pub RaidRewardGroupId: i64,
    pub BattleReadyTimelinePath: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub BattleReadyTimelinePhaseStart: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub BattleReadyTimelinePhaseEnd: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub VictoryTimelinePath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PhaseChangeTimelinePath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TimeLinePhase: i64,
    pub EnterScenarioKey: i64,
    pub ClearScenarioKey: i64,
    pub UseFixedEchelon: bool,
    pub FixedEchelonId: i64,
    pub IsRaidScenarioBattle: bool,
    pub ShowSkillCard: bool,
    pub BossBGInfoKey: u32,
    pub DamageToWorldBoss: i64,
    pub AllyPassiveSkill: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub AllyPassiveSkillLevel: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub SaveCurrentLocalBossHP: bool,
    pub EchelonExtensionType: EchelonExtensionType,
}
impl<'a> Default for WorldRaidStageExcelArgs<'a> {
  #[inline]
  fn default() -> Self {
    WorldRaidStageExcelArgs {
      Id: 0,
      UseBossIndex: false,
      UseBossAIPhaseSync: false,
      WorldRaidBossGroupId: 0,
      PortraitPath: None,
      BGPath: None,
      RaidCharacterId: 0,
      BossCharacterId: None,
      AssistCharacterLimitCount: 0,
      WorldRaidDifficulty: WorldRaidDifficulty::None,
      DifficultyOpenCondition: false,
      RaidEnterAmount: 0,
      ReEnterAmount: 0,
      BattleDuration: 0,
      GroundId: 0,
      RaidBattleEndRewardGroupId: 0,
      RaidRewardGroupId: 0,
      BattleReadyTimelinePath: None,
      BattleReadyTimelinePhaseStart: None,
      BattleReadyTimelinePhaseEnd: None,
      VictoryTimelinePath: None,
      PhaseChangeTimelinePath: None,
      TimeLinePhase: 0,
      EnterScenarioKey: 0,
      ClearScenarioKey: 0,
      UseFixedEchelon: false,
      FixedEchelonId: 0,
      IsRaidScenarioBattle: false,
      ShowSkillCard: false,
      BossBGInfoKey: 0,
      DamageToWorldBoss: 0,
      AllyPassiveSkill: None,
      AllyPassiveSkillLevel: None,
      SaveCurrentLocalBossHP: false,
      EchelonExtensionType: EchelonExtensionType::Base,
    }
  }
}

impl Serialize for WorldRaidStageExcel<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("WorldRaidStageExcel", 35)?;
      s.serialize_field("Id", &self.Id())?;
      s.serialize_field("UseBossIndex", &self.UseBossIndex())?;
      s.serialize_field("UseBossAIPhaseSync", &self.UseBossAIPhaseSync())?;
      s.serialize_field("WorldRaidBossGroupId", &self.WorldRaidBossGroupId())?;
      if let Some(f) = self.PortraitPath() {
        s.serialize_field("PortraitPath", &f)?;
      } else {
        s.skip_field("PortraitPath")?;
      }
      if let Some(f) = self.BGPath() {
        s.serialize_field("BGPath", &f)?;
      } else {
        s.skip_field("BGPath")?;
      }
      s.serialize_field("RaidCharacterId", &self.RaidCharacterId())?;
      if let Some(f) = self.BossCharacterId() {
        s.serialize_field("BossCharacterId", &f)?;
      } else {
        s.skip_field("BossCharacterId")?;
      }
      s.serialize_field("AssistCharacterLimitCount", &self.AssistCharacterLimitCount())?;
      s.serialize_field("WorldRaidDifficulty", &self.WorldRaidDifficulty())?;
      s.serialize_field("DifficultyOpenCondition", &self.DifficultyOpenCondition())?;
      s.serialize_field("RaidEnterAmount", &self.RaidEnterAmount())?;
      s.serialize_field("ReEnterAmount", &self.ReEnterAmount())?;
      s.serialize_field("BattleDuration", &self.BattleDuration())?;
      s.serialize_field("GroundId", &self.GroundId())?;
      s.serialize_field("RaidBattleEndRewardGroupId", &self.RaidBattleEndRewardGroupId())?;
      s.serialize_field("RaidRewardGroupId", &self.RaidRewardGroupId())?;
      if let Some(f) = self.BattleReadyTimelinePath() {
        s.serialize_field("BattleReadyTimelinePath", &f)?;
      } else {
        s.skip_field("BattleReadyTimelinePath")?;
      }
      if let Some(f) = self.BattleReadyTimelinePhaseStart() {
        s.serialize_field("BattleReadyTimelinePhaseStart", &f)?;
      } else {
        s.skip_field("BattleReadyTimelinePhaseStart")?;
      }
      if let Some(f) = self.BattleReadyTimelinePhaseEnd() {
        s.serialize_field("BattleReadyTimelinePhaseEnd", &f)?;
      } else {
        s.skip_field("BattleReadyTimelinePhaseEnd")?;
      }
      if let Some(f) = self.VictoryTimelinePath() {
        s.serialize_field("VictoryTimelinePath", &f)?;
      } else {
        s.skip_field("VictoryTimelinePath")?;
      }
      if let Some(f) = self.PhaseChangeTimelinePath() {
        s.serialize_field("PhaseChangeTimelinePath", &f)?;
      } else {
        s.skip_field("PhaseChangeTimelinePath")?;
      }
      s.serialize_field("TimeLinePhase", &self.TimeLinePhase())?;
      s.serialize_field("EnterScenarioKey", &self.EnterScenarioKey())?;
      s.serialize_field("ClearScenarioKey", &self.ClearScenarioKey())?;
      s.serialize_field("UseFixedEchelon", &self.UseFixedEchelon())?;
      s.serialize_field("FixedEchelonId", &self.FixedEchelonId())?;
      s.serialize_field("IsRaidScenarioBattle", &self.IsRaidScenarioBattle())?;
      s.serialize_field("ShowSkillCard", &self.ShowSkillCard())?;
      s.serialize_field("BossBGInfoKey", &self.BossBGInfoKey())?;
      s.serialize_field("DamageToWorldBoss", &self.DamageToWorldBoss())?;
      if let Some(f) = self.AllyPassiveSkill() {
        s.serialize_field("AllyPassiveSkill", &f)?;
      } else {
        s.skip_field("AllyPassiveSkill")?;
      }
      if let Some(f) = self.AllyPassiveSkillLevel() {
        s.serialize_field("AllyPassiveSkillLevel", &f)?;
      } else {
        s.skip_field("AllyPassiveSkillLevel")?;
      }
      s.serialize_field("SaveCurrentLocalBossHP", &self.SaveCurrentLocalBossHP())?;
      s.serialize_field("EchelonExtensionType", &self.EchelonExtensionType())?;
    s.end()
  }
}

pub struct WorldRaidStageExcelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> WorldRaidStageExcelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_Id(&mut self, Id: i64) {
    self.fbb_.push_slot::<i64>(WorldRaidStageExcel::VT_ID, Id, 0);
  }
  #[inline]
  pub fn add_UseBossIndex(&mut self, UseBossIndex: bool) {
    self.fbb_.push_slot::<bool>(WorldRaidStageExcel::VT_USEBOSSINDEX, UseBossIndex, false);
  }
  #[inline]
  pub fn add_UseBossAIPhaseSync(&mut self, UseBossAIPhaseSync: bool) {
    self.fbb_.push_slot::<bool>(WorldRaidStageExcel::VT_USEBOSSAIPHASESYNC, UseBossAIPhaseSync, false);
  }
  #[inline]
  pub fn add_WorldRaidBossGroupId(&mut self, WorldRaidBossGroupId: i64) {
    self.fbb_.push_slot::<i64>(WorldRaidStageExcel::VT_WORLDRAIDBOSSGROUPID, WorldRaidBossGroupId, 0);
  }
  #[inline]
  pub fn add_PortraitPath(&mut self, PortraitPath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WorldRaidStageExcel::VT_PORTRAITPATH, PortraitPath);
  }
  #[inline]
  pub fn add_BGPath(&mut self, BGPath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WorldRaidStageExcel::VT_BGPATH, BGPath);
  }
  #[inline]
  pub fn add_RaidCharacterId(&mut self, RaidCharacterId: i64) {
    self.fbb_.push_slot::<i64>(WorldRaidStageExcel::VT_RAIDCHARACTERID, RaidCharacterId, 0);
  }
  #[inline]
  pub fn add_BossCharacterId(&mut self, BossCharacterId: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WorldRaidStageExcel::VT_BOSSCHARACTERID, BossCharacterId);
  }
  #[inline]
  pub fn add_AssistCharacterLimitCount(&mut self, AssistCharacterLimitCount: i64) {
    self.fbb_.push_slot::<i64>(WorldRaidStageExcel::VT_ASSISTCHARACTERLIMITCOUNT, AssistCharacterLimitCount, 0);
  }
  #[inline]
  pub fn add_WorldRaidDifficulty(&mut self, WorldRaidDifficulty: WorldRaidDifficulty) {
    self.fbb_.push_slot::<WorldRaidDifficulty>(WorldRaidStageExcel::VT_WORLDRAIDDIFFICULTY, WorldRaidDifficulty, WorldRaidDifficulty::None);
  }
  #[inline]
  pub fn add_DifficultyOpenCondition(&mut self, DifficultyOpenCondition: bool) {
    self.fbb_.push_slot::<bool>(WorldRaidStageExcel::VT_DIFFICULTYOPENCONDITION, DifficultyOpenCondition, false);
  }
  #[inline]
  pub fn add_RaidEnterAmount(&mut self, RaidEnterAmount: i64) {
    self.fbb_.push_slot::<i64>(WorldRaidStageExcel::VT_RAIDENTERAMOUNT, RaidEnterAmount, 0);
  }
  #[inline]
  pub fn add_ReEnterAmount(&mut self, ReEnterAmount: i64) {
    self.fbb_.push_slot::<i64>(WorldRaidStageExcel::VT_REENTERAMOUNT, ReEnterAmount, 0);
  }
  #[inline]
  pub fn add_BattleDuration(&mut self, BattleDuration: i64) {
    self.fbb_.push_slot::<i64>(WorldRaidStageExcel::VT_BATTLEDURATION, BattleDuration, 0);
  }
  #[inline]
  pub fn add_GroundId(&mut self, GroundId: i64) {
    self.fbb_.push_slot::<i64>(WorldRaidStageExcel::VT_GROUNDID, GroundId, 0);
  }
  #[inline]
  pub fn add_RaidBattleEndRewardGroupId(&mut self, RaidBattleEndRewardGroupId: i64) {
    self.fbb_.push_slot::<i64>(WorldRaidStageExcel::VT_RAIDBATTLEENDREWARDGROUPID, RaidBattleEndRewardGroupId, 0);
  }
  #[inline]
  pub fn add_RaidRewardGroupId(&mut self, RaidRewardGroupId: i64) {
    self.fbb_.push_slot::<i64>(WorldRaidStageExcel::VT_RAIDREWARDGROUPID, RaidRewardGroupId, 0);
  }
  #[inline]
  pub fn add_BattleReadyTimelinePath(&mut self, BattleReadyTimelinePath: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WorldRaidStageExcel::VT_BATTLEREADYTIMELINEPATH, BattleReadyTimelinePath);
  }
  #[inline]
  pub fn add_BattleReadyTimelinePhaseStart(&mut self, BattleReadyTimelinePhaseStart: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WorldRaidStageExcel::VT_BATTLEREADYTIMELINEPHASESTART, BattleReadyTimelinePhaseStart);
  }
  #[inline]
  pub fn add_BattleReadyTimelinePhaseEnd(&mut self, BattleReadyTimelinePhaseEnd: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WorldRaidStageExcel::VT_BATTLEREADYTIMELINEPHASEEND, BattleReadyTimelinePhaseEnd);
  }
  #[inline]
  pub fn add_VictoryTimelinePath(&mut self, VictoryTimelinePath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WorldRaidStageExcel::VT_VICTORYTIMELINEPATH, VictoryTimelinePath);
  }
  #[inline]
  pub fn add_PhaseChangeTimelinePath(&mut self, PhaseChangeTimelinePath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WorldRaidStageExcel::VT_PHASECHANGETIMELINEPATH, PhaseChangeTimelinePath);
  }
  #[inline]
  pub fn add_TimeLinePhase(&mut self, TimeLinePhase: i64) {
    self.fbb_.push_slot::<i64>(WorldRaidStageExcel::VT_TIMELINEPHASE, TimeLinePhase, 0);
  }
  #[inline]
  pub fn add_EnterScenarioKey(&mut self, EnterScenarioKey: i64) {
    self.fbb_.push_slot::<i64>(WorldRaidStageExcel::VT_ENTERSCENARIOKEY, EnterScenarioKey, 0);
  }
  #[inline]
  pub fn add_ClearScenarioKey(&mut self, ClearScenarioKey: i64) {
    self.fbb_.push_slot::<i64>(WorldRaidStageExcel::VT_CLEARSCENARIOKEY, ClearScenarioKey, 0);
  }
  #[inline]
  pub fn add_UseFixedEchelon(&mut self, UseFixedEchelon: bool) {
    self.fbb_.push_slot::<bool>(WorldRaidStageExcel::VT_USEFIXEDECHELON, UseFixedEchelon, false);
  }
  #[inline]
  pub fn add_FixedEchelonId(&mut self, FixedEchelonId: i64) {
    self.fbb_.push_slot::<i64>(WorldRaidStageExcel::VT_FIXEDECHELONID, FixedEchelonId, 0);
  }
  #[inline]
  pub fn add_IsRaidScenarioBattle(&mut self, IsRaidScenarioBattle: bool) {
    self.fbb_.push_slot::<bool>(WorldRaidStageExcel::VT_ISRAIDSCENARIOBATTLE, IsRaidScenarioBattle, false);
  }
  #[inline]
  pub fn add_ShowSkillCard(&mut self, ShowSkillCard: bool) {
    self.fbb_.push_slot::<bool>(WorldRaidStageExcel::VT_SHOWSKILLCARD, ShowSkillCard, false);
  }
  #[inline]
  pub fn add_BossBGInfoKey(&mut self, BossBGInfoKey: u32) {
    self.fbb_.push_slot::<u32>(WorldRaidStageExcel::VT_BOSSBGINFOKEY, BossBGInfoKey, 0);
  }
  #[inline]
  pub fn add_DamageToWorldBoss(&mut self, DamageToWorldBoss: i64) {
    self.fbb_.push_slot::<i64>(WorldRaidStageExcel::VT_DAMAGETOWORLDBOSS, DamageToWorldBoss, 0);
  }
  #[inline]
  pub fn add_AllyPassiveSkill(&mut self, AllyPassiveSkill: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WorldRaidStageExcel::VT_ALLYPASSIVESKILL, AllyPassiveSkill);
  }
  #[inline]
  pub fn add_AllyPassiveSkillLevel(&mut self, AllyPassiveSkillLevel: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WorldRaidStageExcel::VT_ALLYPASSIVESKILLLEVEL, AllyPassiveSkillLevel);
  }
  #[inline]
  pub fn add_SaveCurrentLocalBossHP(&mut self, SaveCurrentLocalBossHP: bool) {
    self.fbb_.push_slot::<bool>(WorldRaidStageExcel::VT_SAVECURRENTLOCALBOSSHP, SaveCurrentLocalBossHP, false);
  }
  #[inline]
  pub fn add_EchelonExtensionType(&mut self, EchelonExtensionType: EchelonExtensionType) {
    self.fbb_.push_slot::<EchelonExtensionType>(WorldRaidStageExcel::VT_ECHELONEXTENSIONTYPE, EchelonExtensionType, EchelonExtensionType::Base);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> WorldRaidStageExcelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    WorldRaidStageExcelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WorldRaidStageExcel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for WorldRaidStageExcel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("WorldRaidStageExcel");
      ds.field("Id", &self.Id());
      ds.field("UseBossIndex", &self.UseBossIndex());
      ds.field("UseBossAIPhaseSync", &self.UseBossAIPhaseSync());
      ds.field("WorldRaidBossGroupId", &self.WorldRaidBossGroupId());
      ds.field("PortraitPath", &self.PortraitPath());
      ds.field("BGPath", &self.BGPath());
      ds.field("RaidCharacterId", &self.RaidCharacterId());
      ds.field("BossCharacterId", &self.BossCharacterId());
      ds.field("AssistCharacterLimitCount", &self.AssistCharacterLimitCount());
      ds.field("WorldRaidDifficulty", &self.WorldRaidDifficulty());
      ds.field("DifficultyOpenCondition", &self.DifficultyOpenCondition());
      ds.field("RaidEnterAmount", &self.RaidEnterAmount());
      ds.field("ReEnterAmount", &self.ReEnterAmount());
      ds.field("BattleDuration", &self.BattleDuration());
      ds.field("GroundId", &self.GroundId());
      ds.field("RaidBattleEndRewardGroupId", &self.RaidBattleEndRewardGroupId());
      ds.field("RaidRewardGroupId", &self.RaidRewardGroupId());
      ds.field("BattleReadyTimelinePath", &self.BattleReadyTimelinePath());
      ds.field("BattleReadyTimelinePhaseStart", &self.BattleReadyTimelinePhaseStart());
      ds.field("BattleReadyTimelinePhaseEnd", &self.BattleReadyTimelinePhaseEnd());
      ds.field("VictoryTimelinePath", &self.VictoryTimelinePath());
      ds.field("PhaseChangeTimelinePath", &self.PhaseChangeTimelinePath());
      ds.field("TimeLinePhase", &self.TimeLinePhase());
      ds.field("EnterScenarioKey", &self.EnterScenarioKey());
      ds.field("ClearScenarioKey", &self.ClearScenarioKey());
      ds.field("UseFixedEchelon", &self.UseFixedEchelon());
      ds.field("FixedEchelonId", &self.FixedEchelonId());
      ds.field("IsRaidScenarioBattle", &self.IsRaidScenarioBattle());
      ds.field("ShowSkillCard", &self.ShowSkillCard());
      ds.field("BossBGInfoKey", &self.BossBGInfoKey());
      ds.field("DamageToWorldBoss", &self.DamageToWorldBoss());
      ds.field("AllyPassiveSkill", &self.AllyPassiveSkill());
      ds.field("AllyPassiveSkillLevel", &self.AllyPassiveSkillLevel());
      ds.field("SaveCurrentLocalBossHP", &self.SaveCurrentLocalBossHP());
      ds.field("EchelonExtensionType", &self.EchelonExtensionType());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct WorldRaidStageExcelT {
  pub Id: i64,
  pub UseBossIndex: bool,
  pub UseBossAIPhaseSync: bool,
  pub WorldRaidBossGroupId: i64,
  pub PortraitPath: Option<String>,
  pub BGPath: Option<String>,
  pub RaidCharacterId: i64,
  pub BossCharacterId: Option<Vec<i64>>,
  pub AssistCharacterLimitCount: i64,
  pub WorldRaidDifficulty: WorldRaidDifficulty,
  pub DifficultyOpenCondition: bool,
  pub RaidEnterAmount: i64,
  pub ReEnterAmount: i64,
  pub BattleDuration: i64,
  pub GroundId: i64,
  pub RaidBattleEndRewardGroupId: i64,
  pub RaidRewardGroupId: i64,
  pub BattleReadyTimelinePath: Option<Vec<String>>,
  pub BattleReadyTimelinePhaseStart: Option<Vec<i32>>,
  pub BattleReadyTimelinePhaseEnd: Option<Vec<i32>>,
  pub VictoryTimelinePath: Option<String>,
  pub PhaseChangeTimelinePath: Option<String>,
  pub TimeLinePhase: i64,
  pub EnterScenarioKey: i64,
  pub ClearScenarioKey: i64,
  pub UseFixedEchelon: bool,
  pub FixedEchelonId: i64,
  pub IsRaidScenarioBattle: bool,
  pub ShowSkillCard: bool,
  pub BossBGInfoKey: u32,
  pub DamageToWorldBoss: i64,
  pub AllyPassiveSkill: Option<Vec<String>>,
  pub AllyPassiveSkillLevel: Option<Vec<i32>>,
  pub SaveCurrentLocalBossHP: bool,
  pub EchelonExtensionType: EchelonExtensionType,
}
impl Default for WorldRaidStageExcelT {
  fn default() -> Self {
    Self {
      Id: 0,
      UseBossIndex: false,
      UseBossAIPhaseSync: false,
      WorldRaidBossGroupId: 0,
      PortraitPath: None,
      BGPath: None,
      RaidCharacterId: 0,
      BossCharacterId: None,
      AssistCharacterLimitCount: 0,
      WorldRaidDifficulty: WorldRaidDifficulty::None,
      DifficultyOpenCondition: false,
      RaidEnterAmount: 0,
      ReEnterAmount: 0,
      BattleDuration: 0,
      GroundId: 0,
      RaidBattleEndRewardGroupId: 0,
      RaidRewardGroupId: 0,
      BattleReadyTimelinePath: None,
      BattleReadyTimelinePhaseStart: None,
      BattleReadyTimelinePhaseEnd: None,
      VictoryTimelinePath: None,
      PhaseChangeTimelinePath: None,
      TimeLinePhase: 0,
      EnterScenarioKey: 0,
      ClearScenarioKey: 0,
      UseFixedEchelon: false,
      FixedEchelonId: 0,
      IsRaidScenarioBattle: false,
      ShowSkillCard: false,
      BossBGInfoKey: 0,
      DamageToWorldBoss: 0,
      AllyPassiveSkill: None,
      AllyPassiveSkillLevel: None,
      SaveCurrentLocalBossHP: false,
      EchelonExtensionType: EchelonExtensionType::Base,
    }
  }
}
impl WorldRaidStageExcelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<WorldRaidStageExcel<'b>> {
    let Id = self.Id;
    let UseBossIndex = self.UseBossIndex;
    let UseBossAIPhaseSync = self.UseBossAIPhaseSync;
    let WorldRaidBossGroupId = self.WorldRaidBossGroupId;
    let PortraitPath = self.PortraitPath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let BGPath = self.BGPath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let RaidCharacterId = self.RaidCharacterId;
    let BossCharacterId = self.BossCharacterId.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let AssistCharacterLimitCount = self.AssistCharacterLimitCount;
    let WorldRaidDifficulty = self.WorldRaidDifficulty;
    let DifficultyOpenCondition = self.DifficultyOpenCondition;
    let RaidEnterAmount = self.RaidEnterAmount;
    let ReEnterAmount = self.ReEnterAmount;
    let BattleDuration = self.BattleDuration;
    let GroundId = self.GroundId;
    let RaidBattleEndRewardGroupId = self.RaidBattleEndRewardGroupId;
    let RaidRewardGroupId = self.RaidRewardGroupId;
    let BattleReadyTimelinePath = self.BattleReadyTimelinePath.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let BattleReadyTimelinePhaseStart = self.BattleReadyTimelinePhaseStart.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let BattleReadyTimelinePhaseEnd = self.BattleReadyTimelinePhaseEnd.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let VictoryTimelinePath = self.VictoryTimelinePath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PhaseChangeTimelinePath = self.PhaseChangeTimelinePath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TimeLinePhase = self.TimeLinePhase;
    let EnterScenarioKey = self.EnterScenarioKey;
    let ClearScenarioKey = self.ClearScenarioKey;
    let UseFixedEchelon = self.UseFixedEchelon;
    let FixedEchelonId = self.FixedEchelonId;
    let IsRaidScenarioBattle = self.IsRaidScenarioBattle;
    let ShowSkillCard = self.ShowSkillCard;
    let BossBGInfoKey = self.BossBGInfoKey;
    let DamageToWorldBoss = self.DamageToWorldBoss;
    let AllyPassiveSkill = self.AllyPassiveSkill.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let AllyPassiveSkillLevel = self.AllyPassiveSkillLevel.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let SaveCurrentLocalBossHP = self.SaveCurrentLocalBossHP;
    let EchelonExtensionType = self.EchelonExtensionType;
    WorldRaidStageExcel::create(_fbb, &WorldRaidStageExcelArgs{
      Id,
      UseBossIndex,
      UseBossAIPhaseSync,
      WorldRaidBossGroupId,
      PortraitPath,
      BGPath,
      RaidCharacterId,
      BossCharacterId,
      AssistCharacterLimitCount,
      WorldRaidDifficulty,
      DifficultyOpenCondition,
      RaidEnterAmount,
      ReEnterAmount,
      BattleDuration,
      GroundId,
      RaidBattleEndRewardGroupId,
      RaidRewardGroupId,
      BattleReadyTimelinePath,
      BattleReadyTimelinePhaseStart,
      BattleReadyTimelinePhaseEnd,
      VictoryTimelinePath,
      PhaseChangeTimelinePath,
      TimeLinePhase,
      EnterScenarioKey,
      ClearScenarioKey,
      UseFixedEchelon,
      FixedEchelonId,
      IsRaidScenarioBattle,
      ShowSkillCard,
      BossBGInfoKey,
      DamageToWorldBoss,
      AllyPassiveSkill,
      AllyPassiveSkillLevel,
      SaveCurrentLocalBossHP,
      EchelonExtensionType,
    })
  }
}
