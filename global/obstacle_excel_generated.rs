// automatically generated by the FlatBuffers compiler, do not modify
// @generated
#![allow(unused_imports, dead_code)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum ObstacleExcelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ObstacleExcel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ObstacleExcel<'a> {
  type Inner = ObstacleExcel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ObstacleExcel<'a> {
  pub const VT_INDEX: flatbuffers::VOffsetT = 4;
  pub const VT_PREFABNAME: flatbuffers::VOffsetT = 6;
  pub const VT_JUMPABLE: flatbuffers::VOffsetT = 8;
  pub const VT_SUBOFFSET: flatbuffers::VOffsetT = 10;
  pub const VT_X: flatbuffers::VOffsetT = 12;
  pub const VT_Z: flatbuffers::VOffsetT = 14;
  pub const VT_HP: flatbuffers::VOffsetT = 16;
  pub const VT_MAXHP: flatbuffers::VOffsetT = 18;
  pub const VT_BLOCKRATE: flatbuffers::VOffsetT = 20;
  pub const VT_EVASIONRATE: flatbuffers::VOffsetT = 22;
  pub const VT_DESTROYTYPE: flatbuffers::VOffsetT = 24;
  pub const VT_POINT1OFFESET: flatbuffers::VOffsetT = 26;
  pub const VT_ENEMYPOINT1OSSET: flatbuffers::VOffsetT = 28;
  pub const VT_POINT2OFFESET: flatbuffers::VOffsetT = 30;
  pub const VT_ENEMYPOINT2OSSET: flatbuffers::VOffsetT = 32;
  pub const VT_SUBOBSTACLEID: flatbuffers::VOffsetT = 34;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ObstacleExcel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ObstacleExcelArgs<'args>
  ) -> flatbuffers::WIPOffset<ObstacleExcel<'bldr>> {
    let mut builder = ObstacleExcelBuilder::new(_fbb);
    let key = table_encryption_service::create_key(b"Obstacle");
      let x = args.MaxHp;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_MaxHp(x);
      let x = args.Hp;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_Hp(x);
      let x = args.Index;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_Index(x);
      if let Some(x) = args.SubObstacleID {
        builder.add_SubObstacleID(x);
      }
      if let Some(x) = args.EnemyPoint2Osset {
        builder.add_EnemyPoint2Osset(x);
      }
      if let Some(x) = args.Point2Offeset {
        builder.add_Point2Offeset(x);
      }
      if let Some(x) = args.EnemyPoint1Osset {
        builder.add_EnemyPoint1Osset(x);
      }
      if let Some(x) = args.Point1Offeset {
        builder.add_Point1Offeset(x);
      }
      let x = args.DestroyType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_DestroyType(x);
      let x = args.EvasionRate;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_EvasionRate(x);
      let x = args.BlockRate;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_BlockRate(x);
      let x = args.Z;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_Z(x);
      let x = args.X;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_X(x);
      if let Some(x) = args.SubOffset {
        builder.add_SubOffset(x);
      }
      if let Some(x) = args.PrefabName {
        builder.add_PrefabName(x);
      }
      builder.add_JumpAble(args.JumpAble);
    builder.finish()
  }

  pub fn unpack(&self) -> ObstacleExcelT {
    let key = table_encryption_service::create_key(b"Obstacle");
      let Index = self.Index();
    let PrefabName = self.PrefabName().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let JumpAble = self.JumpAble();
    let SubOffset = self.SubOffset().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_float(*val, &key) } else { *val }).collect()
    });
      let X = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.X(), &key)
      } else {
        self.X()
      };
      let Z = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.Z(), &key)
      } else {
        self.Z()
      };
      let Hp = self.Hp();
      let MaxHp = self.MaxHp();
      let BlockRate = self.BlockRate();
      let EvasionRate = self.EvasionRate();
      let DestroyType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.DestroyType(), &key)
      } else {
        self.DestroyType()
      };
    let Point1Offeset = self.Point1Offeset().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_float(*val, &key) } else { *val }).collect()
    });
    let EnemyPoint1Osset = self.EnemyPoint1Osset().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_float(*val, &key) } else { *val }).collect()
    });
    let Point2Offeset = self.Point2Offeset().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_float(*val, &key) } else { *val }).collect()
    });
    let EnemyPoint2Osset = self.EnemyPoint2Osset().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_float(*val, &key) } else { *val }).collect()
    });
    let SubObstacleID = self.SubObstacleID().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_long(*val, &key) } else { *val }).collect()
    });
    ObstacleExcelT {
      Index,
      PrefabName,
      JumpAble,
      SubOffset,
      X,
      Z,
      Hp,
      MaxHp,
      BlockRate,
      EvasionRate,
      DestroyType,
      Point1Offeset,
      EnemyPoint1Osset,
      Point2Offeset,
      EnemyPoint2Osset,
      SubObstacleID,
    }
  }

  #[inline]
  pub fn Index(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ObstacleExcel::VT_INDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn PrefabName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ObstacleExcel::VT_PREFABNAME, None)}
  }
  #[inline]
  pub fn JumpAble(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ObstacleExcel::VT_JUMPABLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn SubOffset(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(ObstacleExcel::VT_SUBOFFSET, None)}
  }
  #[inline]
  pub fn X(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ObstacleExcel::VT_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn Z(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ObstacleExcel::VT_Z, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn Hp(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ObstacleExcel::VT_HP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn MaxHp(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ObstacleExcel::VT_MAXHP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn BlockRate(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ObstacleExcel::VT_BLOCKRATE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EvasionRate(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ObstacleExcel::VT_EVASIONRATE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn DestroyType(&self) -> ObstacleDestroyType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ObstacleDestroyType>(ObstacleExcel::VT_DESTROYTYPE, Some(ObstacleDestroyType::Remain)).unwrap()}
  }
  #[inline]
  pub fn Point1Offeset(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(ObstacleExcel::VT_POINT1OFFESET, None)}
  }
  #[inline]
  pub fn EnemyPoint1Osset(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(ObstacleExcel::VT_ENEMYPOINT1OSSET, None)}
  }
  #[inline]
  pub fn Point2Offeset(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(ObstacleExcel::VT_POINT2OFFESET, None)}
  }
  #[inline]
  pub fn EnemyPoint2Osset(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(ObstacleExcel::VT_ENEMYPOINT2OSSET, None)}
  }
  #[inline]
  pub fn SubObstacleID(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(ObstacleExcel::VT_SUBOBSTACLEID, None)}
  }
}

impl flatbuffers::Verifiable for ObstacleExcel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("Index", Self::VT_INDEX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PrefabName", Self::VT_PREFABNAME, false)?
     .visit_field::<bool>("JumpAble", Self::VT_JUMPABLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>("SubOffset", Self::VT_SUBOFFSET, false)?
     .visit_field::<f32>("X", Self::VT_X, false)?
     .visit_field::<f32>("Z", Self::VT_Z, false)?
     .visit_field::<i64>("Hp", Self::VT_HP, false)?
     .visit_field::<i64>("MaxHp", Self::VT_MAXHP, false)?
     .visit_field::<i32>("BlockRate", Self::VT_BLOCKRATE, false)?
     .visit_field::<i32>("EvasionRate", Self::VT_EVASIONRATE, false)?
     .visit_field::<ObstacleDestroyType>("DestroyType", Self::VT_DESTROYTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>("Point1Offeset", Self::VT_POINT1OFFESET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>("EnemyPoint1Osset", Self::VT_ENEMYPOINT1OSSET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>("Point2Offeset", Self::VT_POINT2OFFESET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>("EnemyPoint2Osset", Self::VT_ENEMYPOINT2OSSET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("SubObstacleID", Self::VT_SUBOBSTACLEID, false)?
     .finish();
    Ok(())
  }
}
pub struct ObstacleExcelArgs<'a> {
    pub Index: i64,
    pub PrefabName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub JumpAble: bool,
    pub SubOffset: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub X: f32,
    pub Z: f32,
    pub Hp: i64,
    pub MaxHp: i64,
    pub BlockRate: i32,
    pub EvasionRate: i32,
    pub DestroyType: ObstacleDestroyType,
    pub Point1Offeset: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub EnemyPoint1Osset: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub Point2Offeset: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub EnemyPoint2Osset: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub SubObstacleID: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
}
impl<'a> Default for ObstacleExcelArgs<'a> {
  #[inline]
  fn default() -> Self {
    ObstacleExcelArgs {
      Index: 0,
      PrefabName: None,
      JumpAble: false,
      SubOffset: None,
      X: 0.0,
      Z: 0.0,
      Hp: 0,
      MaxHp: 0,
      BlockRate: 0,
      EvasionRate: 0,
      DestroyType: ObstacleDestroyType::Remain,
      Point1Offeset: None,
      EnemyPoint1Osset: None,
      Point2Offeset: None,
      EnemyPoint2Osset: None,
      SubObstacleID: None,
    }
  }
}

impl Serialize for ObstacleExcel<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("ObstacleExcel", 16)?;
      s.serialize_field("Index", &self.Index())?;
      if let Some(f) = self.PrefabName() {
        s.serialize_field("PrefabName", &f)?;
      } else {
        s.skip_field("PrefabName")?;
      }
      s.serialize_field("JumpAble", &self.JumpAble())?;
      if let Some(f) = self.SubOffset() {
        s.serialize_field("SubOffset", &f)?;
      } else {
        s.skip_field("SubOffset")?;
      }
      s.serialize_field("X", &self.X())?;
      s.serialize_field("Z", &self.Z())?;
      s.serialize_field("Hp", &self.Hp())?;
      s.serialize_field("MaxHp", &self.MaxHp())?;
      s.serialize_field("BlockRate", &self.BlockRate())?;
      s.serialize_field("EvasionRate", &self.EvasionRate())?;
      s.serialize_field("DestroyType", &self.DestroyType())?;
      if let Some(f) = self.Point1Offeset() {
        s.serialize_field("Point1Offeset", &f)?;
      } else {
        s.skip_field("Point1Offeset")?;
      }
      if let Some(f) = self.EnemyPoint1Osset() {
        s.serialize_field("EnemyPoint1Osset", &f)?;
      } else {
        s.skip_field("EnemyPoint1Osset")?;
      }
      if let Some(f) = self.Point2Offeset() {
        s.serialize_field("Point2Offeset", &f)?;
      } else {
        s.skip_field("Point2Offeset")?;
      }
      if let Some(f) = self.EnemyPoint2Osset() {
        s.serialize_field("EnemyPoint2Osset", &f)?;
      } else {
        s.skip_field("EnemyPoint2Osset")?;
      }
      if let Some(f) = self.SubObstacleID() {
        s.serialize_field("SubObstacleID", &f)?;
      } else {
        s.skip_field("SubObstacleID")?;
      }
    s.end()
  }
}

pub struct ObstacleExcelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ObstacleExcelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_Index(&mut self, Index: i64) {
    self.fbb_.push_slot::<i64>(ObstacleExcel::VT_INDEX, Index, 0);
  }
  #[inline]
  pub fn add_PrefabName(&mut self, PrefabName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ObstacleExcel::VT_PREFABNAME, PrefabName);
  }
  #[inline]
  pub fn add_JumpAble(&mut self, JumpAble: bool) {
    self.fbb_.push_slot::<bool>(ObstacleExcel::VT_JUMPABLE, JumpAble, false);
  }
  #[inline]
  pub fn add_SubOffset(&mut self, SubOffset: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ObstacleExcel::VT_SUBOFFSET, SubOffset);
  }
  #[inline]
  pub fn add_X(&mut self, X: f32) {
    self.fbb_.push_slot::<f32>(ObstacleExcel::VT_X, X, 0.0);
  }
  #[inline]
  pub fn add_Z(&mut self, Z: f32) {
    self.fbb_.push_slot::<f32>(ObstacleExcel::VT_Z, Z, 0.0);
  }
  #[inline]
  pub fn add_Hp(&mut self, Hp: i64) {
    self.fbb_.push_slot::<i64>(ObstacleExcel::VT_HP, Hp, 0);
  }
  #[inline]
  pub fn add_MaxHp(&mut self, MaxHp: i64) {
    self.fbb_.push_slot::<i64>(ObstacleExcel::VT_MAXHP, MaxHp, 0);
  }
  #[inline]
  pub fn add_BlockRate(&mut self, BlockRate: i32) {
    self.fbb_.push_slot::<i32>(ObstacleExcel::VT_BLOCKRATE, BlockRate, 0);
  }
  #[inline]
  pub fn add_EvasionRate(&mut self, EvasionRate: i32) {
    self.fbb_.push_slot::<i32>(ObstacleExcel::VT_EVASIONRATE, EvasionRate, 0);
  }
  #[inline]
  pub fn add_DestroyType(&mut self, DestroyType: ObstacleDestroyType) {
    self.fbb_.push_slot::<ObstacleDestroyType>(ObstacleExcel::VT_DESTROYTYPE, DestroyType, ObstacleDestroyType::Remain);
  }
  #[inline]
  pub fn add_Point1Offeset(&mut self, Point1Offeset: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ObstacleExcel::VT_POINT1OFFESET, Point1Offeset);
  }
  #[inline]
  pub fn add_EnemyPoint1Osset(&mut self, EnemyPoint1Osset: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ObstacleExcel::VT_ENEMYPOINT1OSSET, EnemyPoint1Osset);
  }
  #[inline]
  pub fn add_Point2Offeset(&mut self, Point2Offeset: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ObstacleExcel::VT_POINT2OFFESET, Point2Offeset);
  }
  #[inline]
  pub fn add_EnemyPoint2Osset(&mut self, EnemyPoint2Osset: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ObstacleExcel::VT_ENEMYPOINT2OSSET, EnemyPoint2Osset);
  }
  #[inline]
  pub fn add_SubObstacleID(&mut self, SubObstacleID: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ObstacleExcel::VT_SUBOBSTACLEID, SubObstacleID);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ObstacleExcelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ObstacleExcelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ObstacleExcel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ObstacleExcel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ObstacleExcel");
      ds.field("Index", &self.Index());
      ds.field("PrefabName", &self.PrefabName());
      ds.field("JumpAble", &self.JumpAble());
      ds.field("SubOffset", &self.SubOffset());
      ds.field("X", &self.X());
      ds.field("Z", &self.Z());
      ds.field("Hp", &self.Hp());
      ds.field("MaxHp", &self.MaxHp());
      ds.field("BlockRate", &self.BlockRate());
      ds.field("EvasionRate", &self.EvasionRate());
      ds.field("DestroyType", &self.DestroyType());
      ds.field("Point1Offeset", &self.Point1Offeset());
      ds.field("EnemyPoint1Osset", &self.EnemyPoint1Osset());
      ds.field("Point2Offeset", &self.Point2Offeset());
      ds.field("EnemyPoint2Osset", &self.EnemyPoint2Osset());
      ds.field("SubObstacleID", &self.SubObstacleID());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ObstacleExcelT {
  pub Index: i64,
  pub PrefabName: Option<String>,
  pub JumpAble: bool,
  pub SubOffset: Option<Vec<f32>>,
  pub X: f32,
  pub Z: f32,
  pub Hp: i64,
  pub MaxHp: i64,
  pub BlockRate: i32,
  pub EvasionRate: i32,
  pub DestroyType: ObstacleDestroyType,
  pub Point1Offeset: Option<Vec<f32>>,
  pub EnemyPoint1Osset: Option<Vec<f32>>,
  pub Point2Offeset: Option<Vec<f32>>,
  pub EnemyPoint2Osset: Option<Vec<f32>>,
  pub SubObstacleID: Option<Vec<i64>>,
}
impl Default for ObstacleExcelT {
  fn default() -> Self {
    Self {
      Index: 0,
      PrefabName: None,
      JumpAble: false,
      SubOffset: None,
      X: 0.0,
      Z: 0.0,
      Hp: 0,
      MaxHp: 0,
      BlockRate: 0,
      EvasionRate: 0,
      DestroyType: ObstacleDestroyType::Remain,
      Point1Offeset: None,
      EnemyPoint1Osset: None,
      Point2Offeset: None,
      EnemyPoint2Osset: None,
      SubObstacleID: None,
    }
  }
}
impl ObstacleExcelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ObstacleExcel<'b>> {
    let Index = self.Index;
    let PrefabName = self.PrefabName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let JumpAble = self.JumpAble;
    let SubOffset = self.SubOffset.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let X = self.X;
    let Z = self.Z;
    let Hp = self.Hp;
    let MaxHp = self.MaxHp;
    let BlockRate = self.BlockRate;
    let EvasionRate = self.EvasionRate;
    let DestroyType = self.DestroyType;
    let Point1Offeset = self.Point1Offeset.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let EnemyPoint1Osset = self.EnemyPoint1Osset.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let Point2Offeset = self.Point2Offeset.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let EnemyPoint2Osset = self.EnemyPoint2Osset.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let SubObstacleID = self.SubObstacleID.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    ObstacleExcel::create(_fbb, &ObstacleExcelArgs{
      Index,
      PrefabName,
      JumpAble,
      SubOffset,
      X,
      Z,
      Hp,
      MaxHp,
      BlockRate,
      EvasionRate,
      DestroyType,
      Point1Offeset,
      EnemyPoint1Osset,
      Point2Offeset,
      EnemyPoint2Osset,
      SubObstacleID,
    })
  }
}
