// automatically generated by the FlatBuffers compiler, do not modify
// @generated
#![allow(unused_imports, dead_code)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum MinigameCCGLevelStageExcelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MinigameCCGLevelStageExcel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MinigameCCGLevelStageExcel<'a> {
  type Inner = MinigameCCGLevelStageExcel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MinigameCCGLevelStageExcel<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_GROUPID: flatbuffers::VOffsetT = 6;
  pub const VT_ENEMYGROUPID: flatbuffers::VOffsetT = 8;
  pub const VT_STAGETYPE: flatbuffers::VOffsetT = 10;
  pub const VT_CAMPDISCARDCARDCOUNT: flatbuffers::VOffsetT = 12;
  pub const VT_CAMPSPRPATH: flatbuffers::VOffsetT = 14;
  pub const VT_CAMPBACKGROUNDPATH: flatbuffers::VOffsetT = 16;
  pub const VT_REWARDTYPE: flatbuffers::VOffsetT = 18;
  pub const VT_REWARDCOUNT: flatbuffers::VOffsetT = 20;
  pub const VT_REWARDCARDGROUPID: flatbuffers::VOffsetT = 22;
  pub const VT_CARDRARITYGROUPID: flatbuffers::VOffsetT = 24;
  pub const VT_ISSKIPINTROSCENARIO: flatbuffers::VOffsetT = 26;
  pub const VT_INTROSCENARIOGROUPID: flatbuffers::VOffsetT = 28;
  pub const VT_ISSKIPOUTROSCENARIO: flatbuffers::VOffsetT = 30;
  pub const VT_OUTROSCENARIOGROUPID: flatbuffers::VOffsetT = 32;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MinigameCCGLevelStageExcel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MinigameCCGLevelStageExcelArgs<'args>
  ) -> flatbuffers::WIPOffset<MinigameCCGLevelStageExcel<'bldr>> {
    let mut builder = MinigameCCGLevelStageExcelBuilder::new(_fbb);
    let key = table_encryption_service::create_key(b"MinigameCCGLevelStage");
      let x = args.OutroScenarioGroupId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_OutroScenarioGroupId(x);
      let x = args.IntroScenarioGroupId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_IntroScenarioGroupId(x);
      let x = args.CardRarityGroupId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_CardRarityGroupId(x);
      let x = args.RewardCardGroupId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_RewardCardGroupId(x);
      let x = args.GroupId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_GroupId(x);
      let x = args.Id;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_Id(x);
      let x = args.RewardCount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_RewardCount(x);
      let x = args.RewardType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_RewardType(x);
      if let Some(x) = args.CampBackgroundPath {
        builder.add_CampBackgroundPath(x);
      }
      if let Some(x) = args.CampSprPath {
        builder.add_CampSprPath(x);
      }
      let x = args.CampDiscardCardCount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_CampDiscardCardCount(x);
      let x = args.StageType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_StageType(x);
      if let Some(x) = args.EnemyGroupId {
        builder.add_EnemyGroupId(x);
      }
      builder.add_isSkipOutroScenario(args.isSkipOutroScenario);
      builder.add_isSkipIntroScenario(args.isSkipIntroScenario);
    builder.finish()
  }

  pub fn unpack(&self) -> MinigameCCGLevelStageExcelT {
    let key = table_encryption_service::create_key(b"MinigameCCGLevelStage");
      let Id = self.Id();
      let GroupId = self.GroupId();
    let EnemyGroupId = self.EnemyGroupId().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_long(*val, &key) } else { *val }).collect()
    });
      let StageType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.StageType(), &key)
      } else {
        self.StageType()
      };
      let CampDiscardCardCount = self.CampDiscardCardCount();
    let CampSprPath = self.CampSprPath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let CampBackgroundPath = self.CampBackgroundPath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let RewardType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.RewardType(), &key)
      } else {
        self.RewardType()
      };
      let RewardCount = self.RewardCount();
      let RewardCardGroupId = self.RewardCardGroupId();
      let CardRarityGroupId = self.CardRarityGroupId();
      let isSkipIntroScenario = self.isSkipIntroScenario();
      let IntroScenarioGroupId = self.IntroScenarioGroupId();
      let isSkipOutroScenario = self.isSkipOutroScenario();
      let OutroScenarioGroupId = self.OutroScenarioGroupId();
    MinigameCCGLevelStageExcelT {
      Id,
      GroupId,
      EnemyGroupId,
      StageType,
      CampDiscardCardCount,
      CampSprPath,
      CampBackgroundPath,
      RewardType,
      RewardCount,
      RewardCardGroupId,
      CardRarityGroupId,
      isSkipIntroScenario,
      IntroScenarioGroupId,
      isSkipOutroScenario,
      OutroScenarioGroupId,
    }
  }

  #[inline]
  pub fn Id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MinigameCCGLevelStageExcel::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn GroupId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MinigameCCGLevelStageExcel::VT_GROUPID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EnemyGroupId(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(MinigameCCGLevelStageExcel::VT_ENEMYGROUPID, None)}
  }
  #[inline]
  pub fn StageType(&self) -> CCGStageType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<CCGStageType>(MinigameCCGLevelStageExcel::VT_STAGETYPE, Some(CCGStageType::None)).unwrap()}
  }
  #[inline]
  pub fn CampDiscardCardCount(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MinigameCCGLevelStageExcel::VT_CAMPDISCARDCARDCOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CampSprPath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MinigameCCGLevelStageExcel::VT_CAMPSPRPATH, None)}
  }
  #[inline]
  pub fn CampBackgroundPath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MinigameCCGLevelStageExcel::VT_CAMPBACKGROUNDPATH, None)}
  }
  #[inline]
  pub fn RewardType(&self) -> CCGStageRewardType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<CCGStageRewardType>(MinigameCCGLevelStageExcel::VT_REWARDTYPE, Some(CCGStageRewardType::None)).unwrap()}
  }
  #[inline]
  pub fn RewardCount(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MinigameCCGLevelStageExcel::VT_REWARDCOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn RewardCardGroupId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MinigameCCGLevelStageExcel::VT_REWARDCARDGROUPID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CardRarityGroupId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MinigameCCGLevelStageExcel::VT_CARDRARITYGROUPID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn isSkipIntroScenario(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(MinigameCCGLevelStageExcel::VT_ISSKIPINTROSCENARIO, Some(false)).unwrap()}
  }
  #[inline]
  pub fn IntroScenarioGroupId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MinigameCCGLevelStageExcel::VT_INTROSCENARIOGROUPID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn isSkipOutroScenario(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(MinigameCCGLevelStageExcel::VT_ISSKIPOUTROSCENARIO, Some(false)).unwrap()}
  }
  #[inline]
  pub fn OutroScenarioGroupId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MinigameCCGLevelStageExcel::VT_OUTROSCENARIOGROUPID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for MinigameCCGLevelStageExcel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("Id", Self::VT_ID, false)?
     .visit_field::<i64>("GroupId", Self::VT_GROUPID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("EnemyGroupId", Self::VT_ENEMYGROUPID, false)?
     .visit_field::<CCGStageType>("StageType", Self::VT_STAGETYPE, false)?
     .visit_field::<i32>("CampDiscardCardCount", Self::VT_CAMPDISCARDCARDCOUNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CampSprPath", Self::VT_CAMPSPRPATH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CampBackgroundPath", Self::VT_CAMPBACKGROUNDPATH, false)?
     .visit_field::<CCGStageRewardType>("RewardType", Self::VT_REWARDTYPE, false)?
     .visit_field::<i32>("RewardCount", Self::VT_REWARDCOUNT, false)?
     .visit_field::<i64>("RewardCardGroupId", Self::VT_REWARDCARDGROUPID, false)?
     .visit_field::<i64>("CardRarityGroupId", Self::VT_CARDRARITYGROUPID, false)?
     .visit_field::<bool>("isSkipIntroScenario", Self::VT_ISSKIPINTROSCENARIO, false)?
     .visit_field::<i64>("IntroScenarioGroupId", Self::VT_INTROSCENARIOGROUPID, false)?
     .visit_field::<bool>("isSkipOutroScenario", Self::VT_ISSKIPOUTROSCENARIO, false)?
     .visit_field::<i64>("OutroScenarioGroupId", Self::VT_OUTROSCENARIOGROUPID, false)?
     .finish();
    Ok(())
  }
}
pub struct MinigameCCGLevelStageExcelArgs<'a> {
    pub Id: i64,
    pub GroupId: i64,
    pub EnemyGroupId: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub StageType: CCGStageType,
    pub CampDiscardCardCount: i32,
    pub CampSprPath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CampBackgroundPath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub RewardType: CCGStageRewardType,
    pub RewardCount: i32,
    pub RewardCardGroupId: i64,
    pub CardRarityGroupId: i64,
    pub isSkipIntroScenario: bool,
    pub IntroScenarioGroupId: i64,
    pub isSkipOutroScenario: bool,
    pub OutroScenarioGroupId: i64,
}
impl<'a> Default for MinigameCCGLevelStageExcelArgs<'a> {
  #[inline]
  fn default() -> Self {
    MinigameCCGLevelStageExcelArgs {
      Id: 0,
      GroupId: 0,
      EnemyGroupId: None,
      StageType: CCGStageType::None,
      CampDiscardCardCount: 0,
      CampSprPath: None,
      CampBackgroundPath: None,
      RewardType: CCGStageRewardType::None,
      RewardCount: 0,
      RewardCardGroupId: 0,
      CardRarityGroupId: 0,
      isSkipIntroScenario: false,
      IntroScenarioGroupId: 0,
      isSkipOutroScenario: false,
      OutroScenarioGroupId: 0,
    }
  }
}

impl Serialize for MinigameCCGLevelStageExcel<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("MinigameCCGLevelStageExcel", 15)?;
      s.serialize_field("Id", &self.Id())?;
      s.serialize_field("GroupId", &self.GroupId())?;
      if let Some(f) = self.EnemyGroupId() {
        s.serialize_field("EnemyGroupId", &f)?;
      } else {
        s.skip_field("EnemyGroupId")?;
      }
      s.serialize_field("StageType", &self.StageType())?;
      s.serialize_field("CampDiscardCardCount", &self.CampDiscardCardCount())?;
      if let Some(f) = self.CampSprPath() {
        s.serialize_field("CampSprPath", &f)?;
      } else {
        s.skip_field("CampSprPath")?;
      }
      if let Some(f) = self.CampBackgroundPath() {
        s.serialize_field("CampBackgroundPath", &f)?;
      } else {
        s.skip_field("CampBackgroundPath")?;
      }
      s.serialize_field("RewardType", &self.RewardType())?;
      s.serialize_field("RewardCount", &self.RewardCount())?;
      s.serialize_field("RewardCardGroupId", &self.RewardCardGroupId())?;
      s.serialize_field("CardRarityGroupId", &self.CardRarityGroupId())?;
      s.serialize_field("isSkipIntroScenario", &self.isSkipIntroScenario())?;
      s.serialize_field("IntroScenarioGroupId", &self.IntroScenarioGroupId())?;
      s.serialize_field("isSkipOutroScenario", &self.isSkipOutroScenario())?;
      s.serialize_field("OutroScenarioGroupId", &self.OutroScenarioGroupId())?;
    s.end()
  }
}

pub struct MinigameCCGLevelStageExcelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MinigameCCGLevelStageExcelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_Id(&mut self, Id: i64) {
    self.fbb_.push_slot::<i64>(MinigameCCGLevelStageExcel::VT_ID, Id, 0);
  }
  #[inline]
  pub fn add_GroupId(&mut self, GroupId: i64) {
    self.fbb_.push_slot::<i64>(MinigameCCGLevelStageExcel::VT_GROUPID, GroupId, 0);
  }
  #[inline]
  pub fn add_EnemyGroupId(&mut self, EnemyGroupId: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MinigameCCGLevelStageExcel::VT_ENEMYGROUPID, EnemyGroupId);
  }
  #[inline]
  pub fn add_StageType(&mut self, StageType: CCGStageType) {
    self.fbb_.push_slot::<CCGStageType>(MinigameCCGLevelStageExcel::VT_STAGETYPE, StageType, CCGStageType::None);
  }
  #[inline]
  pub fn add_CampDiscardCardCount(&mut self, CampDiscardCardCount: i32) {
    self.fbb_.push_slot::<i32>(MinigameCCGLevelStageExcel::VT_CAMPDISCARDCARDCOUNT, CampDiscardCardCount, 0);
  }
  #[inline]
  pub fn add_CampSprPath(&mut self, CampSprPath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MinigameCCGLevelStageExcel::VT_CAMPSPRPATH, CampSprPath);
  }
  #[inline]
  pub fn add_CampBackgroundPath(&mut self, CampBackgroundPath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MinigameCCGLevelStageExcel::VT_CAMPBACKGROUNDPATH, CampBackgroundPath);
  }
  #[inline]
  pub fn add_RewardType(&mut self, RewardType: CCGStageRewardType) {
    self.fbb_.push_slot::<CCGStageRewardType>(MinigameCCGLevelStageExcel::VT_REWARDTYPE, RewardType, CCGStageRewardType::None);
  }
  #[inline]
  pub fn add_RewardCount(&mut self, RewardCount: i32) {
    self.fbb_.push_slot::<i32>(MinigameCCGLevelStageExcel::VT_REWARDCOUNT, RewardCount, 0);
  }
  #[inline]
  pub fn add_RewardCardGroupId(&mut self, RewardCardGroupId: i64) {
    self.fbb_.push_slot::<i64>(MinigameCCGLevelStageExcel::VT_REWARDCARDGROUPID, RewardCardGroupId, 0);
  }
  #[inline]
  pub fn add_CardRarityGroupId(&mut self, CardRarityGroupId: i64) {
    self.fbb_.push_slot::<i64>(MinigameCCGLevelStageExcel::VT_CARDRARITYGROUPID, CardRarityGroupId, 0);
  }
  #[inline]
  pub fn add_isSkipIntroScenario(&mut self, isSkipIntroScenario: bool) {
    self.fbb_.push_slot::<bool>(MinigameCCGLevelStageExcel::VT_ISSKIPINTROSCENARIO, isSkipIntroScenario, false);
  }
  #[inline]
  pub fn add_IntroScenarioGroupId(&mut self, IntroScenarioGroupId: i64) {
    self.fbb_.push_slot::<i64>(MinigameCCGLevelStageExcel::VT_INTROSCENARIOGROUPID, IntroScenarioGroupId, 0);
  }
  #[inline]
  pub fn add_isSkipOutroScenario(&mut self, isSkipOutroScenario: bool) {
    self.fbb_.push_slot::<bool>(MinigameCCGLevelStageExcel::VT_ISSKIPOUTROSCENARIO, isSkipOutroScenario, false);
  }
  #[inline]
  pub fn add_OutroScenarioGroupId(&mut self, OutroScenarioGroupId: i64) {
    self.fbb_.push_slot::<i64>(MinigameCCGLevelStageExcel::VT_OUTROSCENARIOGROUPID, OutroScenarioGroupId, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MinigameCCGLevelStageExcelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MinigameCCGLevelStageExcelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MinigameCCGLevelStageExcel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MinigameCCGLevelStageExcel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MinigameCCGLevelStageExcel");
      ds.field("Id", &self.Id());
      ds.field("GroupId", &self.GroupId());
      ds.field("EnemyGroupId", &self.EnemyGroupId());
      ds.field("StageType", &self.StageType());
      ds.field("CampDiscardCardCount", &self.CampDiscardCardCount());
      ds.field("CampSprPath", &self.CampSprPath());
      ds.field("CampBackgroundPath", &self.CampBackgroundPath());
      ds.field("RewardType", &self.RewardType());
      ds.field("RewardCount", &self.RewardCount());
      ds.field("RewardCardGroupId", &self.RewardCardGroupId());
      ds.field("CardRarityGroupId", &self.CardRarityGroupId());
      ds.field("isSkipIntroScenario", &self.isSkipIntroScenario());
      ds.field("IntroScenarioGroupId", &self.IntroScenarioGroupId());
      ds.field("isSkipOutroScenario", &self.isSkipOutroScenario());
      ds.field("OutroScenarioGroupId", &self.OutroScenarioGroupId());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MinigameCCGLevelStageExcelT {
  pub Id: i64,
  pub GroupId: i64,
  pub EnemyGroupId: Option<Vec<i64>>,
  pub StageType: CCGStageType,
  pub CampDiscardCardCount: i32,
  pub CampSprPath: Option<String>,
  pub CampBackgroundPath: Option<String>,
  pub RewardType: CCGStageRewardType,
  pub RewardCount: i32,
  pub RewardCardGroupId: i64,
  pub CardRarityGroupId: i64,
  pub isSkipIntroScenario: bool,
  pub IntroScenarioGroupId: i64,
  pub isSkipOutroScenario: bool,
  pub OutroScenarioGroupId: i64,
}
impl Default for MinigameCCGLevelStageExcelT {
  fn default() -> Self {
    Self {
      Id: 0,
      GroupId: 0,
      EnemyGroupId: None,
      StageType: CCGStageType::None,
      CampDiscardCardCount: 0,
      CampSprPath: None,
      CampBackgroundPath: None,
      RewardType: CCGStageRewardType::None,
      RewardCount: 0,
      RewardCardGroupId: 0,
      CardRarityGroupId: 0,
      isSkipIntroScenario: false,
      IntroScenarioGroupId: 0,
      isSkipOutroScenario: false,
      OutroScenarioGroupId: 0,
    }
  }
}
impl MinigameCCGLevelStageExcelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<MinigameCCGLevelStageExcel<'b>> {
    let Id = self.Id;
    let GroupId = self.GroupId;
    let EnemyGroupId = self.EnemyGroupId.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let StageType = self.StageType;
    let CampDiscardCardCount = self.CampDiscardCardCount;
    let CampSprPath = self.CampSprPath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CampBackgroundPath = self.CampBackgroundPath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let RewardType = self.RewardType;
    let RewardCount = self.RewardCount;
    let RewardCardGroupId = self.RewardCardGroupId;
    let CardRarityGroupId = self.CardRarityGroupId;
    let isSkipIntroScenario = self.isSkipIntroScenario;
    let IntroScenarioGroupId = self.IntroScenarioGroupId;
    let isSkipOutroScenario = self.isSkipOutroScenario;
    let OutroScenarioGroupId = self.OutroScenarioGroupId;
    MinigameCCGLevelStageExcel::create(_fbb, &MinigameCCGLevelStageExcelArgs{
      Id,
      GroupId,
      EnemyGroupId,
      StageType,
      CampDiscardCardCount,
      CampSprPath,
      CampBackgroundPath,
      RewardType,
      RewardCount,
      RewardCardGroupId,
      CardRarityGroupId,
      isSkipIntroScenario,
      IntroScenarioGroupId,
      isSkipOutroScenario,
      OutroScenarioGroupId,
    })
  }
}
