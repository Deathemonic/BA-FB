// automatically generated by the FlatBuffers compiler, do not modify
// @generated
#![allow(unused_imports, dead_code)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum MiniGameRhythmExcelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MiniGameRhythmExcel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MiniGameRhythmExcel<'a> {
  type Inner = MiniGameRhythmExcel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MiniGameRhythmExcel<'a> {
  pub const VT_UNIQUEID: flatbuffers::VOffsetT = 4;
  pub const VT_RHYTHMBGMID: flatbuffers::VOffsetT = 6;
  pub const VT_PRESETNAME: flatbuffers::VOffsetT = 8;
  pub const VT_STAGEDIFFICULTY: flatbuffers::VOffsetT = 10;
  pub const VT_ISSPECIAL: flatbuffers::VOffsetT = 12;
  pub const VT_OPENSTAGESCOREAMOUNT: flatbuffers::VOffsetT = 14;
  pub const VT_MAXHP: flatbuffers::VOffsetT = 16;
  pub const VT_MISSDAMAGE: flatbuffers::VOffsetT = 18;
  pub const VT_CRITICALHPRESTOREVALUE: flatbuffers::VOffsetT = 20;
  pub const VT_MAXSCORE: flatbuffers::VOffsetT = 22;
  pub const VT_FEVERSCORERATE: flatbuffers::VOffsetT = 24;
  pub const VT_NOTESCORERATE: flatbuffers::VOffsetT = 26;
  pub const VT_COMBOSCORERATE: flatbuffers::VOffsetT = 28;
  pub const VT_ATTACKSCORERATE: flatbuffers::VOffsetT = 30;
  pub const VT_FEVERCRITICALRATE: flatbuffers::VOffsetT = 32;
  pub const VT_FEVERATTACKRATE: flatbuffers::VOffsetT = 34;
  pub const VT_MAXHPSCORE: flatbuffers::VOffsetT = 36;
  pub const VT_RHYTHMFILENAME: flatbuffers::VOffsetT = 38;
  pub const VT_ARTLEVELSCENENAME: flatbuffers::VOffsetT = 40;
  pub const VT_COMBOIMAGEPATH: flatbuffers::VOffsetT = 42;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MiniGameRhythmExcel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MiniGameRhythmExcelArgs<'args>
  ) -> flatbuffers::WIPOffset<MiniGameRhythmExcel<'bldr>> {
    let mut builder = MiniGameRhythmExcelBuilder::new(_fbb);
    let key = table_encryption_service::create_key(b"MiniGameRhythm");
      let x = args.MaxHpScore;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_MaxHpScore(x);
      let x = args.AttackScoreRate;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_AttackScoreRate(x);
      let x = args.ComboScoreRate;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_ComboScoreRate(x);
      let x = args.NoteScoreRate;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_NoteScoreRate(x);
      let x = args.FeverScoreRate;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_FeverScoreRate(x);
      let x = args.MaxScore;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_MaxScore(x);
      let x = args.CriticalHPRestoreValue;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_CriticalHPRestoreValue(x);
      let x = args.MissDamage;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_MissDamage(x);
      let x = args.MaxHp;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_MaxHp(x);
      let x = args.OpenStageScoreAmount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_OpenStageScoreAmount(x);
      let x = args.RhythmBgmId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_RhythmBgmId(x);
      let x = args.UniqueId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_UniqueId(x);
      if let Some(x) = args.ComboImagePath {
        builder.add_ComboImagePath(x);
      }
      if let Some(x) = args.ArtLevelSceneName {
        builder.add_ArtLevelSceneName(x);
      }
      if let Some(x) = args.RhythmFileName {
        builder.add_RhythmFileName(x);
      }
      let x = args.FeverAttackRate;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_FeverAttackRate(x);
      let x = args.FeverCriticalRate;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_FeverCriticalRate(x);
      let x = args.StageDifficulty;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_StageDifficulty(x);
      if let Some(x) = args.PresetName {
        builder.add_PresetName(x);
      }
      builder.add_IsSpecial(args.IsSpecial);
    builder.finish()
  }

  pub fn unpack(&self) -> MiniGameRhythmExcelT {
    let key = table_encryption_service::create_key(b"MiniGameRhythm");
      let UniqueId = self.UniqueId();
      let RhythmBgmId = self.RhythmBgmId();
    let PresetName = self.PresetName().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let StageDifficulty = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.StageDifficulty(), &key)
      } else {
        self.StageDifficulty()
      };
      let IsSpecial = self.IsSpecial();
      let OpenStageScoreAmount = self.OpenStageScoreAmount();
      let MaxHp = self.MaxHp();
      let MissDamage = self.MissDamage();
      let CriticalHPRestoreValue = self.CriticalHPRestoreValue();
      let MaxScore = self.MaxScore();
      let FeverScoreRate = self.FeverScoreRate();
      let NoteScoreRate = self.NoteScoreRate();
      let ComboScoreRate = self.ComboScoreRate();
      let AttackScoreRate = self.AttackScoreRate();
      let FeverCriticalRate = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.FeverCriticalRate(), &key)
      } else {
        self.FeverCriticalRate()
      };
      let FeverAttackRate = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.FeverAttackRate(), &key)
      } else {
        self.FeverAttackRate()
      };
      let MaxHpScore = self.MaxHpScore();
    let RhythmFileName = self.RhythmFileName().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let ArtLevelSceneName = self.ArtLevelSceneName().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let ComboImagePath = self.ComboImagePath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    MiniGameRhythmExcelT {
      UniqueId,
      RhythmBgmId,
      PresetName,
      StageDifficulty,
      IsSpecial,
      OpenStageScoreAmount,
      MaxHp,
      MissDamage,
      CriticalHPRestoreValue,
      MaxScore,
      FeverScoreRate,
      NoteScoreRate,
      ComboScoreRate,
      AttackScoreRate,
      FeverCriticalRate,
      FeverAttackRate,
      MaxHpScore,
      RhythmFileName,
      ArtLevelSceneName,
      ComboImagePath,
    }
  }

  #[inline]
  pub fn UniqueId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MiniGameRhythmExcel::VT_UNIQUEID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn RhythmBgmId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MiniGameRhythmExcel::VT_RHYTHMBGMID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn PresetName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MiniGameRhythmExcel::VT_PRESETNAME, None)}
  }
  #[inline]
  pub fn StageDifficulty(&self) -> Difficulty {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Difficulty>(MiniGameRhythmExcel::VT_STAGEDIFFICULTY, Some(Difficulty::Normal)).unwrap()}
  }
  #[inline]
  pub fn IsSpecial(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(MiniGameRhythmExcel::VT_ISSPECIAL, Some(false)).unwrap()}
  }
  #[inline]
  pub fn OpenStageScoreAmount(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MiniGameRhythmExcel::VT_OPENSTAGESCOREAMOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn MaxHp(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MiniGameRhythmExcel::VT_MAXHP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn MissDamage(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MiniGameRhythmExcel::VT_MISSDAMAGE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CriticalHPRestoreValue(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MiniGameRhythmExcel::VT_CRITICALHPRESTOREVALUE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn MaxScore(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MiniGameRhythmExcel::VT_MAXSCORE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn FeverScoreRate(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MiniGameRhythmExcel::VT_FEVERSCORERATE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn NoteScoreRate(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MiniGameRhythmExcel::VT_NOTESCORERATE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ComboScoreRate(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MiniGameRhythmExcel::VT_COMBOSCORERATE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn AttackScoreRate(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MiniGameRhythmExcel::VT_ATTACKSCORERATE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn FeverCriticalRate(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(MiniGameRhythmExcel::VT_FEVERCRITICALRATE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn FeverAttackRate(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(MiniGameRhythmExcel::VT_FEVERATTACKRATE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn MaxHpScore(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MiniGameRhythmExcel::VT_MAXHPSCORE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn RhythmFileName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MiniGameRhythmExcel::VT_RHYTHMFILENAME, None)}
  }
  #[inline]
  pub fn ArtLevelSceneName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MiniGameRhythmExcel::VT_ARTLEVELSCENENAME, None)}
  }
  #[inline]
  pub fn ComboImagePath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MiniGameRhythmExcel::VT_COMBOIMAGEPATH, None)}
  }
}

impl flatbuffers::Verifiable for MiniGameRhythmExcel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("UniqueId", Self::VT_UNIQUEID, false)?
     .visit_field::<i64>("RhythmBgmId", Self::VT_RHYTHMBGMID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PresetName", Self::VT_PRESETNAME, false)?
     .visit_field::<Difficulty>("StageDifficulty", Self::VT_STAGEDIFFICULTY, false)?
     .visit_field::<bool>("IsSpecial", Self::VT_ISSPECIAL, false)?
     .visit_field::<i64>("OpenStageScoreAmount", Self::VT_OPENSTAGESCOREAMOUNT, false)?
     .visit_field::<i64>("MaxHp", Self::VT_MAXHP, false)?
     .visit_field::<i64>("MissDamage", Self::VT_MISSDAMAGE, false)?
     .visit_field::<i64>("CriticalHPRestoreValue", Self::VT_CRITICALHPRESTOREVALUE, false)?
     .visit_field::<i64>("MaxScore", Self::VT_MAXSCORE, false)?
     .visit_field::<i64>("FeverScoreRate", Self::VT_FEVERSCORERATE, false)?
     .visit_field::<i64>("NoteScoreRate", Self::VT_NOTESCORERATE, false)?
     .visit_field::<i64>("ComboScoreRate", Self::VT_COMBOSCORERATE, false)?
     .visit_field::<i64>("AttackScoreRate", Self::VT_ATTACKSCORERATE, false)?
     .visit_field::<f32>("FeverCriticalRate", Self::VT_FEVERCRITICALRATE, false)?
     .visit_field::<f32>("FeverAttackRate", Self::VT_FEVERATTACKRATE, false)?
     .visit_field::<i64>("MaxHpScore", Self::VT_MAXHPSCORE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("RhythmFileName", Self::VT_RHYTHMFILENAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ArtLevelSceneName", Self::VT_ARTLEVELSCENENAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ComboImagePath", Self::VT_COMBOIMAGEPATH, false)?
     .finish();
    Ok(())
  }
}
pub struct MiniGameRhythmExcelArgs<'a> {
    pub UniqueId: i64,
    pub RhythmBgmId: i64,
    pub PresetName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub StageDifficulty: Difficulty,
    pub IsSpecial: bool,
    pub OpenStageScoreAmount: i64,
    pub MaxHp: i64,
    pub MissDamage: i64,
    pub CriticalHPRestoreValue: i64,
    pub MaxScore: i64,
    pub FeverScoreRate: i64,
    pub NoteScoreRate: i64,
    pub ComboScoreRate: i64,
    pub AttackScoreRate: i64,
    pub FeverCriticalRate: f32,
    pub FeverAttackRate: f32,
    pub MaxHpScore: i64,
    pub RhythmFileName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ArtLevelSceneName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ComboImagePath: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for MiniGameRhythmExcelArgs<'a> {
  #[inline]
  fn default() -> Self {
    MiniGameRhythmExcelArgs {
      UniqueId: 0,
      RhythmBgmId: 0,
      PresetName: None,
      StageDifficulty: Difficulty::Normal,
      IsSpecial: false,
      OpenStageScoreAmount: 0,
      MaxHp: 0,
      MissDamage: 0,
      CriticalHPRestoreValue: 0,
      MaxScore: 0,
      FeverScoreRate: 0,
      NoteScoreRate: 0,
      ComboScoreRate: 0,
      AttackScoreRate: 0,
      FeverCriticalRate: 0.0,
      FeverAttackRate: 0.0,
      MaxHpScore: 0,
      RhythmFileName: None,
      ArtLevelSceneName: None,
      ComboImagePath: None,
    }
  }
}

impl Serialize for MiniGameRhythmExcel<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("MiniGameRhythmExcel", 20)?;
      s.serialize_field("UniqueId", &self.UniqueId())?;
      s.serialize_field("RhythmBgmId", &self.RhythmBgmId())?;
      if let Some(f) = self.PresetName() {
        s.serialize_field("PresetName", &f)?;
      } else {
        s.skip_field("PresetName")?;
      }
      s.serialize_field("StageDifficulty", &self.StageDifficulty())?;
      s.serialize_field("IsSpecial", &self.IsSpecial())?;
      s.serialize_field("OpenStageScoreAmount", &self.OpenStageScoreAmount())?;
      s.serialize_field("MaxHp", &self.MaxHp())?;
      s.serialize_field("MissDamage", &self.MissDamage())?;
      s.serialize_field("CriticalHPRestoreValue", &self.CriticalHPRestoreValue())?;
      s.serialize_field("MaxScore", &self.MaxScore())?;
      s.serialize_field("FeverScoreRate", &self.FeverScoreRate())?;
      s.serialize_field("NoteScoreRate", &self.NoteScoreRate())?;
      s.serialize_field("ComboScoreRate", &self.ComboScoreRate())?;
      s.serialize_field("AttackScoreRate", &self.AttackScoreRate())?;
      s.serialize_field("FeverCriticalRate", &self.FeverCriticalRate())?;
      s.serialize_field("FeverAttackRate", &self.FeverAttackRate())?;
      s.serialize_field("MaxHpScore", &self.MaxHpScore())?;
      if let Some(f) = self.RhythmFileName() {
        s.serialize_field("RhythmFileName", &f)?;
      } else {
        s.skip_field("RhythmFileName")?;
      }
      if let Some(f) = self.ArtLevelSceneName() {
        s.serialize_field("ArtLevelSceneName", &f)?;
      } else {
        s.skip_field("ArtLevelSceneName")?;
      }
      if let Some(f) = self.ComboImagePath() {
        s.serialize_field("ComboImagePath", &f)?;
      } else {
        s.skip_field("ComboImagePath")?;
      }
    s.end()
  }
}

pub struct MiniGameRhythmExcelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MiniGameRhythmExcelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_UniqueId(&mut self, UniqueId: i64) {
    self.fbb_.push_slot::<i64>(MiniGameRhythmExcel::VT_UNIQUEID, UniqueId, 0);
  }
  #[inline]
  pub fn add_RhythmBgmId(&mut self, RhythmBgmId: i64) {
    self.fbb_.push_slot::<i64>(MiniGameRhythmExcel::VT_RHYTHMBGMID, RhythmBgmId, 0);
  }
  #[inline]
  pub fn add_PresetName(&mut self, PresetName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MiniGameRhythmExcel::VT_PRESETNAME, PresetName);
  }
  #[inline]
  pub fn add_StageDifficulty(&mut self, StageDifficulty: Difficulty) {
    self.fbb_.push_slot::<Difficulty>(MiniGameRhythmExcel::VT_STAGEDIFFICULTY, StageDifficulty, Difficulty::Normal);
  }
  #[inline]
  pub fn add_IsSpecial(&mut self, IsSpecial: bool) {
    self.fbb_.push_slot::<bool>(MiniGameRhythmExcel::VT_ISSPECIAL, IsSpecial, false);
  }
  #[inline]
  pub fn add_OpenStageScoreAmount(&mut self, OpenStageScoreAmount: i64) {
    self.fbb_.push_slot::<i64>(MiniGameRhythmExcel::VT_OPENSTAGESCOREAMOUNT, OpenStageScoreAmount, 0);
  }
  #[inline]
  pub fn add_MaxHp(&mut self, MaxHp: i64) {
    self.fbb_.push_slot::<i64>(MiniGameRhythmExcel::VT_MAXHP, MaxHp, 0);
  }
  #[inline]
  pub fn add_MissDamage(&mut self, MissDamage: i64) {
    self.fbb_.push_slot::<i64>(MiniGameRhythmExcel::VT_MISSDAMAGE, MissDamage, 0);
  }
  #[inline]
  pub fn add_CriticalHPRestoreValue(&mut self, CriticalHPRestoreValue: i64) {
    self.fbb_.push_slot::<i64>(MiniGameRhythmExcel::VT_CRITICALHPRESTOREVALUE, CriticalHPRestoreValue, 0);
  }
  #[inline]
  pub fn add_MaxScore(&mut self, MaxScore: i64) {
    self.fbb_.push_slot::<i64>(MiniGameRhythmExcel::VT_MAXSCORE, MaxScore, 0);
  }
  #[inline]
  pub fn add_FeverScoreRate(&mut self, FeverScoreRate: i64) {
    self.fbb_.push_slot::<i64>(MiniGameRhythmExcel::VT_FEVERSCORERATE, FeverScoreRate, 0);
  }
  #[inline]
  pub fn add_NoteScoreRate(&mut self, NoteScoreRate: i64) {
    self.fbb_.push_slot::<i64>(MiniGameRhythmExcel::VT_NOTESCORERATE, NoteScoreRate, 0);
  }
  #[inline]
  pub fn add_ComboScoreRate(&mut self, ComboScoreRate: i64) {
    self.fbb_.push_slot::<i64>(MiniGameRhythmExcel::VT_COMBOSCORERATE, ComboScoreRate, 0);
  }
  #[inline]
  pub fn add_AttackScoreRate(&mut self, AttackScoreRate: i64) {
    self.fbb_.push_slot::<i64>(MiniGameRhythmExcel::VT_ATTACKSCORERATE, AttackScoreRate, 0);
  }
  #[inline]
  pub fn add_FeverCriticalRate(&mut self, FeverCriticalRate: f32) {
    self.fbb_.push_slot::<f32>(MiniGameRhythmExcel::VT_FEVERCRITICALRATE, FeverCriticalRate, 0.0);
  }
  #[inline]
  pub fn add_FeverAttackRate(&mut self, FeverAttackRate: f32) {
    self.fbb_.push_slot::<f32>(MiniGameRhythmExcel::VT_FEVERATTACKRATE, FeverAttackRate, 0.0);
  }
  #[inline]
  pub fn add_MaxHpScore(&mut self, MaxHpScore: i64) {
    self.fbb_.push_slot::<i64>(MiniGameRhythmExcel::VT_MAXHPSCORE, MaxHpScore, 0);
  }
  #[inline]
  pub fn add_RhythmFileName(&mut self, RhythmFileName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MiniGameRhythmExcel::VT_RHYTHMFILENAME, RhythmFileName);
  }
  #[inline]
  pub fn add_ArtLevelSceneName(&mut self, ArtLevelSceneName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MiniGameRhythmExcel::VT_ARTLEVELSCENENAME, ArtLevelSceneName);
  }
  #[inline]
  pub fn add_ComboImagePath(&mut self, ComboImagePath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MiniGameRhythmExcel::VT_COMBOIMAGEPATH, ComboImagePath);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MiniGameRhythmExcelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MiniGameRhythmExcelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MiniGameRhythmExcel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MiniGameRhythmExcel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MiniGameRhythmExcel");
      ds.field("UniqueId", &self.UniqueId());
      ds.field("RhythmBgmId", &self.RhythmBgmId());
      ds.field("PresetName", &self.PresetName());
      ds.field("StageDifficulty", &self.StageDifficulty());
      ds.field("IsSpecial", &self.IsSpecial());
      ds.field("OpenStageScoreAmount", &self.OpenStageScoreAmount());
      ds.field("MaxHp", &self.MaxHp());
      ds.field("MissDamage", &self.MissDamage());
      ds.field("CriticalHPRestoreValue", &self.CriticalHPRestoreValue());
      ds.field("MaxScore", &self.MaxScore());
      ds.field("FeverScoreRate", &self.FeverScoreRate());
      ds.field("NoteScoreRate", &self.NoteScoreRate());
      ds.field("ComboScoreRate", &self.ComboScoreRate());
      ds.field("AttackScoreRate", &self.AttackScoreRate());
      ds.field("FeverCriticalRate", &self.FeverCriticalRate());
      ds.field("FeverAttackRate", &self.FeverAttackRate());
      ds.field("MaxHpScore", &self.MaxHpScore());
      ds.field("RhythmFileName", &self.RhythmFileName());
      ds.field("ArtLevelSceneName", &self.ArtLevelSceneName());
      ds.field("ComboImagePath", &self.ComboImagePath());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MiniGameRhythmExcelT {
  pub UniqueId: i64,
  pub RhythmBgmId: i64,
  pub PresetName: Option<String>,
  pub StageDifficulty: Difficulty,
  pub IsSpecial: bool,
  pub OpenStageScoreAmount: i64,
  pub MaxHp: i64,
  pub MissDamage: i64,
  pub CriticalHPRestoreValue: i64,
  pub MaxScore: i64,
  pub FeverScoreRate: i64,
  pub NoteScoreRate: i64,
  pub ComboScoreRate: i64,
  pub AttackScoreRate: i64,
  pub FeverCriticalRate: f32,
  pub FeverAttackRate: f32,
  pub MaxHpScore: i64,
  pub RhythmFileName: Option<String>,
  pub ArtLevelSceneName: Option<String>,
  pub ComboImagePath: Option<String>,
}
impl Default for MiniGameRhythmExcelT {
  fn default() -> Self {
    Self {
      UniqueId: 0,
      RhythmBgmId: 0,
      PresetName: None,
      StageDifficulty: Difficulty::Normal,
      IsSpecial: false,
      OpenStageScoreAmount: 0,
      MaxHp: 0,
      MissDamage: 0,
      CriticalHPRestoreValue: 0,
      MaxScore: 0,
      FeverScoreRate: 0,
      NoteScoreRate: 0,
      ComboScoreRate: 0,
      AttackScoreRate: 0,
      FeverCriticalRate: 0.0,
      FeverAttackRate: 0.0,
      MaxHpScore: 0,
      RhythmFileName: None,
      ArtLevelSceneName: None,
      ComboImagePath: None,
    }
  }
}
impl MiniGameRhythmExcelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<MiniGameRhythmExcel<'b>> {
    let UniqueId = self.UniqueId;
    let RhythmBgmId = self.RhythmBgmId;
    let PresetName = self.PresetName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let StageDifficulty = self.StageDifficulty;
    let IsSpecial = self.IsSpecial;
    let OpenStageScoreAmount = self.OpenStageScoreAmount;
    let MaxHp = self.MaxHp;
    let MissDamage = self.MissDamage;
    let CriticalHPRestoreValue = self.CriticalHPRestoreValue;
    let MaxScore = self.MaxScore;
    let FeverScoreRate = self.FeverScoreRate;
    let NoteScoreRate = self.NoteScoreRate;
    let ComboScoreRate = self.ComboScoreRate;
    let AttackScoreRate = self.AttackScoreRate;
    let FeverCriticalRate = self.FeverCriticalRate;
    let FeverAttackRate = self.FeverAttackRate;
    let MaxHpScore = self.MaxHpScore;
    let RhythmFileName = self.RhythmFileName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ArtLevelSceneName = self.ArtLevelSceneName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ComboImagePath = self.ComboImagePath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    MiniGameRhythmExcel::create(_fbb, &MiniGameRhythmExcelArgs{
      UniqueId,
      RhythmBgmId,
      PresetName,
      StageDifficulty,
      IsSpecial,
      OpenStageScoreAmount,
      MaxHp,
      MissDamage,
      CriticalHPRestoreValue,
      MaxScore,
      FeverScoreRate,
      NoteScoreRate,
      ComboScoreRate,
      AttackScoreRate,
      FeverCriticalRate,
      FeverAttackRate,
      MaxHpScore,
      RhythmFileName,
      ArtLevelSceneName,
      ComboImagePath,
    })
  }
}
