// automatically generated by the FlatBuffers compiler, do not modify
// @generated
#![allow(unused_imports, dead_code)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum OperatorExcelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct OperatorExcel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OperatorExcel<'a> {
  type Inner = OperatorExcel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> OperatorExcel<'a> {
  pub const VT_UNIQUEID: flatbuffers::VOffsetT = 4;
  pub const VT_GROUPID: flatbuffers::VOffsetT = 6;
  pub const VT_OPERATORCONDITION: flatbuffers::VOffsetT = 8;
  pub const VT_OUTPUTSEQUENCE: flatbuffers::VOffsetT = 10;
  pub const VT_RANDOMWEIGHT: flatbuffers::VOffsetT = 12;
  pub const VT_OUTPUTDELAY: flatbuffers::VOffsetT = 14;
  pub const VT_DURATION: flatbuffers::VOffsetT = 16;
  pub const VT_OPERATOROUTPUTPRIORITY: flatbuffers::VOffsetT = 18;
  pub const VT_PORTRAITPATH: flatbuffers::VOffsetT = 20;
  pub const VT_TEXTLOCALIZEKEY: flatbuffers::VOffsetT = 22;
  pub const VT_VOICEID: flatbuffers::VOffsetT = 24;
  pub const VT_OPERATORWAITQUEUE: flatbuffers::VOffsetT = 26;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    OperatorExcel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args OperatorExcelArgs<'args>
  ) -> flatbuffers::WIPOffset<OperatorExcel<'bldr>> {
    let mut builder = OperatorExcelBuilder::new(_fbb);
    let key = table_encryption_service::create_key(b"Operator");
      let x = args.UniqueId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_UniqueId(x);
      if let Some(x) = args.VoiceId {
        builder.add_VoiceId(x);
      }
      if let Some(x) = args.TextLocalizeKey {
        builder.add_TextLocalizeKey(x);
      }
      if let Some(x) = args.PortraitPath {
        builder.add_PortraitPath(x);
      }
      let x = args.OperatorOutputPriority;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_OperatorOutputPriority(x);
      let x = args.Duration;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_Duration(x);
      let x = args.OutputDelay;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_OutputDelay(x);
      let x = args.RandomWeight;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_RandomWeight(x);
      let x = args.OutputSequence;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_OutputSequence(x);
      let x = args.OperatorCondition;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_OperatorCondition(x);
      if let Some(x) = args.GroupId {
        builder.add_GroupId(x);
      }
      builder.add_OperatorWaitQueue(args.OperatorWaitQueue);
    builder.finish()
  }

  pub fn unpack(&self) -> OperatorExcelT {
    let key = table_encryption_service::create_key(b"Operator");
      let UniqueId = self.UniqueId();
    let GroupId = self.GroupId().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let OperatorCondition = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.OperatorCondition(), &key)
      } else {
        self.OperatorCondition()
      };
      let OutputSequence = self.OutputSequence();
      let RandomWeight = self.RandomWeight();
      let OutputDelay = self.OutputDelay();
      let Duration = self.Duration();
      let OperatorOutputPriority = self.OperatorOutputPriority();
    let PortraitPath = self.PortraitPath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let TextLocalizeKey = self.TextLocalizeKey().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let VoiceId = self.VoiceId().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_uint(*val, &key) } else { *val }).collect()
    });
      let OperatorWaitQueue = self.OperatorWaitQueue();
    OperatorExcelT {
      UniqueId,
      GroupId,
      OperatorCondition,
      OutputSequence,
      RandomWeight,
      OutputDelay,
      Duration,
      OperatorOutputPriority,
      PortraitPath,
      TextLocalizeKey,
      VoiceId,
      OperatorWaitQueue,
    }
  }

  #[inline]
  pub fn UniqueId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(OperatorExcel::VT_UNIQUEID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn GroupId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OperatorExcel::VT_GROUPID, None)}
  }
  #[inline]
  pub fn OperatorCondition(&self) -> OperatorCondition {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<OperatorCondition>(OperatorExcel::VT_OPERATORCONDITION, Some(OperatorCondition::None)).unwrap()}
  }
  #[inline]
  pub fn OutputSequence(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(OperatorExcel::VT_OUTPUTSEQUENCE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn RandomWeight(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(OperatorExcel::VT_RANDOMWEIGHT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn OutputDelay(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(OperatorExcel::VT_OUTPUTDELAY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn Duration(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(OperatorExcel::VT_DURATION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn OperatorOutputPriority(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(OperatorExcel::VT_OPERATOROUTPUTPRIORITY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn PortraitPath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OperatorExcel::VT_PORTRAITPATH, None)}
  }
  #[inline]
  pub fn TextLocalizeKey(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OperatorExcel::VT_TEXTLOCALIZEKEY, None)}
  }
  #[inline]
  pub fn VoiceId(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(OperatorExcel::VT_VOICEID, None)}
  }
  #[inline]
  pub fn OperatorWaitQueue(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(OperatorExcel::VT_OPERATORWAITQUEUE, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for OperatorExcel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("UniqueId", Self::VT_UNIQUEID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("GroupId", Self::VT_GROUPID, false)?
     .visit_field::<OperatorCondition>("OperatorCondition", Self::VT_OPERATORCONDITION, false)?
     .visit_field::<i32>("OutputSequence", Self::VT_OUTPUTSEQUENCE, false)?
     .visit_field::<i32>("RandomWeight", Self::VT_RANDOMWEIGHT, false)?
     .visit_field::<i32>("OutputDelay", Self::VT_OUTPUTDELAY, false)?
     .visit_field::<i32>("Duration", Self::VT_DURATION, false)?
     .visit_field::<i32>("OperatorOutputPriority", Self::VT_OPERATOROUTPUTPRIORITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PortraitPath", Self::VT_PORTRAITPATH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TextLocalizeKey", Self::VT_TEXTLOCALIZEKEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("VoiceId", Self::VT_VOICEID, false)?
     .visit_field::<bool>("OperatorWaitQueue", Self::VT_OPERATORWAITQUEUE, false)?
     .finish();
    Ok(())
  }
}
pub struct OperatorExcelArgs<'a> {
    pub UniqueId: i64,
    pub GroupId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OperatorCondition: OperatorCondition,
    pub OutputSequence: i32,
    pub RandomWeight: i32,
    pub OutputDelay: i32,
    pub Duration: i32,
    pub OperatorOutputPriority: i32,
    pub PortraitPath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TextLocalizeKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub VoiceId: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub OperatorWaitQueue: bool,
}
impl<'a> Default for OperatorExcelArgs<'a> {
  #[inline]
  fn default() -> Self {
    OperatorExcelArgs {
      UniqueId: 0,
      GroupId: None,
      OperatorCondition: OperatorCondition::None,
      OutputSequence: 0,
      RandomWeight: 0,
      OutputDelay: 0,
      Duration: 0,
      OperatorOutputPriority: 0,
      PortraitPath: None,
      TextLocalizeKey: None,
      VoiceId: None,
      OperatorWaitQueue: false,
    }
  }
}

impl Serialize for OperatorExcel<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("OperatorExcel", 12)?;
      s.serialize_field("UniqueId", &self.UniqueId())?;
      if let Some(f) = self.GroupId() {
        s.serialize_field("GroupId", &f)?;
      } else {
        s.skip_field("GroupId")?;
      }
      s.serialize_field("OperatorCondition", &self.OperatorCondition())?;
      s.serialize_field("OutputSequence", &self.OutputSequence())?;
      s.serialize_field("RandomWeight", &self.RandomWeight())?;
      s.serialize_field("OutputDelay", &self.OutputDelay())?;
      s.serialize_field("Duration", &self.Duration())?;
      s.serialize_field("OperatorOutputPriority", &self.OperatorOutputPriority())?;
      if let Some(f) = self.PortraitPath() {
        s.serialize_field("PortraitPath", &f)?;
      } else {
        s.skip_field("PortraitPath")?;
      }
      if let Some(f) = self.TextLocalizeKey() {
        s.serialize_field("TextLocalizeKey", &f)?;
      } else {
        s.skip_field("TextLocalizeKey")?;
      }
      if let Some(f) = self.VoiceId() {
        s.serialize_field("VoiceId", &f)?;
      } else {
        s.skip_field("VoiceId")?;
      }
      s.serialize_field("OperatorWaitQueue", &self.OperatorWaitQueue())?;
    s.end()
  }
}

pub struct OperatorExcelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OperatorExcelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_UniqueId(&mut self, UniqueId: i64) {
    self.fbb_.push_slot::<i64>(OperatorExcel::VT_UNIQUEID, UniqueId, 0);
  }
  #[inline]
  pub fn add_GroupId(&mut self, GroupId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OperatorExcel::VT_GROUPID, GroupId);
  }
  #[inline]
  pub fn add_OperatorCondition(&mut self, OperatorCondition: OperatorCondition) {
    self.fbb_.push_slot::<OperatorCondition>(OperatorExcel::VT_OPERATORCONDITION, OperatorCondition, OperatorCondition::None);
  }
  #[inline]
  pub fn add_OutputSequence(&mut self, OutputSequence: i32) {
    self.fbb_.push_slot::<i32>(OperatorExcel::VT_OUTPUTSEQUENCE, OutputSequence, 0);
  }
  #[inline]
  pub fn add_RandomWeight(&mut self, RandomWeight: i32) {
    self.fbb_.push_slot::<i32>(OperatorExcel::VT_RANDOMWEIGHT, RandomWeight, 0);
  }
  #[inline]
  pub fn add_OutputDelay(&mut self, OutputDelay: i32) {
    self.fbb_.push_slot::<i32>(OperatorExcel::VT_OUTPUTDELAY, OutputDelay, 0);
  }
  #[inline]
  pub fn add_Duration(&mut self, Duration: i32) {
    self.fbb_.push_slot::<i32>(OperatorExcel::VT_DURATION, Duration, 0);
  }
  #[inline]
  pub fn add_OperatorOutputPriority(&mut self, OperatorOutputPriority: i32) {
    self.fbb_.push_slot::<i32>(OperatorExcel::VT_OPERATOROUTPUTPRIORITY, OperatorOutputPriority, 0);
  }
  #[inline]
  pub fn add_PortraitPath(&mut self, PortraitPath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OperatorExcel::VT_PORTRAITPATH, PortraitPath);
  }
  #[inline]
  pub fn add_TextLocalizeKey(&mut self, TextLocalizeKey: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OperatorExcel::VT_TEXTLOCALIZEKEY, TextLocalizeKey);
  }
  #[inline]
  pub fn add_VoiceId(&mut self, VoiceId: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OperatorExcel::VT_VOICEID, VoiceId);
  }
  #[inline]
  pub fn add_OperatorWaitQueue(&mut self, OperatorWaitQueue: bool) {
    self.fbb_.push_slot::<bool>(OperatorExcel::VT_OPERATORWAITQUEUE, OperatorWaitQueue, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> OperatorExcelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    OperatorExcelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OperatorExcel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for OperatorExcel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("OperatorExcel");
      ds.field("UniqueId", &self.UniqueId());
      ds.field("GroupId", &self.GroupId());
      ds.field("OperatorCondition", &self.OperatorCondition());
      ds.field("OutputSequence", &self.OutputSequence());
      ds.field("RandomWeight", &self.RandomWeight());
      ds.field("OutputDelay", &self.OutputDelay());
      ds.field("Duration", &self.Duration());
      ds.field("OperatorOutputPriority", &self.OperatorOutputPriority());
      ds.field("PortraitPath", &self.PortraitPath());
      ds.field("TextLocalizeKey", &self.TextLocalizeKey());
      ds.field("VoiceId", &self.VoiceId());
      ds.field("OperatorWaitQueue", &self.OperatorWaitQueue());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct OperatorExcelT {
  pub UniqueId: i64,
  pub GroupId: Option<String>,
  pub OperatorCondition: OperatorCondition,
  pub OutputSequence: i32,
  pub RandomWeight: i32,
  pub OutputDelay: i32,
  pub Duration: i32,
  pub OperatorOutputPriority: i32,
  pub PortraitPath: Option<String>,
  pub TextLocalizeKey: Option<String>,
  pub VoiceId: Option<Vec<u32>>,
  pub OperatorWaitQueue: bool,
}
impl Default for OperatorExcelT {
  fn default() -> Self {
    Self {
      UniqueId: 0,
      GroupId: None,
      OperatorCondition: OperatorCondition::None,
      OutputSequence: 0,
      RandomWeight: 0,
      OutputDelay: 0,
      Duration: 0,
      OperatorOutputPriority: 0,
      PortraitPath: None,
      TextLocalizeKey: None,
      VoiceId: None,
      OperatorWaitQueue: false,
    }
  }
}
impl OperatorExcelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<OperatorExcel<'b>> {
    let UniqueId = self.UniqueId;
    let GroupId = self.GroupId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OperatorCondition = self.OperatorCondition;
    let OutputSequence = self.OutputSequence;
    let RandomWeight = self.RandomWeight;
    let OutputDelay = self.OutputDelay;
    let Duration = self.Duration;
    let OperatorOutputPriority = self.OperatorOutputPriority;
    let PortraitPath = self.PortraitPath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TextLocalizeKey = self.TextLocalizeKey.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let VoiceId = self.VoiceId.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let OperatorWaitQueue = self.OperatorWaitQueue;
    OperatorExcel::create(_fbb, &OperatorExcelArgs{
      UniqueId,
      GroupId,
      OperatorCondition,
      OutputSequence,
      RandomWeight,
      OutputDelay,
      Duration,
      OperatorOutputPriority,
      PortraitPath,
      TextLocalizeKey,
      VoiceId,
      OperatorWaitQueue,
    })
  }
}
