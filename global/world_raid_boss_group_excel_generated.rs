// automatically generated by the FlatBuffers compiler, do not modify
// @generated
#![allow(unused_imports, dead_code)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum WorldRaidBossGroupExcelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct WorldRaidBossGroupExcel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WorldRaidBossGroupExcel<'a> {
  type Inner = WorldRaidBossGroupExcel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> WorldRaidBossGroupExcel<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_WORLDRAIDBOSSGROUPID: flatbuffers::VOffsetT = 6;
  pub const VT_WORLDBOSSNAME: flatbuffers::VOffsetT = 8;
  pub const VT_WORLDBOSSPOPUPPORTRAIT: flatbuffers::VOffsetT = 10;
  pub const VT_WORLDBOSSPOPUPBG: flatbuffers::VOffsetT = 12;
  pub const VT_WORLDBOSSPARCELPORTRAIT: flatbuffers::VOffsetT = 14;
  pub const VT_WORLDBOSSLISTPARCEL: flatbuffers::VOffsetT = 16;
  pub const VT_WORLDBOSSHP: flatbuffers::VOffsetT = 18;
  pub const VT_WORLDBOSSHPTW: flatbuffers::VOffsetT = 20;
  pub const VT_WORLDBOSSHPASIA: flatbuffers::VOffsetT = 22;
  pub const VT_WORLDBOSSHPNA: flatbuffers::VOffsetT = 24;
  pub const VT_WORLDBOSSHPGLOBAL: flatbuffers::VOffsetT = 26;
  pub const VT_UIHIDEBEFORESPAWN: flatbuffers::VOffsetT = 28;
  pub const VT_HIDEANOTHERBOSSKILLED: flatbuffers::VOffsetT = 30;
  pub const VT_WORLDBOSSCLEARREWARDGROUPID: flatbuffers::VOffsetT = 32;
  pub const VT_ANOTHERBOSSKILLED: flatbuffers::VOffsetT = 34;
  pub const VT_ECHELONCONSTRAINTGROUPID: flatbuffers::VOffsetT = 36;
  pub const VT_EXCLUSIVEOPERATORBOSSSPAWN: flatbuffers::VOffsetT = 38;
  pub const VT_EXCLUSIVEOPERATORBOSSKILL: flatbuffers::VOffsetT = 40;
  pub const VT_EXCLUSIVEOPERATORSCENARIOBATTLE: flatbuffers::VOffsetT = 42;
  pub const VT_EXCLUSIVEOPERATORBOSSDAMAGED: flatbuffers::VOffsetT = 44;
  pub const VT_BOSSGROUPOPENCONDITION: flatbuffers::VOffsetT = 46;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    WorldRaidBossGroupExcel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args WorldRaidBossGroupExcelArgs<'args>
  ) -> flatbuffers::WIPOffset<WorldRaidBossGroupExcel<'bldr>> {
    let mut builder = WorldRaidBossGroupExcelBuilder::new(_fbb);
    let key = table_encryption_service::create_key(b"WorldRaidBossGroup");
      let x = args.BossGroupOpenCondition;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_BossGroupOpenCondition(x);
      let x = args.EchelonConstraintGroupId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_EchelonConstraintGroupId(x);
      let x = args.WorldBossClearRewardGroupId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_WorldBossClearRewardGroupId(x);
      let x = args.WorldBossHPGlobal;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_WorldBossHPGlobal(x);
      let x = args.WorldBossHPNa;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_WorldBossHPNa(x);
      let x = args.WorldBossHPAsia;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_WorldBossHPAsia(x);
      let x = args.WorldBossHPTw;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_WorldBossHPTw(x);
      let x = args.WorldBossHP;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_WorldBossHP(x);
      let x = args.WorldRaidBossGroupId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_WorldRaidBossGroupId(x);
      let x = args.Id;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_Id(x);
      if let Some(x) = args.ExclusiveOperatorBossDamaged {
        builder.add_ExclusiveOperatorBossDamaged(x);
      }
      if let Some(x) = args.ExclusiveOperatorScenarioBattle {
        builder.add_ExclusiveOperatorScenarioBattle(x);
      }
      if let Some(x) = args.ExclusiveOperatorBossKill {
        builder.add_ExclusiveOperatorBossKill(x);
      }
      if let Some(x) = args.ExclusiveOperatorBossSpawn {
        builder.add_ExclusiveOperatorBossSpawn(x);
      }
      if let Some(x) = args.AnotherBossKilled {
        builder.add_AnotherBossKilled(x);
      }
      if let Some(x) = args.WorldBossListParcel {
        builder.add_WorldBossListParcel(x);
      }
      if let Some(x) = args.WorldBossParcelPortrait {
        builder.add_WorldBossParcelPortrait(x);
      }
      if let Some(x) = args.WorldBossPopupBG {
        builder.add_WorldBossPopupBG(x);
      }
      if let Some(x) = args.WorldBossPopupPortrait {
        builder.add_WorldBossPopupPortrait(x);
      }
      if let Some(x) = args.WorldBossName {
        builder.add_WorldBossName(x);
      }
      builder.add_HideAnotherBossKilled(args.HideAnotherBossKilled);
      builder.add_UIHideBeforeSpawn(args.UIHideBeforeSpawn);
    builder.finish()
  }

  pub fn unpack(&self) -> WorldRaidBossGroupExcelT {
    let key = table_encryption_service::create_key(b"WorldRaidBossGroup");
      let Id = self.Id();
      let WorldRaidBossGroupId = self.WorldRaidBossGroupId();
    let WorldBossName = self.WorldBossName().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let WorldBossPopupPortrait = self.WorldBossPopupPortrait().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let WorldBossPopupBG = self.WorldBossPopupBG().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let WorldBossParcelPortrait = self.WorldBossParcelPortrait().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let WorldBossListParcel = self.WorldBossListParcel().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let WorldBossHP = self.WorldBossHP();
      let WorldBossHPTw = self.WorldBossHPTw();
      let WorldBossHPAsia = self.WorldBossHPAsia();
      let WorldBossHPNa = self.WorldBossHPNa();
      let WorldBossHPGlobal = self.WorldBossHPGlobal();
      let UIHideBeforeSpawn = self.UIHideBeforeSpawn();
      let HideAnotherBossKilled = self.HideAnotherBossKilled();
      let WorldBossClearRewardGroupId = self.WorldBossClearRewardGroupId();
    let AnotherBossKilled = self.AnotherBossKilled().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_long(*val, &key) } else { *val }).collect()
    });
      let EchelonConstraintGroupId = self.EchelonConstraintGroupId();
    let ExclusiveOperatorBossSpawn = self.ExclusiveOperatorBossSpawn().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let ExclusiveOperatorBossKill = self.ExclusiveOperatorBossKill().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let ExclusiveOperatorScenarioBattle = self.ExclusiveOperatorScenarioBattle().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let ExclusiveOperatorBossDamaged = self.ExclusiveOperatorBossDamaged().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let BossGroupOpenCondition = self.BossGroupOpenCondition();
    WorldRaidBossGroupExcelT {
      Id,
      WorldRaidBossGroupId,
      WorldBossName,
      WorldBossPopupPortrait,
      WorldBossPopupBG,
      WorldBossParcelPortrait,
      WorldBossListParcel,
      WorldBossHP,
      WorldBossHPTw,
      WorldBossHPAsia,
      WorldBossHPNa,
      WorldBossHPGlobal,
      UIHideBeforeSpawn,
      HideAnotherBossKilled,
      WorldBossClearRewardGroupId,
      AnotherBossKilled,
      EchelonConstraintGroupId,
      ExclusiveOperatorBossSpawn,
      ExclusiveOperatorBossKill,
      ExclusiveOperatorScenarioBattle,
      ExclusiveOperatorBossDamaged,
      BossGroupOpenCondition,
    }
  }

  #[inline]
  pub fn Id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(WorldRaidBossGroupExcel::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn WorldRaidBossGroupId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(WorldRaidBossGroupExcel::VT_WORLDRAIDBOSSGROUPID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn WorldBossName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WorldRaidBossGroupExcel::VT_WORLDBOSSNAME, None)}
  }
  #[inline]
  pub fn WorldBossPopupPortrait(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WorldRaidBossGroupExcel::VT_WORLDBOSSPOPUPPORTRAIT, None)}
  }
  #[inline]
  pub fn WorldBossPopupBG(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WorldRaidBossGroupExcel::VT_WORLDBOSSPOPUPBG, None)}
  }
  #[inline]
  pub fn WorldBossParcelPortrait(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WorldRaidBossGroupExcel::VT_WORLDBOSSPARCELPORTRAIT, None)}
  }
  #[inline]
  pub fn WorldBossListParcel(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WorldRaidBossGroupExcel::VT_WORLDBOSSLISTPARCEL, None)}
  }
  #[inline]
  pub fn WorldBossHP(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(WorldRaidBossGroupExcel::VT_WORLDBOSSHP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn WorldBossHPTw(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(WorldRaidBossGroupExcel::VT_WORLDBOSSHPTW, Some(0)).unwrap()}
  }
  #[inline]
  pub fn WorldBossHPAsia(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(WorldRaidBossGroupExcel::VT_WORLDBOSSHPASIA, Some(0)).unwrap()}
  }
  #[inline]
  pub fn WorldBossHPNa(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(WorldRaidBossGroupExcel::VT_WORLDBOSSHPNA, Some(0)).unwrap()}
  }
  #[inline]
  pub fn WorldBossHPGlobal(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(WorldRaidBossGroupExcel::VT_WORLDBOSSHPGLOBAL, Some(0)).unwrap()}
  }
  #[inline]
  pub fn UIHideBeforeSpawn(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(WorldRaidBossGroupExcel::VT_UIHIDEBEFORESPAWN, Some(false)).unwrap()}
  }
  #[inline]
  pub fn HideAnotherBossKilled(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(WorldRaidBossGroupExcel::VT_HIDEANOTHERBOSSKILLED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn WorldBossClearRewardGroupId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(WorldRaidBossGroupExcel::VT_WORLDBOSSCLEARREWARDGROUPID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn AnotherBossKilled(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(WorldRaidBossGroupExcel::VT_ANOTHERBOSSKILLED, None)}
  }
  #[inline]
  pub fn EchelonConstraintGroupId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(WorldRaidBossGroupExcel::VT_ECHELONCONSTRAINTGROUPID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ExclusiveOperatorBossSpawn(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WorldRaidBossGroupExcel::VT_EXCLUSIVEOPERATORBOSSSPAWN, None)}
  }
  #[inline]
  pub fn ExclusiveOperatorBossKill(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WorldRaidBossGroupExcel::VT_EXCLUSIVEOPERATORBOSSKILL, None)}
  }
  #[inline]
  pub fn ExclusiveOperatorScenarioBattle(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WorldRaidBossGroupExcel::VT_EXCLUSIVEOPERATORSCENARIOBATTLE, None)}
  }
  #[inline]
  pub fn ExclusiveOperatorBossDamaged(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WorldRaidBossGroupExcel::VT_EXCLUSIVEOPERATORBOSSDAMAGED, None)}
  }
  #[inline]
  pub fn BossGroupOpenCondition(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(WorldRaidBossGroupExcel::VT_BOSSGROUPOPENCONDITION, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for WorldRaidBossGroupExcel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("Id", Self::VT_ID, false)?
     .visit_field::<i64>("WorldRaidBossGroupId", Self::VT_WORLDRAIDBOSSGROUPID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("WorldBossName", Self::VT_WORLDBOSSNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("WorldBossPopupPortrait", Self::VT_WORLDBOSSPOPUPPORTRAIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("WorldBossPopupBG", Self::VT_WORLDBOSSPOPUPBG, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("WorldBossParcelPortrait", Self::VT_WORLDBOSSPARCELPORTRAIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("WorldBossListParcel", Self::VT_WORLDBOSSLISTPARCEL, false)?
     .visit_field::<i64>("WorldBossHP", Self::VT_WORLDBOSSHP, false)?
     .visit_field::<i64>("WorldBossHPTw", Self::VT_WORLDBOSSHPTW, false)?
     .visit_field::<i64>("WorldBossHPAsia", Self::VT_WORLDBOSSHPASIA, false)?
     .visit_field::<i64>("WorldBossHPNa", Self::VT_WORLDBOSSHPNA, false)?
     .visit_field::<i64>("WorldBossHPGlobal", Self::VT_WORLDBOSSHPGLOBAL, false)?
     .visit_field::<bool>("UIHideBeforeSpawn", Self::VT_UIHIDEBEFORESPAWN, false)?
     .visit_field::<bool>("HideAnotherBossKilled", Self::VT_HIDEANOTHERBOSSKILLED, false)?
     .visit_field::<i64>("WorldBossClearRewardGroupId", Self::VT_WORLDBOSSCLEARREWARDGROUPID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("AnotherBossKilled", Self::VT_ANOTHERBOSSKILLED, false)?
     .visit_field::<i64>("EchelonConstraintGroupId", Self::VT_ECHELONCONSTRAINTGROUPID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ExclusiveOperatorBossSpawn", Self::VT_EXCLUSIVEOPERATORBOSSSPAWN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ExclusiveOperatorBossKill", Self::VT_EXCLUSIVEOPERATORBOSSKILL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ExclusiveOperatorScenarioBattle", Self::VT_EXCLUSIVEOPERATORSCENARIOBATTLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ExclusiveOperatorBossDamaged", Self::VT_EXCLUSIVEOPERATORBOSSDAMAGED, false)?
     .visit_field::<i64>("BossGroupOpenCondition", Self::VT_BOSSGROUPOPENCONDITION, false)?
     .finish();
    Ok(())
  }
}
pub struct WorldRaidBossGroupExcelArgs<'a> {
    pub Id: i64,
    pub WorldRaidBossGroupId: i64,
    pub WorldBossName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub WorldBossPopupPortrait: Option<flatbuffers::WIPOffset<&'a str>>,
    pub WorldBossPopupBG: Option<flatbuffers::WIPOffset<&'a str>>,
    pub WorldBossParcelPortrait: Option<flatbuffers::WIPOffset<&'a str>>,
    pub WorldBossListParcel: Option<flatbuffers::WIPOffset<&'a str>>,
    pub WorldBossHP: i64,
    pub WorldBossHPTw: i64,
    pub WorldBossHPAsia: i64,
    pub WorldBossHPNa: i64,
    pub WorldBossHPGlobal: i64,
    pub UIHideBeforeSpawn: bool,
    pub HideAnotherBossKilled: bool,
    pub WorldBossClearRewardGroupId: i64,
    pub AnotherBossKilled: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub EchelonConstraintGroupId: i64,
    pub ExclusiveOperatorBossSpawn: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ExclusiveOperatorBossKill: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ExclusiveOperatorScenarioBattle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ExclusiveOperatorBossDamaged: Option<flatbuffers::WIPOffset<&'a str>>,
    pub BossGroupOpenCondition: i64,
}
impl<'a> Default for WorldRaidBossGroupExcelArgs<'a> {
  #[inline]
  fn default() -> Self {
    WorldRaidBossGroupExcelArgs {
      Id: 0,
      WorldRaidBossGroupId: 0,
      WorldBossName: None,
      WorldBossPopupPortrait: None,
      WorldBossPopupBG: None,
      WorldBossParcelPortrait: None,
      WorldBossListParcel: None,
      WorldBossHP: 0,
      WorldBossHPTw: 0,
      WorldBossHPAsia: 0,
      WorldBossHPNa: 0,
      WorldBossHPGlobal: 0,
      UIHideBeforeSpawn: false,
      HideAnotherBossKilled: false,
      WorldBossClearRewardGroupId: 0,
      AnotherBossKilled: None,
      EchelonConstraintGroupId: 0,
      ExclusiveOperatorBossSpawn: None,
      ExclusiveOperatorBossKill: None,
      ExclusiveOperatorScenarioBattle: None,
      ExclusiveOperatorBossDamaged: None,
      BossGroupOpenCondition: 0,
    }
  }
}

impl Serialize for WorldRaidBossGroupExcel<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("WorldRaidBossGroupExcel", 22)?;
      s.serialize_field("Id", &self.Id())?;
      s.serialize_field("WorldRaidBossGroupId", &self.WorldRaidBossGroupId())?;
      if let Some(f) = self.WorldBossName() {
        s.serialize_field("WorldBossName", &f)?;
      } else {
        s.skip_field("WorldBossName")?;
      }
      if let Some(f) = self.WorldBossPopupPortrait() {
        s.serialize_field("WorldBossPopupPortrait", &f)?;
      } else {
        s.skip_field("WorldBossPopupPortrait")?;
      }
      if let Some(f) = self.WorldBossPopupBG() {
        s.serialize_field("WorldBossPopupBG", &f)?;
      } else {
        s.skip_field("WorldBossPopupBG")?;
      }
      if let Some(f) = self.WorldBossParcelPortrait() {
        s.serialize_field("WorldBossParcelPortrait", &f)?;
      } else {
        s.skip_field("WorldBossParcelPortrait")?;
      }
      if let Some(f) = self.WorldBossListParcel() {
        s.serialize_field("WorldBossListParcel", &f)?;
      } else {
        s.skip_field("WorldBossListParcel")?;
      }
      s.serialize_field("WorldBossHP", &self.WorldBossHP())?;
      s.serialize_field("WorldBossHPTw", &self.WorldBossHPTw())?;
      s.serialize_field("WorldBossHPAsia", &self.WorldBossHPAsia())?;
      s.serialize_field("WorldBossHPNa", &self.WorldBossHPNa())?;
      s.serialize_field("WorldBossHPGlobal", &self.WorldBossHPGlobal())?;
      s.serialize_field("UIHideBeforeSpawn", &self.UIHideBeforeSpawn())?;
      s.serialize_field("HideAnotherBossKilled", &self.HideAnotherBossKilled())?;
      s.serialize_field("WorldBossClearRewardGroupId", &self.WorldBossClearRewardGroupId())?;
      if let Some(f) = self.AnotherBossKilled() {
        s.serialize_field("AnotherBossKilled", &f)?;
      } else {
        s.skip_field("AnotherBossKilled")?;
      }
      s.serialize_field("EchelonConstraintGroupId", &self.EchelonConstraintGroupId())?;
      if let Some(f) = self.ExclusiveOperatorBossSpawn() {
        s.serialize_field("ExclusiveOperatorBossSpawn", &f)?;
      } else {
        s.skip_field("ExclusiveOperatorBossSpawn")?;
      }
      if let Some(f) = self.ExclusiveOperatorBossKill() {
        s.serialize_field("ExclusiveOperatorBossKill", &f)?;
      } else {
        s.skip_field("ExclusiveOperatorBossKill")?;
      }
      if let Some(f) = self.ExclusiveOperatorScenarioBattle() {
        s.serialize_field("ExclusiveOperatorScenarioBattle", &f)?;
      } else {
        s.skip_field("ExclusiveOperatorScenarioBattle")?;
      }
      if let Some(f) = self.ExclusiveOperatorBossDamaged() {
        s.serialize_field("ExclusiveOperatorBossDamaged", &f)?;
      } else {
        s.skip_field("ExclusiveOperatorBossDamaged")?;
      }
      s.serialize_field("BossGroupOpenCondition", &self.BossGroupOpenCondition())?;
    s.end()
  }
}

pub struct WorldRaidBossGroupExcelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> WorldRaidBossGroupExcelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_Id(&mut self, Id: i64) {
    self.fbb_.push_slot::<i64>(WorldRaidBossGroupExcel::VT_ID, Id, 0);
  }
  #[inline]
  pub fn add_WorldRaidBossGroupId(&mut self, WorldRaidBossGroupId: i64) {
    self.fbb_.push_slot::<i64>(WorldRaidBossGroupExcel::VT_WORLDRAIDBOSSGROUPID, WorldRaidBossGroupId, 0);
  }
  #[inline]
  pub fn add_WorldBossName(&mut self, WorldBossName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WorldRaidBossGroupExcel::VT_WORLDBOSSNAME, WorldBossName);
  }
  #[inline]
  pub fn add_WorldBossPopupPortrait(&mut self, WorldBossPopupPortrait: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WorldRaidBossGroupExcel::VT_WORLDBOSSPOPUPPORTRAIT, WorldBossPopupPortrait);
  }
  #[inline]
  pub fn add_WorldBossPopupBG(&mut self, WorldBossPopupBG: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WorldRaidBossGroupExcel::VT_WORLDBOSSPOPUPBG, WorldBossPopupBG);
  }
  #[inline]
  pub fn add_WorldBossParcelPortrait(&mut self, WorldBossParcelPortrait: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WorldRaidBossGroupExcel::VT_WORLDBOSSPARCELPORTRAIT, WorldBossParcelPortrait);
  }
  #[inline]
  pub fn add_WorldBossListParcel(&mut self, WorldBossListParcel: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WorldRaidBossGroupExcel::VT_WORLDBOSSLISTPARCEL, WorldBossListParcel);
  }
  #[inline]
  pub fn add_WorldBossHP(&mut self, WorldBossHP: i64) {
    self.fbb_.push_slot::<i64>(WorldRaidBossGroupExcel::VT_WORLDBOSSHP, WorldBossHP, 0);
  }
  #[inline]
  pub fn add_WorldBossHPTw(&mut self, WorldBossHPTw: i64) {
    self.fbb_.push_slot::<i64>(WorldRaidBossGroupExcel::VT_WORLDBOSSHPTW, WorldBossHPTw, 0);
  }
  #[inline]
  pub fn add_WorldBossHPAsia(&mut self, WorldBossHPAsia: i64) {
    self.fbb_.push_slot::<i64>(WorldRaidBossGroupExcel::VT_WORLDBOSSHPASIA, WorldBossHPAsia, 0);
  }
  #[inline]
  pub fn add_WorldBossHPNa(&mut self, WorldBossHPNa: i64) {
    self.fbb_.push_slot::<i64>(WorldRaidBossGroupExcel::VT_WORLDBOSSHPNA, WorldBossHPNa, 0);
  }
  #[inline]
  pub fn add_WorldBossHPGlobal(&mut self, WorldBossHPGlobal: i64) {
    self.fbb_.push_slot::<i64>(WorldRaidBossGroupExcel::VT_WORLDBOSSHPGLOBAL, WorldBossHPGlobal, 0);
  }
  #[inline]
  pub fn add_UIHideBeforeSpawn(&mut self, UIHideBeforeSpawn: bool) {
    self.fbb_.push_slot::<bool>(WorldRaidBossGroupExcel::VT_UIHIDEBEFORESPAWN, UIHideBeforeSpawn, false);
  }
  #[inline]
  pub fn add_HideAnotherBossKilled(&mut self, HideAnotherBossKilled: bool) {
    self.fbb_.push_slot::<bool>(WorldRaidBossGroupExcel::VT_HIDEANOTHERBOSSKILLED, HideAnotherBossKilled, false);
  }
  #[inline]
  pub fn add_WorldBossClearRewardGroupId(&mut self, WorldBossClearRewardGroupId: i64) {
    self.fbb_.push_slot::<i64>(WorldRaidBossGroupExcel::VT_WORLDBOSSCLEARREWARDGROUPID, WorldBossClearRewardGroupId, 0);
  }
  #[inline]
  pub fn add_AnotherBossKilled(&mut self, AnotherBossKilled: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WorldRaidBossGroupExcel::VT_ANOTHERBOSSKILLED, AnotherBossKilled);
  }
  #[inline]
  pub fn add_EchelonConstraintGroupId(&mut self, EchelonConstraintGroupId: i64) {
    self.fbb_.push_slot::<i64>(WorldRaidBossGroupExcel::VT_ECHELONCONSTRAINTGROUPID, EchelonConstraintGroupId, 0);
  }
  #[inline]
  pub fn add_ExclusiveOperatorBossSpawn(&mut self, ExclusiveOperatorBossSpawn: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WorldRaidBossGroupExcel::VT_EXCLUSIVEOPERATORBOSSSPAWN, ExclusiveOperatorBossSpawn);
  }
  #[inline]
  pub fn add_ExclusiveOperatorBossKill(&mut self, ExclusiveOperatorBossKill: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WorldRaidBossGroupExcel::VT_EXCLUSIVEOPERATORBOSSKILL, ExclusiveOperatorBossKill);
  }
  #[inline]
  pub fn add_ExclusiveOperatorScenarioBattle(&mut self, ExclusiveOperatorScenarioBattle: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WorldRaidBossGroupExcel::VT_EXCLUSIVEOPERATORSCENARIOBATTLE, ExclusiveOperatorScenarioBattle);
  }
  #[inline]
  pub fn add_ExclusiveOperatorBossDamaged(&mut self, ExclusiveOperatorBossDamaged: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WorldRaidBossGroupExcel::VT_EXCLUSIVEOPERATORBOSSDAMAGED, ExclusiveOperatorBossDamaged);
  }
  #[inline]
  pub fn add_BossGroupOpenCondition(&mut self, BossGroupOpenCondition: i64) {
    self.fbb_.push_slot::<i64>(WorldRaidBossGroupExcel::VT_BOSSGROUPOPENCONDITION, BossGroupOpenCondition, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> WorldRaidBossGroupExcelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    WorldRaidBossGroupExcelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WorldRaidBossGroupExcel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for WorldRaidBossGroupExcel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("WorldRaidBossGroupExcel");
      ds.field("Id", &self.Id());
      ds.field("WorldRaidBossGroupId", &self.WorldRaidBossGroupId());
      ds.field("WorldBossName", &self.WorldBossName());
      ds.field("WorldBossPopupPortrait", &self.WorldBossPopupPortrait());
      ds.field("WorldBossPopupBG", &self.WorldBossPopupBG());
      ds.field("WorldBossParcelPortrait", &self.WorldBossParcelPortrait());
      ds.field("WorldBossListParcel", &self.WorldBossListParcel());
      ds.field("WorldBossHP", &self.WorldBossHP());
      ds.field("WorldBossHPTw", &self.WorldBossHPTw());
      ds.field("WorldBossHPAsia", &self.WorldBossHPAsia());
      ds.field("WorldBossHPNa", &self.WorldBossHPNa());
      ds.field("WorldBossHPGlobal", &self.WorldBossHPGlobal());
      ds.field("UIHideBeforeSpawn", &self.UIHideBeforeSpawn());
      ds.field("HideAnotherBossKilled", &self.HideAnotherBossKilled());
      ds.field("WorldBossClearRewardGroupId", &self.WorldBossClearRewardGroupId());
      ds.field("AnotherBossKilled", &self.AnotherBossKilled());
      ds.field("EchelonConstraintGroupId", &self.EchelonConstraintGroupId());
      ds.field("ExclusiveOperatorBossSpawn", &self.ExclusiveOperatorBossSpawn());
      ds.field("ExclusiveOperatorBossKill", &self.ExclusiveOperatorBossKill());
      ds.field("ExclusiveOperatorScenarioBattle", &self.ExclusiveOperatorScenarioBattle());
      ds.field("ExclusiveOperatorBossDamaged", &self.ExclusiveOperatorBossDamaged());
      ds.field("BossGroupOpenCondition", &self.BossGroupOpenCondition());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct WorldRaidBossGroupExcelT {
  pub Id: i64,
  pub WorldRaidBossGroupId: i64,
  pub WorldBossName: Option<String>,
  pub WorldBossPopupPortrait: Option<String>,
  pub WorldBossPopupBG: Option<String>,
  pub WorldBossParcelPortrait: Option<String>,
  pub WorldBossListParcel: Option<String>,
  pub WorldBossHP: i64,
  pub WorldBossHPTw: i64,
  pub WorldBossHPAsia: i64,
  pub WorldBossHPNa: i64,
  pub WorldBossHPGlobal: i64,
  pub UIHideBeforeSpawn: bool,
  pub HideAnotherBossKilled: bool,
  pub WorldBossClearRewardGroupId: i64,
  pub AnotherBossKilled: Option<Vec<i64>>,
  pub EchelonConstraintGroupId: i64,
  pub ExclusiveOperatorBossSpawn: Option<String>,
  pub ExclusiveOperatorBossKill: Option<String>,
  pub ExclusiveOperatorScenarioBattle: Option<String>,
  pub ExclusiveOperatorBossDamaged: Option<String>,
  pub BossGroupOpenCondition: i64,
}
impl Default for WorldRaidBossGroupExcelT {
  fn default() -> Self {
    Self {
      Id: 0,
      WorldRaidBossGroupId: 0,
      WorldBossName: None,
      WorldBossPopupPortrait: None,
      WorldBossPopupBG: None,
      WorldBossParcelPortrait: None,
      WorldBossListParcel: None,
      WorldBossHP: 0,
      WorldBossHPTw: 0,
      WorldBossHPAsia: 0,
      WorldBossHPNa: 0,
      WorldBossHPGlobal: 0,
      UIHideBeforeSpawn: false,
      HideAnotherBossKilled: false,
      WorldBossClearRewardGroupId: 0,
      AnotherBossKilled: None,
      EchelonConstraintGroupId: 0,
      ExclusiveOperatorBossSpawn: None,
      ExclusiveOperatorBossKill: None,
      ExclusiveOperatorScenarioBattle: None,
      ExclusiveOperatorBossDamaged: None,
      BossGroupOpenCondition: 0,
    }
  }
}
impl WorldRaidBossGroupExcelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<WorldRaidBossGroupExcel<'b>> {
    let Id = self.Id;
    let WorldRaidBossGroupId = self.WorldRaidBossGroupId;
    let WorldBossName = self.WorldBossName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let WorldBossPopupPortrait = self.WorldBossPopupPortrait.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let WorldBossPopupBG = self.WorldBossPopupBG.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let WorldBossParcelPortrait = self.WorldBossParcelPortrait.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let WorldBossListParcel = self.WorldBossListParcel.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let WorldBossHP = self.WorldBossHP;
    let WorldBossHPTw = self.WorldBossHPTw;
    let WorldBossHPAsia = self.WorldBossHPAsia;
    let WorldBossHPNa = self.WorldBossHPNa;
    let WorldBossHPGlobal = self.WorldBossHPGlobal;
    let UIHideBeforeSpawn = self.UIHideBeforeSpawn;
    let HideAnotherBossKilled = self.HideAnotherBossKilled;
    let WorldBossClearRewardGroupId = self.WorldBossClearRewardGroupId;
    let AnotherBossKilled = self.AnotherBossKilled.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let EchelonConstraintGroupId = self.EchelonConstraintGroupId;
    let ExclusiveOperatorBossSpawn = self.ExclusiveOperatorBossSpawn.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ExclusiveOperatorBossKill = self.ExclusiveOperatorBossKill.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ExclusiveOperatorScenarioBattle = self.ExclusiveOperatorScenarioBattle.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ExclusiveOperatorBossDamaged = self.ExclusiveOperatorBossDamaged.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let BossGroupOpenCondition = self.BossGroupOpenCondition;
    WorldRaidBossGroupExcel::create(_fbb, &WorldRaidBossGroupExcelArgs{
      Id,
      WorldRaidBossGroupId,
      WorldBossName,
      WorldBossPopupPortrait,
      WorldBossPopupBG,
      WorldBossParcelPortrait,
      WorldBossListParcel,
      WorldBossHP,
      WorldBossHPTw,
      WorldBossHPAsia,
      WorldBossHPNa,
      WorldBossHPGlobal,
      UIHideBeforeSpawn,
      HideAnotherBossKilled,
      WorldBossClearRewardGroupId,
      AnotherBossKilled,
      EchelonConstraintGroupId,
      ExclusiveOperatorBossSpawn,
      ExclusiveOperatorBossKill,
      ExclusiveOperatorScenarioBattle,
      ExclusiveOperatorBossDamaged,
      BossGroupOpenCondition,
    })
  }
}
