// automatically generated by the FlatBuffers compiler, do not modify
// @generated
#![allow(unused_imports, dead_code)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum GoodsExcelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GoodsExcel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GoodsExcel<'a> {
  type Inner = GoodsExcel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GoodsExcel<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_RARITY: flatbuffers::VOffsetT = 8;
  pub const VT_ICONPATH: flatbuffers::VOffsetT = 10;
  pub const VT_CONSUMEPARCELTYPE: flatbuffers::VOffsetT = 12;
  pub const VT_CONSUMEPARCELID: flatbuffers::VOffsetT = 14;
  pub const VT_CONSUMEPARCELAMOUNT: flatbuffers::VOffsetT = 16;
  pub const VT_CONSUMECONDITION: flatbuffers::VOffsetT = 18;
  pub const VT_CONSUMEGACHATICKETTYPE: flatbuffers::VOffsetT = 20;
  pub const VT_CONSUMEGACHATICKETTYPEAMOUNT: flatbuffers::VOffsetT = 22;
  pub const VT_PRODUCTIDAOS: flatbuffers::VOffsetT = 24;
  pub const VT_PRODUCTIDIOS: flatbuffers::VOffsetT = 26;
  pub const VT_PRODUCTIDONE: flatbuffers::VOffsetT = 28;
  pub const VT_PRODUCTIDSGS: flatbuffers::VOffsetT = 30;
  pub const VT_PRODUCTIDSTEAM: flatbuffers::VOffsetT = 32;
  pub const VT_CONSUMEEXTRASTEP: flatbuffers::VOffsetT = 34;
  pub const VT_CONSUMEEXTRAAMOUNT: flatbuffers::VOffsetT = 36;
  pub const VT_STATE: flatbuffers::VOffsetT = 38;
  pub const VT_PARCELTYPE: flatbuffers::VOffsetT = 40;
  pub const VT_PARCELID: flatbuffers::VOffsetT = 42;
  pub const VT_PARCELAMOUNT: flatbuffers::VOffsetT = 44;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GoodsExcel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GoodsExcelArgs<'args>
  ) -> flatbuffers::WIPOffset<GoodsExcel<'bldr>> {
    let mut builder = GoodsExcelBuilder::new(_fbb);
    let key = table_encryption_service::create_key(b"Goods");
      let x = args.ProductIdSTEAM;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_ProductIdSTEAM(x);
      let x = args.ProductIdSGS;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_ProductIdSGS(x);
      let x = args.ProductIdONE;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_ProductIdONE(x);
      let x = args.ProductIdiOS;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_ProductIdiOS(x);
      let x = args.ProductIdAOS;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_ProductIdAOS(x);
      let x = args.Id;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_Id(x);
      if let Some(x) = args.ParcelAmount {
        builder.add_ParcelAmount(x);
      }
      if let Some(x) = args.ParcelId {
        builder.add_ParcelId(x);
      }
      if let Some(x) = args.ParcelType {
        builder.add_ParcelType(x);
      }
      let x = args.State;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_State(x);
      if let Some(x) = args.ConsumeExtraAmount {
        builder.add_ConsumeExtraAmount(x);
      }
      if let Some(x) = args.ConsumeExtraStep {
        builder.add_ConsumeExtraStep(x);
      }
      if let Some(x) = args.ConsumeGachaTicketTypeAmount {
        builder.add_ConsumeGachaTicketTypeAmount(x);
      }
      if let Some(x) = args.ConsumeGachaTicketType {
        builder.add_ConsumeGachaTicketType(x);
      }
      if let Some(x) = args.ConsumeCondition {
        builder.add_ConsumeCondition(x);
      }
      if let Some(x) = args.ConsumeParcelAmount {
        builder.add_ConsumeParcelAmount(x);
      }
      if let Some(x) = args.ConsumeParcelId {
        builder.add_ConsumeParcelId(x);
      }
      if let Some(x) = args.ConsumeParcelType {
        builder.add_ConsumeParcelType(x);
      }
      if let Some(x) = args.IconPath {
        builder.add_IconPath(x);
      }
      let x = args.Rarity;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_Rarity(x);
      let x = args.Type;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_Type(x);
    builder.finish()
  }

  pub fn unpack(&self) -> GoodsExcelT {
    let key = table_encryption_service::create_key(b"Goods");
      let Id = self.Id();
      let Type = self.Type();
      let Rarity = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.Rarity(), &key)
      } else {
        self.Rarity()
      };
    let IconPath = self.IconPath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let ConsumeParcelType = self.ConsumeParcelType().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(*val, &key) } else { *val }).collect()
    });
    let ConsumeParcelId = self.ConsumeParcelId().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_long(*val, &key) } else { *val }).collect()
    });
    let ConsumeParcelAmount = self.ConsumeParcelAmount().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_long(*val, &key) } else { *val }).collect()
    });
    let ConsumeCondition = self.ConsumeCondition().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(*val, &key) } else { *val }).collect()
    });
    let ConsumeGachaTicketType = self.ConsumeGachaTicketType().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(*val, &key) } else { *val }).collect()
    });
    let ConsumeGachaTicketTypeAmount = self.ConsumeGachaTicketTypeAmount().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_long(*val, &key) } else { *val }).collect()
    });
      let ProductIdAOS = self.ProductIdAOS();
      let ProductIdiOS = self.ProductIdiOS();
      let ProductIdONE = self.ProductIdONE();
      let ProductIdSGS = self.ProductIdSGS();
      let ProductIdSTEAM = self.ProductIdSTEAM();
    let ConsumeExtraStep = self.ConsumeExtraStep().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_long(*val, &key) } else { *val }).collect()
    });
    let ConsumeExtraAmount = self.ConsumeExtraAmount().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_long(*val, &key) } else { *val }).collect()
    });
      let State = self.State();
    let ParcelType = self.ParcelType().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(*val, &key) } else { *val }).collect()
    });
    let ParcelId = self.ParcelId().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_long(*val, &key) } else { *val }).collect()
    });
    let ParcelAmount = self.ParcelAmount().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_long(*val, &key) } else { *val }).collect()
    });
    GoodsExcelT {
      Id,
      Type,
      Rarity,
      IconPath,
      ConsumeParcelType,
      ConsumeParcelId,
      ConsumeParcelAmount,
      ConsumeCondition,
      ConsumeGachaTicketType,
      ConsumeGachaTicketTypeAmount,
      ProductIdAOS,
      ProductIdiOS,
      ProductIdONE,
      ProductIdSGS,
      ProductIdSTEAM,
      ConsumeExtraStep,
      ConsumeExtraAmount,
      State,
      ParcelType,
      ParcelId,
      ParcelAmount,
    }
  }

  #[inline]
  pub fn Id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GoodsExcel::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn Type(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(GoodsExcel::VT_TYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn Rarity(&self) -> Rarity {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Rarity>(GoodsExcel::VT_RARITY, Some(Rarity::N)).unwrap()}
  }
  #[inline]
  pub fn IconPath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GoodsExcel::VT_ICONPATH, None)}
  }
  #[inline]
  pub fn ConsumeParcelType(&self) -> Option<flatbuffers::Vector<'a, ParcelType>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, ParcelType>>>(GoodsExcel::VT_CONSUMEPARCELTYPE, None)}
  }
  #[inline]
  pub fn ConsumeParcelId(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(GoodsExcel::VT_CONSUMEPARCELID, None)}
  }
  #[inline]
  pub fn ConsumeParcelAmount(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(GoodsExcel::VT_CONSUMEPARCELAMOUNT, None)}
  }
  #[inline]
  pub fn ConsumeCondition(&self) -> Option<flatbuffers::Vector<'a, ConsumeCondition>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, ConsumeCondition>>>(GoodsExcel::VT_CONSUMECONDITION, None)}
  }
  #[inline]
  pub fn ConsumeGachaTicketType(&self) -> Option<flatbuffers::Vector<'a, GachaTicketType>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, GachaTicketType>>>(GoodsExcel::VT_CONSUMEGACHATICKETTYPE, None)}
  }
  #[inline]
  pub fn ConsumeGachaTicketTypeAmount(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(GoodsExcel::VT_CONSUMEGACHATICKETTYPEAMOUNT, None)}
  }
  #[inline]
  pub fn ProductIdAOS(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GoodsExcel::VT_PRODUCTIDAOS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ProductIdiOS(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GoodsExcel::VT_PRODUCTIDIOS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ProductIdONE(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GoodsExcel::VT_PRODUCTIDONE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ProductIdSGS(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GoodsExcel::VT_PRODUCTIDSGS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ProductIdSTEAM(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GoodsExcel::VT_PRODUCTIDSTEAM, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ConsumeExtraStep(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(GoodsExcel::VT_CONSUMEEXTRASTEP, None)}
  }
  #[inline]
  pub fn ConsumeExtraAmount(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(GoodsExcel::VT_CONSUMEEXTRAAMOUNT, None)}
  }
  #[inline]
  pub fn State(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(GoodsExcel::VT_STATE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ParcelType(&self) -> Option<flatbuffers::Vector<'a, ParcelType>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, ParcelType>>>(GoodsExcel::VT_PARCELTYPE, None)}
  }
  #[inline]
  pub fn ParcelId(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(GoodsExcel::VT_PARCELID, None)}
  }
  #[inline]
  pub fn ParcelAmount(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(GoodsExcel::VT_PARCELAMOUNT, None)}
  }
}

impl flatbuffers::Verifiable for GoodsExcel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("Id", Self::VT_ID, false)?
     .visit_field::<i32>("Type", Self::VT_TYPE, false)?
     .visit_field::<Rarity>("Rarity", Self::VT_RARITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("IconPath", Self::VT_ICONPATH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, ParcelType>>>("ConsumeParcelType", Self::VT_CONSUMEPARCELTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("ConsumeParcelId", Self::VT_CONSUMEPARCELID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("ConsumeParcelAmount", Self::VT_CONSUMEPARCELAMOUNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, ConsumeCondition>>>("ConsumeCondition", Self::VT_CONSUMECONDITION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, GachaTicketType>>>("ConsumeGachaTicketType", Self::VT_CONSUMEGACHATICKETTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("ConsumeGachaTicketTypeAmount", Self::VT_CONSUMEGACHATICKETTYPEAMOUNT, false)?
     .visit_field::<i64>("ProductIdAOS", Self::VT_PRODUCTIDAOS, false)?
     .visit_field::<i64>("ProductIdiOS", Self::VT_PRODUCTIDIOS, false)?
     .visit_field::<i64>("ProductIdONE", Self::VT_PRODUCTIDONE, false)?
     .visit_field::<i64>("ProductIdSGS", Self::VT_PRODUCTIDSGS, false)?
     .visit_field::<i64>("ProductIdSTEAM", Self::VT_PRODUCTIDSTEAM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("ConsumeExtraStep", Self::VT_CONSUMEEXTRASTEP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("ConsumeExtraAmount", Self::VT_CONSUMEEXTRAAMOUNT, false)?
     .visit_field::<i32>("State", Self::VT_STATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, ParcelType>>>("ParcelType", Self::VT_PARCELTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("ParcelId", Self::VT_PARCELID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("ParcelAmount", Self::VT_PARCELAMOUNT, false)?
     .finish();
    Ok(())
  }
}
pub struct GoodsExcelArgs<'a> {
    pub Id: i64,
    pub Type: i32,
    pub Rarity: Rarity,
    pub IconPath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ConsumeParcelType: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, ParcelType>>>,
    pub ConsumeParcelId: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub ConsumeParcelAmount: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub ConsumeCondition: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, ConsumeCondition>>>,
    pub ConsumeGachaTicketType: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, GachaTicketType>>>,
    pub ConsumeGachaTicketTypeAmount: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub ProductIdAOS: i64,
    pub ProductIdiOS: i64,
    pub ProductIdONE: i64,
    pub ProductIdSGS: i64,
    pub ProductIdSTEAM: i64,
    pub ConsumeExtraStep: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub ConsumeExtraAmount: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub State: i32,
    pub ParcelType: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, ParcelType>>>,
    pub ParcelId: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub ParcelAmount: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
}
impl<'a> Default for GoodsExcelArgs<'a> {
  #[inline]
  fn default() -> Self {
    GoodsExcelArgs {
      Id: 0,
      Type: 0,
      Rarity: Rarity::N,
      IconPath: None,
      ConsumeParcelType: None,
      ConsumeParcelId: None,
      ConsumeParcelAmount: None,
      ConsumeCondition: None,
      ConsumeGachaTicketType: None,
      ConsumeGachaTicketTypeAmount: None,
      ProductIdAOS: 0,
      ProductIdiOS: 0,
      ProductIdONE: 0,
      ProductIdSGS: 0,
      ProductIdSTEAM: 0,
      ConsumeExtraStep: None,
      ConsumeExtraAmount: None,
      State: 0,
      ParcelType: None,
      ParcelId: None,
      ParcelAmount: None,
    }
  }
}

impl Serialize for GoodsExcel<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("GoodsExcel", 21)?;
      s.serialize_field("Id", &self.Id())?;
      s.serialize_field("Type", &self.Type())?;
      s.serialize_field("Rarity", &self.Rarity())?;
      if let Some(f) = self.IconPath() {
        s.serialize_field("IconPath", &f)?;
      } else {
        s.skip_field("IconPath")?;
      }
      if let Some(f) = self.ConsumeParcelType() {
        s.serialize_field("ConsumeParcelType", &f)?;
      } else {
        s.skip_field("ConsumeParcelType")?;
      }
      if let Some(f) = self.ConsumeParcelId() {
        s.serialize_field("ConsumeParcelId", &f)?;
      } else {
        s.skip_field("ConsumeParcelId")?;
      }
      if let Some(f) = self.ConsumeParcelAmount() {
        s.serialize_field("ConsumeParcelAmount", &f)?;
      } else {
        s.skip_field("ConsumeParcelAmount")?;
      }
      if let Some(f) = self.ConsumeCondition() {
        s.serialize_field("ConsumeCondition", &f)?;
      } else {
        s.skip_field("ConsumeCondition")?;
      }
      if let Some(f) = self.ConsumeGachaTicketType() {
        s.serialize_field("ConsumeGachaTicketType", &f)?;
      } else {
        s.skip_field("ConsumeGachaTicketType")?;
      }
      if let Some(f) = self.ConsumeGachaTicketTypeAmount() {
        s.serialize_field("ConsumeGachaTicketTypeAmount", &f)?;
      } else {
        s.skip_field("ConsumeGachaTicketTypeAmount")?;
      }
      s.serialize_field("ProductIdAOS", &self.ProductIdAOS())?;
      s.serialize_field("ProductIdiOS", &self.ProductIdiOS())?;
      s.serialize_field("ProductIdONE", &self.ProductIdONE())?;
      s.serialize_field("ProductIdSGS", &self.ProductIdSGS())?;
      s.serialize_field("ProductIdSTEAM", &self.ProductIdSTEAM())?;
      if let Some(f) = self.ConsumeExtraStep() {
        s.serialize_field("ConsumeExtraStep", &f)?;
      } else {
        s.skip_field("ConsumeExtraStep")?;
      }
      if let Some(f) = self.ConsumeExtraAmount() {
        s.serialize_field("ConsumeExtraAmount", &f)?;
      } else {
        s.skip_field("ConsumeExtraAmount")?;
      }
      s.serialize_field("State", &self.State())?;
      if let Some(f) = self.ParcelType() {
        s.serialize_field("ParcelType", &f)?;
      } else {
        s.skip_field("ParcelType")?;
      }
      if let Some(f) = self.ParcelId() {
        s.serialize_field("ParcelId", &f)?;
      } else {
        s.skip_field("ParcelId")?;
      }
      if let Some(f) = self.ParcelAmount() {
        s.serialize_field("ParcelAmount", &f)?;
      } else {
        s.skip_field("ParcelAmount")?;
      }
    s.end()
  }
}

pub struct GoodsExcelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GoodsExcelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_Id(&mut self, Id: i64) {
    self.fbb_.push_slot::<i64>(GoodsExcel::VT_ID, Id, 0);
  }
  #[inline]
  pub fn add_Type(&mut self, Type: i32) {
    self.fbb_.push_slot::<i32>(GoodsExcel::VT_TYPE, Type, 0);
  }
  #[inline]
  pub fn add_Rarity(&mut self, Rarity: Rarity) {
    self.fbb_.push_slot::<Rarity>(GoodsExcel::VT_RARITY, Rarity, Rarity::N);
  }
  #[inline]
  pub fn add_IconPath(&mut self, IconPath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GoodsExcel::VT_ICONPATH, IconPath);
  }
  #[inline]
  pub fn add_ConsumeParcelType(&mut self, ConsumeParcelType: flatbuffers::WIPOffset<flatbuffers::Vector<'b , ParcelType>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GoodsExcel::VT_CONSUMEPARCELTYPE, ConsumeParcelType);
  }
  #[inline]
  pub fn add_ConsumeParcelId(&mut self, ConsumeParcelId: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GoodsExcel::VT_CONSUMEPARCELID, ConsumeParcelId);
  }
  #[inline]
  pub fn add_ConsumeParcelAmount(&mut self, ConsumeParcelAmount: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GoodsExcel::VT_CONSUMEPARCELAMOUNT, ConsumeParcelAmount);
  }
  #[inline]
  pub fn add_ConsumeCondition(&mut self, ConsumeCondition: flatbuffers::WIPOffset<flatbuffers::Vector<'b , ConsumeCondition>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GoodsExcel::VT_CONSUMECONDITION, ConsumeCondition);
  }
  #[inline]
  pub fn add_ConsumeGachaTicketType(&mut self, ConsumeGachaTicketType: flatbuffers::WIPOffset<flatbuffers::Vector<'b , GachaTicketType>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GoodsExcel::VT_CONSUMEGACHATICKETTYPE, ConsumeGachaTicketType);
  }
  #[inline]
  pub fn add_ConsumeGachaTicketTypeAmount(&mut self, ConsumeGachaTicketTypeAmount: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GoodsExcel::VT_CONSUMEGACHATICKETTYPEAMOUNT, ConsumeGachaTicketTypeAmount);
  }
  #[inline]
  pub fn add_ProductIdAOS(&mut self, ProductIdAOS: i64) {
    self.fbb_.push_slot::<i64>(GoodsExcel::VT_PRODUCTIDAOS, ProductIdAOS, 0);
  }
  #[inline]
  pub fn add_ProductIdiOS(&mut self, ProductIdiOS: i64) {
    self.fbb_.push_slot::<i64>(GoodsExcel::VT_PRODUCTIDIOS, ProductIdiOS, 0);
  }
  #[inline]
  pub fn add_ProductIdONE(&mut self, ProductIdONE: i64) {
    self.fbb_.push_slot::<i64>(GoodsExcel::VT_PRODUCTIDONE, ProductIdONE, 0);
  }
  #[inline]
  pub fn add_ProductIdSGS(&mut self, ProductIdSGS: i64) {
    self.fbb_.push_slot::<i64>(GoodsExcel::VT_PRODUCTIDSGS, ProductIdSGS, 0);
  }
  #[inline]
  pub fn add_ProductIdSTEAM(&mut self, ProductIdSTEAM: i64) {
    self.fbb_.push_slot::<i64>(GoodsExcel::VT_PRODUCTIDSTEAM, ProductIdSTEAM, 0);
  }
  #[inline]
  pub fn add_ConsumeExtraStep(&mut self, ConsumeExtraStep: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GoodsExcel::VT_CONSUMEEXTRASTEP, ConsumeExtraStep);
  }
  #[inline]
  pub fn add_ConsumeExtraAmount(&mut self, ConsumeExtraAmount: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GoodsExcel::VT_CONSUMEEXTRAAMOUNT, ConsumeExtraAmount);
  }
  #[inline]
  pub fn add_State(&mut self, State: i32) {
    self.fbb_.push_slot::<i32>(GoodsExcel::VT_STATE, State, 0);
  }
  #[inline]
  pub fn add_ParcelType(&mut self, ParcelType: flatbuffers::WIPOffset<flatbuffers::Vector<'b , ParcelType>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GoodsExcel::VT_PARCELTYPE, ParcelType);
  }
  #[inline]
  pub fn add_ParcelId(&mut self, ParcelId: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GoodsExcel::VT_PARCELID, ParcelId);
  }
  #[inline]
  pub fn add_ParcelAmount(&mut self, ParcelAmount: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GoodsExcel::VT_PARCELAMOUNT, ParcelAmount);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GoodsExcelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GoodsExcelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GoodsExcel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GoodsExcel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GoodsExcel");
      ds.field("Id", &self.Id());
      ds.field("Type", &self.Type());
      ds.field("Rarity", &self.Rarity());
      ds.field("IconPath", &self.IconPath());
      ds.field("ConsumeParcelType", &self.ConsumeParcelType());
      ds.field("ConsumeParcelId", &self.ConsumeParcelId());
      ds.field("ConsumeParcelAmount", &self.ConsumeParcelAmount());
      ds.field("ConsumeCondition", &self.ConsumeCondition());
      ds.field("ConsumeGachaTicketType", &self.ConsumeGachaTicketType());
      ds.field("ConsumeGachaTicketTypeAmount", &self.ConsumeGachaTicketTypeAmount());
      ds.field("ProductIdAOS", &self.ProductIdAOS());
      ds.field("ProductIdiOS", &self.ProductIdiOS());
      ds.field("ProductIdONE", &self.ProductIdONE());
      ds.field("ProductIdSGS", &self.ProductIdSGS());
      ds.field("ProductIdSTEAM", &self.ProductIdSTEAM());
      ds.field("ConsumeExtraStep", &self.ConsumeExtraStep());
      ds.field("ConsumeExtraAmount", &self.ConsumeExtraAmount());
      ds.field("State", &self.State());
      ds.field("ParcelType", &self.ParcelType());
      ds.field("ParcelId", &self.ParcelId());
      ds.field("ParcelAmount", &self.ParcelAmount());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GoodsExcelT {
  pub Id: i64,
  pub Type: i32,
  pub Rarity: Rarity,
  pub IconPath: Option<String>,
  pub ConsumeParcelType: Option<Vec<ParcelType>>,
  pub ConsumeParcelId: Option<Vec<i64>>,
  pub ConsumeParcelAmount: Option<Vec<i64>>,
  pub ConsumeCondition: Option<Vec<ConsumeCondition>>,
  pub ConsumeGachaTicketType: Option<Vec<GachaTicketType>>,
  pub ConsumeGachaTicketTypeAmount: Option<Vec<i64>>,
  pub ProductIdAOS: i64,
  pub ProductIdiOS: i64,
  pub ProductIdONE: i64,
  pub ProductIdSGS: i64,
  pub ProductIdSTEAM: i64,
  pub ConsumeExtraStep: Option<Vec<i64>>,
  pub ConsumeExtraAmount: Option<Vec<i64>>,
  pub State: i32,
  pub ParcelType: Option<Vec<ParcelType>>,
  pub ParcelId: Option<Vec<i64>>,
  pub ParcelAmount: Option<Vec<i64>>,
}
impl Default for GoodsExcelT {
  fn default() -> Self {
    Self {
      Id: 0,
      Type: 0,
      Rarity: Rarity::N,
      IconPath: None,
      ConsumeParcelType: None,
      ConsumeParcelId: None,
      ConsumeParcelAmount: None,
      ConsumeCondition: None,
      ConsumeGachaTicketType: None,
      ConsumeGachaTicketTypeAmount: None,
      ProductIdAOS: 0,
      ProductIdiOS: 0,
      ProductIdONE: 0,
      ProductIdSGS: 0,
      ProductIdSTEAM: 0,
      ConsumeExtraStep: None,
      ConsumeExtraAmount: None,
      State: 0,
      ParcelType: None,
      ParcelId: None,
      ParcelAmount: None,
    }
  }
}
impl GoodsExcelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<GoodsExcel<'b>> {
    let Id = self.Id;
    let Type = self.Type;
    let Rarity = self.Rarity;
    let IconPath = self.IconPath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ConsumeParcelType = self.ConsumeParcelType.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let ConsumeParcelId = self.ConsumeParcelId.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let ConsumeParcelAmount = self.ConsumeParcelAmount.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let ConsumeCondition = self.ConsumeCondition.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let ConsumeGachaTicketType = self.ConsumeGachaTicketType.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let ConsumeGachaTicketTypeAmount = self.ConsumeGachaTicketTypeAmount.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let ProductIdAOS = self.ProductIdAOS;
    let ProductIdiOS = self.ProductIdiOS;
    let ProductIdONE = self.ProductIdONE;
    let ProductIdSGS = self.ProductIdSGS;
    let ProductIdSTEAM = self.ProductIdSTEAM;
    let ConsumeExtraStep = self.ConsumeExtraStep.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let ConsumeExtraAmount = self.ConsumeExtraAmount.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let State = self.State;
    let ParcelType = self.ParcelType.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let ParcelId = self.ParcelId.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let ParcelAmount = self.ParcelAmount.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    GoodsExcel::create(_fbb, &GoodsExcelArgs{
      Id,
      Type,
      Rarity,
      IconPath,
      ConsumeParcelType,
      ConsumeParcelId,
      ConsumeParcelAmount,
      ConsumeCondition,
      ConsumeGachaTicketType,
      ConsumeGachaTicketTypeAmount,
      ProductIdAOS,
      ProductIdiOS,
      ProductIdONE,
      ProductIdSGS,
      ProductIdSTEAM,
      ConsumeExtraStep,
      ConsumeExtraAmount,
      State,
      ParcelType,
      ParcelId,
      ParcelAmount,
    })
  }
}
