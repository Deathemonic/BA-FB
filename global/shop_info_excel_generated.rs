// automatically generated by the FlatBuffers compiler, do not modify
// @generated
#![allow(unused_imports, dead_code)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum ShopInfoExcelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ShopInfoExcel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ShopInfoExcel<'a> {
  type Inner = ShopInfoExcel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ShopInfoExcel<'a> {
  pub const VT_CATEGORYTYPE: flatbuffers::VOffsetT = 4;
  pub const VT_ISREFRESH: flatbuffers::VOffsetT = 6;
  pub const VT_ISSOLDOUTDIMMED: flatbuffers::VOffsetT = 8;
  pub const VT_COSTPARCELTYPE: flatbuffers::VOffsetT = 10;
  pub const VT_COSTPARCELID: flatbuffers::VOffsetT = 12;
  pub const VT_AUTOREFRESHCOOLTIME: flatbuffers::VOffsetT = 14;
  pub const VT_SHOPREFRESHERTYPE: flatbuffers::VOffsetT = 16;
  pub const VT_SHOPREFRESHPERIODTYPE: flatbuffers::VOffsetT = 18;
  pub const VT_REFRESHABLECOUNT: flatbuffers::VOffsetT = 20;
  pub const VT_GOODSID: flatbuffers::VOffsetT = 22;
  pub const VT_OPENPERIODFROM: flatbuffers::VOffsetT = 24;
  pub const VT_OPENPERIODTO: flatbuffers::VOffsetT = 26;
  pub const VT_REFRESHPERIODBASETIME: flatbuffers::VOffsetT = 28;
  pub const VT_SHOPPRODUCTUPDATETIME: flatbuffers::VOffsetT = 30;
  pub const VT_DISPLAYPARCELTYPE: flatbuffers::VOffsetT = 32;
  pub const VT_DISPLAYPARCELID: flatbuffers::VOffsetT = 34;
  pub const VT_ISSHOPVISIBLE: flatbuffers::VOffsetT = 36;
  pub const VT_DISPLAYORDER: flatbuffers::VOffsetT = 38;
  pub const VT_SHOPUPDATEDATE: flatbuffers::VOffsetT = 40;
  pub const VT_SHOPUPDATEGROUPID1: flatbuffers::VOffsetT = 42;
  pub const VT_SHOPUPDATEGROUPID2: flatbuffers::VOffsetT = 44;
  pub const VT_SHOPUPDATEGROUPID3: flatbuffers::VOffsetT = 46;
  pub const VT_SHOPUPDATEGROUPID4: flatbuffers::VOffsetT = 48;
  pub const VT_SHOPUPDATEGROUPID5: flatbuffers::VOffsetT = 50;
  pub const VT_SHOPUPDATEGROUPID6: flatbuffers::VOffsetT = 52;
  pub const VT_SHOPUPDATEGROUPID7: flatbuffers::VOffsetT = 54;
  pub const VT_SHOPUPDATEGROUPID8: flatbuffers::VOffsetT = 56;
  pub const VT_SHOPUPDATEGROUPID9: flatbuffers::VOffsetT = 58;
  pub const VT_SHOPUPDATEGROUPID10: flatbuffers::VOffsetT = 60;
  pub const VT_SHOPUPDATEGROUPID11: flatbuffers::VOffsetT = 62;
  pub const VT_SHOPUPDATEGROUPID12: flatbuffers::VOffsetT = 64;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ShopInfoExcel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ShopInfoExcelArgs<'args>
  ) -> flatbuffers::WIPOffset<ShopInfoExcel<'bldr>> {
    let mut builder = ShopInfoExcelBuilder::new(_fbb);
    let key = table_encryption_service::create_key(b"ShopInfo");
      let x = args.DisplayParcelId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_DisplayParcelId(x);
      let x = args.RefreshAbleCount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_RefreshAbleCount(x);
      let x = args.AutoRefreshCoolTime;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_AutoRefreshCoolTime(x);
      let x = args.ShopUpdateGroupId12;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_ShopUpdateGroupId12(x);
      let x = args.ShopUpdateGroupId11;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_ShopUpdateGroupId11(x);
      let x = args.ShopUpdateGroupId10;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_ShopUpdateGroupId10(x);
      let x = args.ShopUpdateGroupId9;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_ShopUpdateGroupId9(x);
      let x = args.ShopUpdateGroupId8;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_ShopUpdateGroupId8(x);
      let x = args.ShopUpdateGroupId7;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_ShopUpdateGroupId7(x);
      let x = args.ShopUpdateGroupId6;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_ShopUpdateGroupId6(x);
      let x = args.ShopUpdateGroupId5;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_ShopUpdateGroupId5(x);
      let x = args.ShopUpdateGroupId4;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_ShopUpdateGroupId4(x);
      let x = args.ShopUpdateGroupId3;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_ShopUpdateGroupId3(x);
      let x = args.ShopUpdateGroupId2;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_ShopUpdateGroupId2(x);
      let x = args.ShopUpdateGroupId1;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_ShopUpdateGroupId1(x);
      let x = args.ShopUpdateDate;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_ShopUpdateDate(x);
      let x = args.DisplayOrder;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_DisplayOrder(x);
      let x = args.DisplayParcelType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_DisplayParcelType(x);
      if let Some(x) = args.ShopProductUpdateTime {
        builder.add_ShopProductUpdateTime(x);
      }
      if let Some(x) = args.RefreshPeriodBaseTime {
        builder.add_RefreshPeriodBaseTime(x);
      }
      if let Some(x) = args.OpenPeriodTo {
        builder.add_OpenPeriodTo(x);
      }
      if let Some(x) = args.OpenPeriodFrom {
        builder.add_OpenPeriodFrom(x);
      }
      if let Some(x) = args.GoodsId {
        builder.add_GoodsId(x);
      }
      let x = args.ShopRefreshPeriodType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_ShopRefreshPeriodType(x);
      let x = args.ShopRefresherType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_ShopRefresherType(x);
      if let Some(x) = args.CostParcelId {
        builder.add_CostParcelId(x);
      }
      if let Some(x) = args.CostParcelType {
        builder.add_CostParcelType(x);
      }
      let x = args.CategoryType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_CategoryType(x);
      builder.add_IsShopVisible(args.IsShopVisible);
      builder.add_IsSoldOutDimmed(args.IsSoldOutDimmed);
      builder.add_IsRefresh(args.IsRefresh);
    builder.finish()
  }

  pub fn unpack(&self) -> ShopInfoExcelT {
    let key = table_encryption_service::create_key(b"ShopInfo");
      let CategoryType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.CategoryType(), &key)
      } else {
        self.CategoryType()
      };
      let IsRefresh = self.IsRefresh();
      let IsSoldOutDimmed = self.IsSoldOutDimmed();
    let CostParcelType = self.CostParcelType().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(*val, &key) } else { *val }).collect()
    });
    let CostParcelId = self.CostParcelId().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_long(*val, &key) } else { *val }).collect()
    });
      let AutoRefreshCoolTime = self.AutoRefreshCoolTime();
      let ShopRefresherType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.ShopRefresherType(), &key)
      } else {
        self.ShopRefresherType()
      };
      let ShopRefreshPeriodType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.ShopRefreshPeriodType(), &key)
      } else {
        self.ShopRefreshPeriodType()
      };
      let RefreshAbleCount = self.RefreshAbleCount();
    let GoodsId = self.GoodsId().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_long(*val, &key) } else { *val }).collect()
    });
    let OpenPeriodFrom = self.OpenPeriodFrom().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let OpenPeriodTo = self.OpenPeriodTo().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let RefreshPeriodBaseTime = self.RefreshPeriodBaseTime().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let ShopProductUpdateTime = self.ShopProductUpdateTime().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let DisplayParcelType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.DisplayParcelType(), &key)
      } else {
        self.DisplayParcelType()
      };
      let DisplayParcelId = self.DisplayParcelId();
      let IsShopVisible = self.IsShopVisible();
      let DisplayOrder = self.DisplayOrder();
      let ShopUpdateDate = self.ShopUpdateDate();
      let ShopUpdateGroupId1 = self.ShopUpdateGroupId1();
      let ShopUpdateGroupId2 = self.ShopUpdateGroupId2();
      let ShopUpdateGroupId3 = self.ShopUpdateGroupId3();
      let ShopUpdateGroupId4 = self.ShopUpdateGroupId4();
      let ShopUpdateGroupId5 = self.ShopUpdateGroupId5();
      let ShopUpdateGroupId6 = self.ShopUpdateGroupId6();
      let ShopUpdateGroupId7 = self.ShopUpdateGroupId7();
      let ShopUpdateGroupId8 = self.ShopUpdateGroupId8();
      let ShopUpdateGroupId9 = self.ShopUpdateGroupId9();
      let ShopUpdateGroupId10 = self.ShopUpdateGroupId10();
      let ShopUpdateGroupId11 = self.ShopUpdateGroupId11();
      let ShopUpdateGroupId12 = self.ShopUpdateGroupId12();
    ShopInfoExcelT {
      CategoryType,
      IsRefresh,
      IsSoldOutDimmed,
      CostParcelType,
      CostParcelId,
      AutoRefreshCoolTime,
      ShopRefresherType,
      ShopRefreshPeriodType,
      RefreshAbleCount,
      GoodsId,
      OpenPeriodFrom,
      OpenPeriodTo,
      RefreshPeriodBaseTime,
      ShopProductUpdateTime,
      DisplayParcelType,
      DisplayParcelId,
      IsShopVisible,
      DisplayOrder,
      ShopUpdateDate,
      ShopUpdateGroupId1,
      ShopUpdateGroupId2,
      ShopUpdateGroupId3,
      ShopUpdateGroupId4,
      ShopUpdateGroupId5,
      ShopUpdateGroupId6,
      ShopUpdateGroupId7,
      ShopUpdateGroupId8,
      ShopUpdateGroupId9,
      ShopUpdateGroupId10,
      ShopUpdateGroupId11,
      ShopUpdateGroupId12,
    }
  }

  #[inline]
  pub fn CategoryType(&self) -> ShopCategoryType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ShopCategoryType>(ShopInfoExcel::VT_CATEGORYTYPE, Some(ShopCategoryType::General)).unwrap()}
  }
  #[inline]
  pub fn IsRefresh(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ShopInfoExcel::VT_ISREFRESH, Some(false)).unwrap()}
  }
  #[inline]
  pub fn IsSoldOutDimmed(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ShopInfoExcel::VT_ISSOLDOUTDIMMED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn CostParcelType(&self) -> Option<flatbuffers::Vector<'a, ParcelType>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, ParcelType>>>(ShopInfoExcel::VT_COSTPARCELTYPE, None)}
  }
  #[inline]
  pub fn CostParcelId(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(ShopInfoExcel::VT_COSTPARCELID, None)}
  }
  #[inline]
  pub fn AutoRefreshCoolTime(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ShopInfoExcel::VT_AUTOREFRESHCOOLTIME, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ShopRefresherType(&self) -> ShopRefresherType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ShopRefresherType>(ShopInfoExcel::VT_SHOPREFRESHERTYPE, Some(ShopRefresherType::None)).unwrap()}
  }
  #[inline]
  pub fn ShopRefreshPeriodType(&self) -> ShopRefreshPeriodType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ShopRefreshPeriodType>(ShopInfoExcel::VT_SHOPREFRESHPERIODTYPE, Some(ShopRefreshPeriodType::None)).unwrap()}
  }
  #[inline]
  pub fn RefreshAbleCount(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ShopInfoExcel::VT_REFRESHABLECOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn GoodsId(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(ShopInfoExcel::VT_GOODSID, None)}
  }
  #[inline]
  pub fn OpenPeriodFrom(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ShopInfoExcel::VT_OPENPERIODFROM, None)}
  }
  #[inline]
  pub fn OpenPeriodTo(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ShopInfoExcel::VT_OPENPERIODTO, None)}
  }
  #[inline]
  pub fn RefreshPeriodBaseTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ShopInfoExcel::VT_REFRESHPERIODBASETIME, None)}
  }
  #[inline]
  pub fn ShopProductUpdateTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ShopInfoExcel::VT_SHOPPRODUCTUPDATETIME, None)}
  }
  #[inline]
  pub fn DisplayParcelType(&self) -> ParcelType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ParcelType>(ShopInfoExcel::VT_DISPLAYPARCELTYPE, Some(ParcelType::None)).unwrap()}
  }
  #[inline]
  pub fn DisplayParcelId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ShopInfoExcel::VT_DISPLAYPARCELID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn IsShopVisible(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ShopInfoExcel::VT_ISSHOPVISIBLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn DisplayOrder(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ShopInfoExcel::VT_DISPLAYORDER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ShopUpdateDate(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ShopInfoExcel::VT_SHOPUPDATEDATE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ShopUpdateGroupId1(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ShopInfoExcel::VT_SHOPUPDATEGROUPID1, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ShopUpdateGroupId2(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ShopInfoExcel::VT_SHOPUPDATEGROUPID2, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ShopUpdateGroupId3(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ShopInfoExcel::VT_SHOPUPDATEGROUPID3, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ShopUpdateGroupId4(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ShopInfoExcel::VT_SHOPUPDATEGROUPID4, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ShopUpdateGroupId5(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ShopInfoExcel::VT_SHOPUPDATEGROUPID5, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ShopUpdateGroupId6(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ShopInfoExcel::VT_SHOPUPDATEGROUPID6, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ShopUpdateGroupId7(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ShopInfoExcel::VT_SHOPUPDATEGROUPID7, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ShopUpdateGroupId8(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ShopInfoExcel::VT_SHOPUPDATEGROUPID8, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ShopUpdateGroupId9(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ShopInfoExcel::VT_SHOPUPDATEGROUPID9, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ShopUpdateGroupId10(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ShopInfoExcel::VT_SHOPUPDATEGROUPID10, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ShopUpdateGroupId11(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ShopInfoExcel::VT_SHOPUPDATEGROUPID11, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ShopUpdateGroupId12(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ShopInfoExcel::VT_SHOPUPDATEGROUPID12, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ShopInfoExcel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ShopCategoryType>("CategoryType", Self::VT_CATEGORYTYPE, false)?
     .visit_field::<bool>("IsRefresh", Self::VT_ISREFRESH, false)?
     .visit_field::<bool>("IsSoldOutDimmed", Self::VT_ISSOLDOUTDIMMED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, ParcelType>>>("CostParcelType", Self::VT_COSTPARCELTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("CostParcelId", Self::VT_COSTPARCELID, false)?
     .visit_field::<i64>("AutoRefreshCoolTime", Self::VT_AUTOREFRESHCOOLTIME, false)?
     .visit_field::<ShopRefresherType>("ShopRefresherType", Self::VT_SHOPREFRESHERTYPE, false)?
     .visit_field::<ShopRefreshPeriodType>("ShopRefreshPeriodType", Self::VT_SHOPREFRESHPERIODTYPE, false)?
     .visit_field::<i64>("RefreshAbleCount", Self::VT_REFRESHABLECOUNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("GoodsId", Self::VT_GOODSID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OpenPeriodFrom", Self::VT_OPENPERIODFROM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OpenPeriodTo", Self::VT_OPENPERIODTO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("RefreshPeriodBaseTime", Self::VT_REFRESHPERIODBASETIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ShopProductUpdateTime", Self::VT_SHOPPRODUCTUPDATETIME, false)?
     .visit_field::<ParcelType>("DisplayParcelType", Self::VT_DISPLAYPARCELTYPE, false)?
     .visit_field::<i64>("DisplayParcelId", Self::VT_DISPLAYPARCELID, false)?
     .visit_field::<bool>("IsShopVisible", Self::VT_ISSHOPVISIBLE, false)?
     .visit_field::<i32>("DisplayOrder", Self::VT_DISPLAYORDER, false)?
     .visit_field::<i32>("ShopUpdateDate", Self::VT_SHOPUPDATEDATE, false)?
     .visit_field::<i32>("ShopUpdateGroupId1", Self::VT_SHOPUPDATEGROUPID1, false)?
     .visit_field::<i32>("ShopUpdateGroupId2", Self::VT_SHOPUPDATEGROUPID2, false)?
     .visit_field::<i32>("ShopUpdateGroupId3", Self::VT_SHOPUPDATEGROUPID3, false)?
     .visit_field::<i32>("ShopUpdateGroupId4", Self::VT_SHOPUPDATEGROUPID4, false)?
     .visit_field::<i32>("ShopUpdateGroupId5", Self::VT_SHOPUPDATEGROUPID5, false)?
     .visit_field::<i32>("ShopUpdateGroupId6", Self::VT_SHOPUPDATEGROUPID6, false)?
     .visit_field::<i32>("ShopUpdateGroupId7", Self::VT_SHOPUPDATEGROUPID7, false)?
     .visit_field::<i32>("ShopUpdateGroupId8", Self::VT_SHOPUPDATEGROUPID8, false)?
     .visit_field::<i32>("ShopUpdateGroupId9", Self::VT_SHOPUPDATEGROUPID9, false)?
     .visit_field::<i32>("ShopUpdateGroupId10", Self::VT_SHOPUPDATEGROUPID10, false)?
     .visit_field::<i32>("ShopUpdateGroupId11", Self::VT_SHOPUPDATEGROUPID11, false)?
     .visit_field::<i32>("ShopUpdateGroupId12", Self::VT_SHOPUPDATEGROUPID12, false)?
     .finish();
    Ok(())
  }
}
pub struct ShopInfoExcelArgs<'a> {
    pub CategoryType: ShopCategoryType,
    pub IsRefresh: bool,
    pub IsSoldOutDimmed: bool,
    pub CostParcelType: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, ParcelType>>>,
    pub CostParcelId: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub AutoRefreshCoolTime: i64,
    pub ShopRefresherType: ShopRefresherType,
    pub ShopRefreshPeriodType: ShopRefreshPeriodType,
    pub RefreshAbleCount: i64,
    pub GoodsId: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub OpenPeriodFrom: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OpenPeriodTo: Option<flatbuffers::WIPOffset<&'a str>>,
    pub RefreshPeriodBaseTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ShopProductUpdateTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DisplayParcelType: ParcelType,
    pub DisplayParcelId: i64,
    pub IsShopVisible: bool,
    pub DisplayOrder: i32,
    pub ShopUpdateDate: i32,
    pub ShopUpdateGroupId1: i32,
    pub ShopUpdateGroupId2: i32,
    pub ShopUpdateGroupId3: i32,
    pub ShopUpdateGroupId4: i32,
    pub ShopUpdateGroupId5: i32,
    pub ShopUpdateGroupId6: i32,
    pub ShopUpdateGroupId7: i32,
    pub ShopUpdateGroupId8: i32,
    pub ShopUpdateGroupId9: i32,
    pub ShopUpdateGroupId10: i32,
    pub ShopUpdateGroupId11: i32,
    pub ShopUpdateGroupId12: i32,
}
impl<'a> Default for ShopInfoExcelArgs<'a> {
  #[inline]
  fn default() -> Self {
    ShopInfoExcelArgs {
      CategoryType: ShopCategoryType::General,
      IsRefresh: false,
      IsSoldOutDimmed: false,
      CostParcelType: None,
      CostParcelId: None,
      AutoRefreshCoolTime: 0,
      ShopRefresherType: ShopRefresherType::None,
      ShopRefreshPeriodType: ShopRefreshPeriodType::None,
      RefreshAbleCount: 0,
      GoodsId: None,
      OpenPeriodFrom: None,
      OpenPeriodTo: None,
      RefreshPeriodBaseTime: None,
      ShopProductUpdateTime: None,
      DisplayParcelType: ParcelType::None,
      DisplayParcelId: 0,
      IsShopVisible: false,
      DisplayOrder: 0,
      ShopUpdateDate: 0,
      ShopUpdateGroupId1: 0,
      ShopUpdateGroupId2: 0,
      ShopUpdateGroupId3: 0,
      ShopUpdateGroupId4: 0,
      ShopUpdateGroupId5: 0,
      ShopUpdateGroupId6: 0,
      ShopUpdateGroupId7: 0,
      ShopUpdateGroupId8: 0,
      ShopUpdateGroupId9: 0,
      ShopUpdateGroupId10: 0,
      ShopUpdateGroupId11: 0,
      ShopUpdateGroupId12: 0,
    }
  }
}

impl Serialize for ShopInfoExcel<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("ShopInfoExcel", 31)?;
      s.serialize_field("CategoryType", &self.CategoryType())?;
      s.serialize_field("IsRefresh", &self.IsRefresh())?;
      s.serialize_field("IsSoldOutDimmed", &self.IsSoldOutDimmed())?;
      if let Some(f) = self.CostParcelType() {
        s.serialize_field("CostParcelType", &f)?;
      } else {
        s.skip_field("CostParcelType")?;
      }
      if let Some(f) = self.CostParcelId() {
        s.serialize_field("CostParcelId", &f)?;
      } else {
        s.skip_field("CostParcelId")?;
      }
      s.serialize_field("AutoRefreshCoolTime", &self.AutoRefreshCoolTime())?;
      s.serialize_field("ShopRefresherType", &self.ShopRefresherType())?;
      s.serialize_field("ShopRefreshPeriodType", &self.ShopRefreshPeriodType())?;
      s.serialize_field("RefreshAbleCount", &self.RefreshAbleCount())?;
      if let Some(f) = self.GoodsId() {
        s.serialize_field("GoodsId", &f)?;
      } else {
        s.skip_field("GoodsId")?;
      }
      if let Some(f) = self.OpenPeriodFrom() {
        s.serialize_field("OpenPeriodFrom", &f)?;
      } else {
        s.skip_field("OpenPeriodFrom")?;
      }
      if let Some(f) = self.OpenPeriodTo() {
        s.serialize_field("OpenPeriodTo", &f)?;
      } else {
        s.skip_field("OpenPeriodTo")?;
      }
      if let Some(f) = self.RefreshPeriodBaseTime() {
        s.serialize_field("RefreshPeriodBaseTime", &f)?;
      } else {
        s.skip_field("RefreshPeriodBaseTime")?;
      }
      if let Some(f) = self.ShopProductUpdateTime() {
        s.serialize_field("ShopProductUpdateTime", &f)?;
      } else {
        s.skip_field("ShopProductUpdateTime")?;
      }
      s.serialize_field("DisplayParcelType", &self.DisplayParcelType())?;
      s.serialize_field("DisplayParcelId", &self.DisplayParcelId())?;
      s.serialize_field("IsShopVisible", &self.IsShopVisible())?;
      s.serialize_field("DisplayOrder", &self.DisplayOrder())?;
      s.serialize_field("ShopUpdateDate", &self.ShopUpdateDate())?;
      s.serialize_field("ShopUpdateGroupId1", &self.ShopUpdateGroupId1())?;
      s.serialize_field("ShopUpdateGroupId2", &self.ShopUpdateGroupId2())?;
      s.serialize_field("ShopUpdateGroupId3", &self.ShopUpdateGroupId3())?;
      s.serialize_field("ShopUpdateGroupId4", &self.ShopUpdateGroupId4())?;
      s.serialize_field("ShopUpdateGroupId5", &self.ShopUpdateGroupId5())?;
      s.serialize_field("ShopUpdateGroupId6", &self.ShopUpdateGroupId6())?;
      s.serialize_field("ShopUpdateGroupId7", &self.ShopUpdateGroupId7())?;
      s.serialize_field("ShopUpdateGroupId8", &self.ShopUpdateGroupId8())?;
      s.serialize_field("ShopUpdateGroupId9", &self.ShopUpdateGroupId9())?;
      s.serialize_field("ShopUpdateGroupId10", &self.ShopUpdateGroupId10())?;
      s.serialize_field("ShopUpdateGroupId11", &self.ShopUpdateGroupId11())?;
      s.serialize_field("ShopUpdateGroupId12", &self.ShopUpdateGroupId12())?;
    s.end()
  }
}

pub struct ShopInfoExcelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ShopInfoExcelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_CategoryType(&mut self, CategoryType: ShopCategoryType) {
    self.fbb_.push_slot::<ShopCategoryType>(ShopInfoExcel::VT_CATEGORYTYPE, CategoryType, ShopCategoryType::General);
  }
  #[inline]
  pub fn add_IsRefresh(&mut self, IsRefresh: bool) {
    self.fbb_.push_slot::<bool>(ShopInfoExcel::VT_ISREFRESH, IsRefresh, false);
  }
  #[inline]
  pub fn add_IsSoldOutDimmed(&mut self, IsSoldOutDimmed: bool) {
    self.fbb_.push_slot::<bool>(ShopInfoExcel::VT_ISSOLDOUTDIMMED, IsSoldOutDimmed, false);
  }
  #[inline]
  pub fn add_CostParcelType(&mut self, CostParcelType: flatbuffers::WIPOffset<flatbuffers::Vector<'b , ParcelType>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ShopInfoExcel::VT_COSTPARCELTYPE, CostParcelType);
  }
  #[inline]
  pub fn add_CostParcelId(&mut self, CostParcelId: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ShopInfoExcel::VT_COSTPARCELID, CostParcelId);
  }
  #[inline]
  pub fn add_AutoRefreshCoolTime(&mut self, AutoRefreshCoolTime: i64) {
    self.fbb_.push_slot::<i64>(ShopInfoExcel::VT_AUTOREFRESHCOOLTIME, AutoRefreshCoolTime, 0);
  }
  #[inline]
  pub fn add_ShopRefresherType(&mut self, ShopRefresherType: ShopRefresherType) {
    self.fbb_.push_slot::<ShopRefresherType>(ShopInfoExcel::VT_SHOPREFRESHERTYPE, ShopRefresherType, ShopRefresherType::None);
  }
  #[inline]
  pub fn add_ShopRefreshPeriodType(&mut self, ShopRefreshPeriodType: ShopRefreshPeriodType) {
    self.fbb_.push_slot::<ShopRefreshPeriodType>(ShopInfoExcel::VT_SHOPREFRESHPERIODTYPE, ShopRefreshPeriodType, ShopRefreshPeriodType::None);
  }
  #[inline]
  pub fn add_RefreshAbleCount(&mut self, RefreshAbleCount: i64) {
    self.fbb_.push_slot::<i64>(ShopInfoExcel::VT_REFRESHABLECOUNT, RefreshAbleCount, 0);
  }
  #[inline]
  pub fn add_GoodsId(&mut self, GoodsId: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ShopInfoExcel::VT_GOODSID, GoodsId);
  }
  #[inline]
  pub fn add_OpenPeriodFrom(&mut self, OpenPeriodFrom: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ShopInfoExcel::VT_OPENPERIODFROM, OpenPeriodFrom);
  }
  #[inline]
  pub fn add_OpenPeriodTo(&mut self, OpenPeriodTo: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ShopInfoExcel::VT_OPENPERIODTO, OpenPeriodTo);
  }
  #[inline]
  pub fn add_RefreshPeriodBaseTime(&mut self, RefreshPeriodBaseTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ShopInfoExcel::VT_REFRESHPERIODBASETIME, RefreshPeriodBaseTime);
  }
  #[inline]
  pub fn add_ShopProductUpdateTime(&mut self, ShopProductUpdateTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ShopInfoExcel::VT_SHOPPRODUCTUPDATETIME, ShopProductUpdateTime);
  }
  #[inline]
  pub fn add_DisplayParcelType(&mut self, DisplayParcelType: ParcelType) {
    self.fbb_.push_slot::<ParcelType>(ShopInfoExcel::VT_DISPLAYPARCELTYPE, DisplayParcelType, ParcelType::None);
  }
  #[inline]
  pub fn add_DisplayParcelId(&mut self, DisplayParcelId: i64) {
    self.fbb_.push_slot::<i64>(ShopInfoExcel::VT_DISPLAYPARCELID, DisplayParcelId, 0);
  }
  #[inline]
  pub fn add_IsShopVisible(&mut self, IsShopVisible: bool) {
    self.fbb_.push_slot::<bool>(ShopInfoExcel::VT_ISSHOPVISIBLE, IsShopVisible, false);
  }
  #[inline]
  pub fn add_DisplayOrder(&mut self, DisplayOrder: i32) {
    self.fbb_.push_slot::<i32>(ShopInfoExcel::VT_DISPLAYORDER, DisplayOrder, 0);
  }
  #[inline]
  pub fn add_ShopUpdateDate(&mut self, ShopUpdateDate: i32) {
    self.fbb_.push_slot::<i32>(ShopInfoExcel::VT_SHOPUPDATEDATE, ShopUpdateDate, 0);
  }
  #[inline]
  pub fn add_ShopUpdateGroupId1(&mut self, ShopUpdateGroupId1: i32) {
    self.fbb_.push_slot::<i32>(ShopInfoExcel::VT_SHOPUPDATEGROUPID1, ShopUpdateGroupId1, 0);
  }
  #[inline]
  pub fn add_ShopUpdateGroupId2(&mut self, ShopUpdateGroupId2: i32) {
    self.fbb_.push_slot::<i32>(ShopInfoExcel::VT_SHOPUPDATEGROUPID2, ShopUpdateGroupId2, 0);
  }
  #[inline]
  pub fn add_ShopUpdateGroupId3(&mut self, ShopUpdateGroupId3: i32) {
    self.fbb_.push_slot::<i32>(ShopInfoExcel::VT_SHOPUPDATEGROUPID3, ShopUpdateGroupId3, 0);
  }
  #[inline]
  pub fn add_ShopUpdateGroupId4(&mut self, ShopUpdateGroupId4: i32) {
    self.fbb_.push_slot::<i32>(ShopInfoExcel::VT_SHOPUPDATEGROUPID4, ShopUpdateGroupId4, 0);
  }
  #[inline]
  pub fn add_ShopUpdateGroupId5(&mut self, ShopUpdateGroupId5: i32) {
    self.fbb_.push_slot::<i32>(ShopInfoExcel::VT_SHOPUPDATEGROUPID5, ShopUpdateGroupId5, 0);
  }
  #[inline]
  pub fn add_ShopUpdateGroupId6(&mut self, ShopUpdateGroupId6: i32) {
    self.fbb_.push_slot::<i32>(ShopInfoExcel::VT_SHOPUPDATEGROUPID6, ShopUpdateGroupId6, 0);
  }
  #[inline]
  pub fn add_ShopUpdateGroupId7(&mut self, ShopUpdateGroupId7: i32) {
    self.fbb_.push_slot::<i32>(ShopInfoExcel::VT_SHOPUPDATEGROUPID7, ShopUpdateGroupId7, 0);
  }
  #[inline]
  pub fn add_ShopUpdateGroupId8(&mut self, ShopUpdateGroupId8: i32) {
    self.fbb_.push_slot::<i32>(ShopInfoExcel::VT_SHOPUPDATEGROUPID8, ShopUpdateGroupId8, 0);
  }
  #[inline]
  pub fn add_ShopUpdateGroupId9(&mut self, ShopUpdateGroupId9: i32) {
    self.fbb_.push_slot::<i32>(ShopInfoExcel::VT_SHOPUPDATEGROUPID9, ShopUpdateGroupId9, 0);
  }
  #[inline]
  pub fn add_ShopUpdateGroupId10(&mut self, ShopUpdateGroupId10: i32) {
    self.fbb_.push_slot::<i32>(ShopInfoExcel::VT_SHOPUPDATEGROUPID10, ShopUpdateGroupId10, 0);
  }
  #[inline]
  pub fn add_ShopUpdateGroupId11(&mut self, ShopUpdateGroupId11: i32) {
    self.fbb_.push_slot::<i32>(ShopInfoExcel::VT_SHOPUPDATEGROUPID11, ShopUpdateGroupId11, 0);
  }
  #[inline]
  pub fn add_ShopUpdateGroupId12(&mut self, ShopUpdateGroupId12: i32) {
    self.fbb_.push_slot::<i32>(ShopInfoExcel::VT_SHOPUPDATEGROUPID12, ShopUpdateGroupId12, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ShopInfoExcelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ShopInfoExcelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ShopInfoExcel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ShopInfoExcel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ShopInfoExcel");
      ds.field("CategoryType", &self.CategoryType());
      ds.field("IsRefresh", &self.IsRefresh());
      ds.field("IsSoldOutDimmed", &self.IsSoldOutDimmed());
      ds.field("CostParcelType", &self.CostParcelType());
      ds.field("CostParcelId", &self.CostParcelId());
      ds.field("AutoRefreshCoolTime", &self.AutoRefreshCoolTime());
      ds.field("ShopRefresherType", &self.ShopRefresherType());
      ds.field("ShopRefreshPeriodType", &self.ShopRefreshPeriodType());
      ds.field("RefreshAbleCount", &self.RefreshAbleCount());
      ds.field("GoodsId", &self.GoodsId());
      ds.field("OpenPeriodFrom", &self.OpenPeriodFrom());
      ds.field("OpenPeriodTo", &self.OpenPeriodTo());
      ds.field("RefreshPeriodBaseTime", &self.RefreshPeriodBaseTime());
      ds.field("ShopProductUpdateTime", &self.ShopProductUpdateTime());
      ds.field("DisplayParcelType", &self.DisplayParcelType());
      ds.field("DisplayParcelId", &self.DisplayParcelId());
      ds.field("IsShopVisible", &self.IsShopVisible());
      ds.field("DisplayOrder", &self.DisplayOrder());
      ds.field("ShopUpdateDate", &self.ShopUpdateDate());
      ds.field("ShopUpdateGroupId1", &self.ShopUpdateGroupId1());
      ds.field("ShopUpdateGroupId2", &self.ShopUpdateGroupId2());
      ds.field("ShopUpdateGroupId3", &self.ShopUpdateGroupId3());
      ds.field("ShopUpdateGroupId4", &self.ShopUpdateGroupId4());
      ds.field("ShopUpdateGroupId5", &self.ShopUpdateGroupId5());
      ds.field("ShopUpdateGroupId6", &self.ShopUpdateGroupId6());
      ds.field("ShopUpdateGroupId7", &self.ShopUpdateGroupId7());
      ds.field("ShopUpdateGroupId8", &self.ShopUpdateGroupId8());
      ds.field("ShopUpdateGroupId9", &self.ShopUpdateGroupId9());
      ds.field("ShopUpdateGroupId10", &self.ShopUpdateGroupId10());
      ds.field("ShopUpdateGroupId11", &self.ShopUpdateGroupId11());
      ds.field("ShopUpdateGroupId12", &self.ShopUpdateGroupId12());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ShopInfoExcelT {
  pub CategoryType: ShopCategoryType,
  pub IsRefresh: bool,
  pub IsSoldOutDimmed: bool,
  pub CostParcelType: Option<Vec<ParcelType>>,
  pub CostParcelId: Option<Vec<i64>>,
  pub AutoRefreshCoolTime: i64,
  pub ShopRefresherType: ShopRefresherType,
  pub ShopRefreshPeriodType: ShopRefreshPeriodType,
  pub RefreshAbleCount: i64,
  pub GoodsId: Option<Vec<i64>>,
  pub OpenPeriodFrom: Option<String>,
  pub OpenPeriodTo: Option<String>,
  pub RefreshPeriodBaseTime: Option<String>,
  pub ShopProductUpdateTime: Option<String>,
  pub DisplayParcelType: ParcelType,
  pub DisplayParcelId: i64,
  pub IsShopVisible: bool,
  pub DisplayOrder: i32,
  pub ShopUpdateDate: i32,
  pub ShopUpdateGroupId1: i32,
  pub ShopUpdateGroupId2: i32,
  pub ShopUpdateGroupId3: i32,
  pub ShopUpdateGroupId4: i32,
  pub ShopUpdateGroupId5: i32,
  pub ShopUpdateGroupId6: i32,
  pub ShopUpdateGroupId7: i32,
  pub ShopUpdateGroupId8: i32,
  pub ShopUpdateGroupId9: i32,
  pub ShopUpdateGroupId10: i32,
  pub ShopUpdateGroupId11: i32,
  pub ShopUpdateGroupId12: i32,
}
impl Default for ShopInfoExcelT {
  fn default() -> Self {
    Self {
      CategoryType: ShopCategoryType::General,
      IsRefresh: false,
      IsSoldOutDimmed: false,
      CostParcelType: None,
      CostParcelId: None,
      AutoRefreshCoolTime: 0,
      ShopRefresherType: ShopRefresherType::None,
      ShopRefreshPeriodType: ShopRefreshPeriodType::None,
      RefreshAbleCount: 0,
      GoodsId: None,
      OpenPeriodFrom: None,
      OpenPeriodTo: None,
      RefreshPeriodBaseTime: None,
      ShopProductUpdateTime: None,
      DisplayParcelType: ParcelType::None,
      DisplayParcelId: 0,
      IsShopVisible: false,
      DisplayOrder: 0,
      ShopUpdateDate: 0,
      ShopUpdateGroupId1: 0,
      ShopUpdateGroupId2: 0,
      ShopUpdateGroupId3: 0,
      ShopUpdateGroupId4: 0,
      ShopUpdateGroupId5: 0,
      ShopUpdateGroupId6: 0,
      ShopUpdateGroupId7: 0,
      ShopUpdateGroupId8: 0,
      ShopUpdateGroupId9: 0,
      ShopUpdateGroupId10: 0,
      ShopUpdateGroupId11: 0,
      ShopUpdateGroupId12: 0,
    }
  }
}
impl ShopInfoExcelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ShopInfoExcel<'b>> {
    let CategoryType = self.CategoryType;
    let IsRefresh = self.IsRefresh;
    let IsSoldOutDimmed = self.IsSoldOutDimmed;
    let CostParcelType = self.CostParcelType.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let CostParcelId = self.CostParcelId.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let AutoRefreshCoolTime = self.AutoRefreshCoolTime;
    let ShopRefresherType = self.ShopRefresherType;
    let ShopRefreshPeriodType = self.ShopRefreshPeriodType;
    let RefreshAbleCount = self.RefreshAbleCount;
    let GoodsId = self.GoodsId.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let OpenPeriodFrom = self.OpenPeriodFrom.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OpenPeriodTo = self.OpenPeriodTo.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let RefreshPeriodBaseTime = self.RefreshPeriodBaseTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ShopProductUpdateTime = self.ShopProductUpdateTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DisplayParcelType = self.DisplayParcelType;
    let DisplayParcelId = self.DisplayParcelId;
    let IsShopVisible = self.IsShopVisible;
    let DisplayOrder = self.DisplayOrder;
    let ShopUpdateDate = self.ShopUpdateDate;
    let ShopUpdateGroupId1 = self.ShopUpdateGroupId1;
    let ShopUpdateGroupId2 = self.ShopUpdateGroupId2;
    let ShopUpdateGroupId3 = self.ShopUpdateGroupId3;
    let ShopUpdateGroupId4 = self.ShopUpdateGroupId4;
    let ShopUpdateGroupId5 = self.ShopUpdateGroupId5;
    let ShopUpdateGroupId6 = self.ShopUpdateGroupId6;
    let ShopUpdateGroupId7 = self.ShopUpdateGroupId7;
    let ShopUpdateGroupId8 = self.ShopUpdateGroupId8;
    let ShopUpdateGroupId9 = self.ShopUpdateGroupId9;
    let ShopUpdateGroupId10 = self.ShopUpdateGroupId10;
    let ShopUpdateGroupId11 = self.ShopUpdateGroupId11;
    let ShopUpdateGroupId12 = self.ShopUpdateGroupId12;
    ShopInfoExcel::create(_fbb, &ShopInfoExcelArgs{
      CategoryType,
      IsRefresh,
      IsSoldOutDimmed,
      CostParcelType,
      CostParcelId,
      AutoRefreshCoolTime,
      ShopRefresherType,
      ShopRefreshPeriodType,
      RefreshAbleCount,
      GoodsId,
      OpenPeriodFrom,
      OpenPeriodTo,
      RefreshPeriodBaseTime,
      ShopProductUpdateTime,
      DisplayParcelType,
      DisplayParcelId,
      IsShopVisible,
      DisplayOrder,
      ShopUpdateDate,
      ShopUpdateGroupId1,
      ShopUpdateGroupId2,
      ShopUpdateGroupId3,
      ShopUpdateGroupId4,
      ShopUpdateGroupId5,
      ShopUpdateGroupId6,
      ShopUpdateGroupId7,
      ShopUpdateGroupId8,
      ShopUpdateGroupId9,
      ShopUpdateGroupId10,
      ShopUpdateGroupId11,
      ShopUpdateGroupId12,
    })
  }
}
