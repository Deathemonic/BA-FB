// automatically generated by the FlatBuffers compiler, do not modify
// @generated
#![allow(unused_imports, dead_code)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum CostumeExcelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CostumeExcel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CostumeExcel<'a> {
  type Inner = CostumeExcel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CostumeExcel<'a> {
  pub const VT_COSTUMEGROUPID: flatbuffers::VOffsetT = 4;
  pub const VT_COSTUMEUNIQUEID: flatbuffers::VOffsetT = 6;
  pub const VT_DEVNAME: flatbuffers::VOffsetT = 8;
  pub const VT_PRODUCTIONSTEP: flatbuffers::VOffsetT = 10;
  pub const VT_ISDEFAULT: flatbuffers::VOffsetT = 12;
  pub const VT_COLLECTIONVISIBLE: flatbuffers::VOffsetT = 14;
  pub const VT_RELEASEDATE: flatbuffers::VOffsetT = 16;
  pub const VT_COLLECTIONVISIBLESTARTDATE: flatbuffers::VOffsetT = 18;
  pub const VT_COLLECTIONVISIBLEENDDATE: flatbuffers::VOffsetT = 20;
  pub const VT_RARITY: flatbuffers::VOffsetT = 22;
  pub const VT_CHARACTERSKILLLISTGROUPID: flatbuffers::VOffsetT = 24;
  pub const VT_SPINERESOURCENAME: flatbuffers::VOffsetT = 26;
  pub const VT_SPINERESOURCENAMEDIORAMA: flatbuffers::VOffsetT = 28;
  pub const VT_SPINERESOURCENAMEDIORAMAFORFORMCONVERSION: flatbuffers::VOffsetT = 30;
  pub const VT_ENTITYMATERIALTYPE: flatbuffers::VOffsetT = 32;
  pub const VT_MODELPREFABNAME: flatbuffers::VOffsetT = 34;
  pub const VT_ANIMATORNAME: flatbuffers::VOffsetT = 36;
  pub const VT_CAFEMODELPREFABNAME: flatbuffers::VOffsetT = 38;
  pub const VT_ECHELONMODELPREFABNAME: flatbuffers::VOffsetT = 40;
  pub const VT_STRATEGYMODELPREFABNAME: flatbuffers::VOffsetT = 42;
  pub const VT_TEXTUREDIR: flatbuffers::VOffsetT = 44;
  pub const VT_COLLECTIONTEXTUREPATH: flatbuffers::VOffsetT = 46;
  pub const VT_COLLECTIONBGTEXTUREPATH: flatbuffers::VOffsetT = 48;
  pub const VT_COMBATSTYLETEXTUREPATH: flatbuffers::VOffsetT = 50;
  pub const VT_USEOBJECTHPBAR: flatbuffers::VOffsetT = 52;
  pub const VT_TEXTUREBOSS: flatbuffers::VOffsetT = 54;
  pub const VT_TEXTURESKILLCARD: flatbuffers::VOffsetT = 56;
  pub const VT_INFORMATIONPACEL: flatbuffers::VOffsetT = 58;
  pub const VT_ANIMATIONSSR: flatbuffers::VOffsetT = 60;
  pub const VT_ENTERSTRATEGYANIMATIONNAME: flatbuffers::VOffsetT = 62;
  pub const VT_ANIMATIONVALIDATOR: flatbuffers::VOffsetT = 64;
  pub const VT_CHARACTERVOICEGROUPID: flatbuffers::VOffsetT = 66;
  pub const VT_SHOWOBJECTHPSTATUS: flatbuffers::VOffsetT = 68;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CostumeExcel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CostumeExcelArgs<'args>
  ) -> flatbuffers::WIPOffset<CostumeExcel<'bldr>> {
    let mut builder = CostumeExcelBuilder::new(_fbb);
    let key = table_encryption_service::create_key(b"Costume");
      let x = args.CharacterVoiceGroupId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_CharacterVoiceGroupId(x);
      let x = args.CharacterSkillListGroupId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_CharacterSkillListGroupId(x);
      let x = args.CostumeUniqueId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_CostumeUniqueId(x);
      let x = args.CostumeGroupId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_CostumeGroupId(x);
      if let Some(x) = args.EnterStrategyAnimationName {
        builder.add_EnterStrategyAnimationName(x);
      }
      if let Some(x) = args.AnimationSSR {
        builder.add_AnimationSSR(x);
      }
      if let Some(x) = args.InformationPacel {
        builder.add_InformationPacel(x);
      }
      if let Some(x) = args.textureSkillCard {
        builder.add_textureSkillCard(x);
      }
      if let Some(x) = args.TextureBoss {
        builder.add_TextureBoss(x);
      }
      if let Some(x) = args.CombatStyleTexturePath {
        builder.add_CombatStyleTexturePath(x);
      }
      if let Some(x) = args.CollectionBGTexturePath {
        builder.add_CollectionBGTexturePath(x);
      }
      if let Some(x) = args.CollectionTexturePath {
        builder.add_CollectionTexturePath(x);
      }
      if let Some(x) = args.TextureDir {
        builder.add_TextureDir(x);
      }
      if let Some(x) = args.StrategyModelPrefabName {
        builder.add_StrategyModelPrefabName(x);
      }
      if let Some(x) = args.EchelonModelPrefabName {
        builder.add_EchelonModelPrefabName(x);
      }
      if let Some(x) = args.CafeModelPrefabName {
        builder.add_CafeModelPrefabName(x);
      }
      if let Some(x) = args.AnimatorName {
        builder.add_AnimatorName(x);
      }
      if let Some(x) = args.ModelPrefabName {
        builder.add_ModelPrefabName(x);
      }
      let x = args.EntityMaterialType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_EntityMaterialType(x);
      if let Some(x) = args.spineResourceNameDioramaForFormConversion {
        builder.add_spineResourceNameDioramaForFormConversion(x);
      }
      if let Some(x) = args.SpineResourceNameDiorama {
        builder.add_SpineResourceNameDiorama(x);
      }
      if let Some(x) = args.SpineResourceName {
        builder.add_SpineResourceName(x);
      }
      let x = args.Rarity;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_Rarity(x);
      if let Some(x) = args.CollectionVisibleEndDate {
        builder.add_CollectionVisibleEndDate(x);
      }
      if let Some(x) = args.CollectionVisibleStartDate {
        builder.add_CollectionVisibleStartDate(x);
      }
      if let Some(x) = args.ReleaseDate {
        builder.add_ReleaseDate(x);
      }
      let x = args.ProductionStep;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_ProductionStep(x);
      if let Some(x) = args.DevName {
        builder.add_DevName(x);
      }
      builder.add_ShowObjectHpStatus(args.ShowObjectHpStatus);
      builder.add_AnimationValidator(args.AnimationValidator);
      builder.add_UseObjectHPBAR(args.UseObjectHPBAR);
      builder.add_CollectionVisible(args.CollectionVisible);
      builder.add_IsDefault(args.IsDefault);
    builder.finish()
  }

  pub fn unpack(&self) -> CostumeExcelT {
    let key = table_encryption_service::create_key(b"Costume");
      let CostumeGroupId = self.CostumeGroupId();
      let CostumeUniqueId = self.CostumeUniqueId();
    let DevName = self.DevName().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let ProductionStep = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.ProductionStep(), &key)
      } else {
        self.ProductionStep()
      };
      let IsDefault = self.IsDefault();
      let CollectionVisible = self.CollectionVisible();
    let ReleaseDate = self.ReleaseDate().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let CollectionVisibleStartDate = self.CollectionVisibleStartDate().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let CollectionVisibleEndDate = self.CollectionVisibleEndDate().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let Rarity = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.Rarity(), &key)
      } else {
        self.Rarity()
      };
      let CharacterSkillListGroupId = self.CharacterSkillListGroupId();
    let SpineResourceName = self.SpineResourceName().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let SpineResourceNameDiorama = self.SpineResourceNameDiorama().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let spineResourceNameDioramaForFormConversion = self.spineResourceNameDioramaForFormConversion().map(|x| {
      x.iter().map(|s| if table_encryption_service::use_encryption() { table_encryption_service::convert_string(s, &key).unwrap() } else { s.to_string() }).collect()
    });
      let EntityMaterialType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.EntityMaterialType(), &key)
      } else {
        self.EntityMaterialType()
      };
    let ModelPrefabName = self.ModelPrefabName().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let AnimatorName = self.AnimatorName().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let CafeModelPrefabName = self.CafeModelPrefabName().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let EchelonModelPrefabName = self.EchelonModelPrefabName().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let StrategyModelPrefabName = self.StrategyModelPrefabName().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let TextureDir = self.TextureDir().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let CollectionTexturePath = self.CollectionTexturePath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let CollectionBGTexturePath = self.CollectionBGTexturePath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let CombatStyleTexturePath = self.CombatStyleTexturePath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let UseObjectHPBAR = self.UseObjectHPBAR();
    let TextureBoss = self.TextureBoss().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let textureSkillCard = self.textureSkillCard().map(|x| {
      x.iter().map(|s| if table_encryption_service::use_encryption() { table_encryption_service::convert_string(s, &key).unwrap() } else { s.to_string() }).collect()
    });
    let InformationPacel = self.InformationPacel().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let AnimationSSR = self.AnimationSSR().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let EnterStrategyAnimationName = self.EnterStrategyAnimationName().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let AnimationValidator = self.AnimationValidator();
      let CharacterVoiceGroupId = self.CharacterVoiceGroupId();
      let ShowObjectHpStatus = self.ShowObjectHpStatus();
    CostumeExcelT {
      CostumeGroupId,
      CostumeUniqueId,
      DevName,
      ProductionStep,
      IsDefault,
      CollectionVisible,
      ReleaseDate,
      CollectionVisibleStartDate,
      CollectionVisibleEndDate,
      Rarity,
      CharacterSkillListGroupId,
      SpineResourceName,
      SpineResourceNameDiorama,
      spineResourceNameDioramaForFormConversion,
      EntityMaterialType,
      ModelPrefabName,
      AnimatorName,
      CafeModelPrefabName,
      EchelonModelPrefabName,
      StrategyModelPrefabName,
      TextureDir,
      CollectionTexturePath,
      CollectionBGTexturePath,
      CombatStyleTexturePath,
      UseObjectHPBAR,
      TextureBoss,
      textureSkillCard,
      InformationPacel,
      AnimationSSR,
      EnterStrategyAnimationName,
      AnimationValidator,
      CharacterVoiceGroupId,
      ShowObjectHpStatus,
    }
  }

  #[inline]
  pub fn CostumeGroupId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CostumeExcel::VT_COSTUMEGROUPID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CostumeUniqueId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CostumeExcel::VT_COSTUMEUNIQUEID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn DevName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CostumeExcel::VT_DEVNAME, None)}
  }
  #[inline]
  pub fn ProductionStep(&self) -> ProductionStep {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ProductionStep>(CostumeExcel::VT_PRODUCTIONSTEP, Some(ProductionStep::ToDo)).unwrap()}
  }
  #[inline]
  pub fn IsDefault(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CostumeExcel::VT_ISDEFAULT, Some(false)).unwrap()}
  }
  #[inline]
  pub fn CollectionVisible(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CostumeExcel::VT_COLLECTIONVISIBLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn ReleaseDate(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CostumeExcel::VT_RELEASEDATE, None)}
  }
  #[inline]
  pub fn CollectionVisibleStartDate(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CostumeExcel::VT_COLLECTIONVISIBLESTARTDATE, None)}
  }
  #[inline]
  pub fn CollectionVisibleEndDate(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CostumeExcel::VT_COLLECTIONVISIBLEENDDATE, None)}
  }
  #[inline]
  pub fn Rarity(&self) -> Rarity {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Rarity>(CostumeExcel::VT_RARITY, Some(Rarity::N)).unwrap()}
  }
  #[inline]
  pub fn CharacterSkillListGroupId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CostumeExcel::VT_CHARACTERSKILLLISTGROUPID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn SpineResourceName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CostumeExcel::VT_SPINERESOURCENAME, None)}
  }
  #[inline]
  pub fn SpineResourceNameDiorama(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CostumeExcel::VT_SPINERESOURCENAMEDIORAMA, None)}
  }
  #[inline]
  pub fn spineResourceNameDioramaForFormConversion(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(CostumeExcel::VT_SPINERESOURCENAMEDIORAMAFORFORMCONVERSION, None)}
  }
  #[inline]
  pub fn EntityMaterialType(&self) -> EntityMaterialType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<EntityMaterialType>(CostumeExcel::VT_ENTITYMATERIALTYPE, Some(EntityMaterialType::Wood)).unwrap()}
  }
  #[inline]
  pub fn ModelPrefabName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CostumeExcel::VT_MODELPREFABNAME, None)}
  }
  #[inline]
  pub fn AnimatorName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CostumeExcel::VT_ANIMATORNAME, None)}
  }
  #[inline]
  pub fn CafeModelPrefabName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CostumeExcel::VT_CAFEMODELPREFABNAME, None)}
  }
  #[inline]
  pub fn EchelonModelPrefabName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CostumeExcel::VT_ECHELONMODELPREFABNAME, None)}
  }
  #[inline]
  pub fn StrategyModelPrefabName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CostumeExcel::VT_STRATEGYMODELPREFABNAME, None)}
  }
  #[inline]
  pub fn TextureDir(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CostumeExcel::VT_TEXTUREDIR, None)}
  }
  #[inline]
  pub fn CollectionTexturePath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CostumeExcel::VT_COLLECTIONTEXTUREPATH, None)}
  }
  #[inline]
  pub fn CollectionBGTexturePath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CostumeExcel::VT_COLLECTIONBGTEXTUREPATH, None)}
  }
  #[inline]
  pub fn CombatStyleTexturePath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CostumeExcel::VT_COMBATSTYLETEXTUREPATH, None)}
  }
  #[inline]
  pub fn UseObjectHPBAR(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CostumeExcel::VT_USEOBJECTHPBAR, Some(false)).unwrap()}
  }
  #[inline]
  pub fn TextureBoss(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CostumeExcel::VT_TEXTUREBOSS, None)}
  }
  #[inline]
  pub fn textureSkillCard(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(CostumeExcel::VT_TEXTURESKILLCARD, None)}
  }
  #[inline]
  pub fn InformationPacel(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CostumeExcel::VT_INFORMATIONPACEL, None)}
  }
  #[inline]
  pub fn AnimationSSR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CostumeExcel::VT_ANIMATIONSSR, None)}
  }
  #[inline]
  pub fn EnterStrategyAnimationName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CostumeExcel::VT_ENTERSTRATEGYANIMATIONNAME, None)}
  }
  #[inline]
  pub fn AnimationValidator(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CostumeExcel::VT_ANIMATIONVALIDATOR, Some(false)).unwrap()}
  }
  #[inline]
  pub fn CharacterVoiceGroupId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CostumeExcel::VT_CHARACTERVOICEGROUPID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ShowObjectHpStatus(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CostumeExcel::VT_SHOWOBJECTHPSTATUS, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for CostumeExcel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("CostumeGroupId", Self::VT_COSTUMEGROUPID, false)?
     .visit_field::<i64>("CostumeUniqueId", Self::VT_COSTUMEUNIQUEID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DevName", Self::VT_DEVNAME, false)?
     .visit_field::<ProductionStep>("ProductionStep", Self::VT_PRODUCTIONSTEP, false)?
     .visit_field::<bool>("IsDefault", Self::VT_ISDEFAULT, false)?
     .visit_field::<bool>("CollectionVisible", Self::VT_COLLECTIONVISIBLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ReleaseDate", Self::VT_RELEASEDATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CollectionVisibleStartDate", Self::VT_COLLECTIONVISIBLESTARTDATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CollectionVisibleEndDate", Self::VT_COLLECTIONVISIBLEENDDATE, false)?
     .visit_field::<Rarity>("Rarity", Self::VT_RARITY, false)?
     .visit_field::<i64>("CharacterSkillListGroupId", Self::VT_CHARACTERSKILLLISTGROUPID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SpineResourceName", Self::VT_SPINERESOURCENAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SpineResourceNameDiorama", Self::VT_SPINERESOURCENAMEDIORAMA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("spineResourceNameDioramaForFormConversion", Self::VT_SPINERESOURCENAMEDIORAMAFORFORMCONVERSION, false)?
     .visit_field::<EntityMaterialType>("EntityMaterialType", Self::VT_ENTITYMATERIALTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ModelPrefabName", Self::VT_MODELPREFABNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("AnimatorName", Self::VT_ANIMATORNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CafeModelPrefabName", Self::VT_CAFEMODELPREFABNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EchelonModelPrefabName", Self::VT_ECHELONMODELPREFABNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("StrategyModelPrefabName", Self::VT_STRATEGYMODELPREFABNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TextureDir", Self::VT_TEXTUREDIR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CollectionTexturePath", Self::VT_COLLECTIONTEXTUREPATH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CollectionBGTexturePath", Self::VT_COLLECTIONBGTEXTUREPATH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CombatStyleTexturePath", Self::VT_COMBATSTYLETEXTUREPATH, false)?
     .visit_field::<bool>("UseObjectHPBAR", Self::VT_USEOBJECTHPBAR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TextureBoss", Self::VT_TEXTUREBOSS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("textureSkillCard", Self::VT_TEXTURESKILLCARD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("InformationPacel", Self::VT_INFORMATIONPACEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("AnimationSSR", Self::VT_ANIMATIONSSR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EnterStrategyAnimationName", Self::VT_ENTERSTRATEGYANIMATIONNAME, false)?
     .visit_field::<bool>("AnimationValidator", Self::VT_ANIMATIONVALIDATOR, false)?
     .visit_field::<i64>("CharacterVoiceGroupId", Self::VT_CHARACTERVOICEGROUPID, false)?
     .visit_field::<bool>("ShowObjectHpStatus", Self::VT_SHOWOBJECTHPSTATUS, false)?
     .finish();
    Ok(())
  }
}
pub struct CostumeExcelArgs<'a> {
    pub CostumeGroupId: i64,
    pub CostumeUniqueId: i64,
    pub DevName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ProductionStep: ProductionStep,
    pub IsDefault: bool,
    pub CollectionVisible: bool,
    pub ReleaseDate: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CollectionVisibleStartDate: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CollectionVisibleEndDate: Option<flatbuffers::WIPOffset<&'a str>>,
    pub Rarity: Rarity,
    pub CharacterSkillListGroupId: i64,
    pub SpineResourceName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SpineResourceNameDiorama: Option<flatbuffers::WIPOffset<&'a str>>,
    pub spineResourceNameDioramaForFormConversion: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub EntityMaterialType: EntityMaterialType,
    pub ModelPrefabName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub AnimatorName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CafeModelPrefabName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EchelonModelPrefabName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub StrategyModelPrefabName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TextureDir: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CollectionTexturePath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CollectionBGTexturePath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CombatStyleTexturePath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub UseObjectHPBAR: bool,
    pub TextureBoss: Option<flatbuffers::WIPOffset<&'a str>>,
    pub textureSkillCard: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub InformationPacel: Option<flatbuffers::WIPOffset<&'a str>>,
    pub AnimationSSR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EnterStrategyAnimationName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub AnimationValidator: bool,
    pub CharacterVoiceGroupId: i64,
    pub ShowObjectHpStatus: bool,
}
impl<'a> Default for CostumeExcelArgs<'a> {
  #[inline]
  fn default() -> Self {
    CostumeExcelArgs {
      CostumeGroupId: 0,
      CostumeUniqueId: 0,
      DevName: None,
      ProductionStep: ProductionStep::ToDo,
      IsDefault: false,
      CollectionVisible: false,
      ReleaseDate: None,
      CollectionVisibleStartDate: None,
      CollectionVisibleEndDate: None,
      Rarity: Rarity::N,
      CharacterSkillListGroupId: 0,
      SpineResourceName: None,
      SpineResourceNameDiorama: None,
      spineResourceNameDioramaForFormConversion: None,
      EntityMaterialType: EntityMaterialType::Wood,
      ModelPrefabName: None,
      AnimatorName: None,
      CafeModelPrefabName: None,
      EchelonModelPrefabName: None,
      StrategyModelPrefabName: None,
      TextureDir: None,
      CollectionTexturePath: None,
      CollectionBGTexturePath: None,
      CombatStyleTexturePath: None,
      UseObjectHPBAR: false,
      TextureBoss: None,
      textureSkillCard: None,
      InformationPacel: None,
      AnimationSSR: None,
      EnterStrategyAnimationName: None,
      AnimationValidator: false,
      CharacterVoiceGroupId: 0,
      ShowObjectHpStatus: false,
    }
  }
}

impl Serialize for CostumeExcel<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("CostumeExcel", 33)?;
      s.serialize_field("CostumeGroupId", &self.CostumeGroupId())?;
      s.serialize_field("CostumeUniqueId", &self.CostumeUniqueId())?;
      if let Some(f) = self.DevName() {
        s.serialize_field("DevName", &f)?;
      } else {
        s.skip_field("DevName")?;
      }
      s.serialize_field("ProductionStep", &self.ProductionStep())?;
      s.serialize_field("IsDefault", &self.IsDefault())?;
      s.serialize_field("CollectionVisible", &self.CollectionVisible())?;
      if let Some(f) = self.ReleaseDate() {
        s.serialize_field("ReleaseDate", &f)?;
      } else {
        s.skip_field("ReleaseDate")?;
      }
      if let Some(f) = self.CollectionVisibleStartDate() {
        s.serialize_field("CollectionVisibleStartDate", &f)?;
      } else {
        s.skip_field("CollectionVisibleStartDate")?;
      }
      if let Some(f) = self.CollectionVisibleEndDate() {
        s.serialize_field("CollectionVisibleEndDate", &f)?;
      } else {
        s.skip_field("CollectionVisibleEndDate")?;
      }
      s.serialize_field("Rarity", &self.Rarity())?;
      s.serialize_field("CharacterSkillListGroupId", &self.CharacterSkillListGroupId())?;
      if let Some(f) = self.SpineResourceName() {
        s.serialize_field("SpineResourceName", &f)?;
      } else {
        s.skip_field("SpineResourceName")?;
      }
      if let Some(f) = self.SpineResourceNameDiorama() {
        s.serialize_field("SpineResourceNameDiorama", &f)?;
      } else {
        s.skip_field("SpineResourceNameDiorama")?;
      }
      if let Some(f) = self.spineResourceNameDioramaForFormConversion() {
        s.serialize_field("spineResourceNameDioramaForFormConversion", &f)?;
      } else {
        s.skip_field("spineResourceNameDioramaForFormConversion")?;
      }
      s.serialize_field("EntityMaterialType", &self.EntityMaterialType())?;
      if let Some(f) = self.ModelPrefabName() {
        s.serialize_field("ModelPrefabName", &f)?;
      } else {
        s.skip_field("ModelPrefabName")?;
      }
      if let Some(f) = self.AnimatorName() {
        s.serialize_field("AnimatorName", &f)?;
      } else {
        s.skip_field("AnimatorName")?;
      }
      if let Some(f) = self.CafeModelPrefabName() {
        s.serialize_field("CafeModelPrefabName", &f)?;
      } else {
        s.skip_field("CafeModelPrefabName")?;
      }
      if let Some(f) = self.EchelonModelPrefabName() {
        s.serialize_field("EchelonModelPrefabName", &f)?;
      } else {
        s.skip_field("EchelonModelPrefabName")?;
      }
      if let Some(f) = self.StrategyModelPrefabName() {
        s.serialize_field("StrategyModelPrefabName", &f)?;
      } else {
        s.skip_field("StrategyModelPrefabName")?;
      }
      if let Some(f) = self.TextureDir() {
        s.serialize_field("TextureDir", &f)?;
      } else {
        s.skip_field("TextureDir")?;
      }
      if let Some(f) = self.CollectionTexturePath() {
        s.serialize_field("CollectionTexturePath", &f)?;
      } else {
        s.skip_field("CollectionTexturePath")?;
      }
      if let Some(f) = self.CollectionBGTexturePath() {
        s.serialize_field("CollectionBGTexturePath", &f)?;
      } else {
        s.skip_field("CollectionBGTexturePath")?;
      }
      if let Some(f) = self.CombatStyleTexturePath() {
        s.serialize_field("CombatStyleTexturePath", &f)?;
      } else {
        s.skip_field("CombatStyleTexturePath")?;
      }
      s.serialize_field("UseObjectHPBAR", &self.UseObjectHPBAR())?;
      if let Some(f) = self.TextureBoss() {
        s.serialize_field("TextureBoss", &f)?;
      } else {
        s.skip_field("TextureBoss")?;
      }
      if let Some(f) = self.textureSkillCard() {
        s.serialize_field("textureSkillCard", &f)?;
      } else {
        s.skip_field("textureSkillCard")?;
      }
      if let Some(f) = self.InformationPacel() {
        s.serialize_field("InformationPacel", &f)?;
      } else {
        s.skip_field("InformationPacel")?;
      }
      if let Some(f) = self.AnimationSSR() {
        s.serialize_field("AnimationSSR", &f)?;
      } else {
        s.skip_field("AnimationSSR")?;
      }
      if let Some(f) = self.EnterStrategyAnimationName() {
        s.serialize_field("EnterStrategyAnimationName", &f)?;
      } else {
        s.skip_field("EnterStrategyAnimationName")?;
      }
      s.serialize_field("AnimationValidator", &self.AnimationValidator())?;
      s.serialize_field("CharacterVoiceGroupId", &self.CharacterVoiceGroupId())?;
      s.serialize_field("ShowObjectHpStatus", &self.ShowObjectHpStatus())?;
    s.end()
  }
}

pub struct CostumeExcelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CostumeExcelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_CostumeGroupId(&mut self, CostumeGroupId: i64) {
    self.fbb_.push_slot::<i64>(CostumeExcel::VT_COSTUMEGROUPID, CostumeGroupId, 0);
  }
  #[inline]
  pub fn add_CostumeUniqueId(&mut self, CostumeUniqueId: i64) {
    self.fbb_.push_slot::<i64>(CostumeExcel::VT_COSTUMEUNIQUEID, CostumeUniqueId, 0);
  }
  #[inline]
  pub fn add_DevName(&mut self, DevName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CostumeExcel::VT_DEVNAME, DevName);
  }
  #[inline]
  pub fn add_ProductionStep(&mut self, ProductionStep: ProductionStep) {
    self.fbb_.push_slot::<ProductionStep>(CostumeExcel::VT_PRODUCTIONSTEP, ProductionStep, ProductionStep::ToDo);
  }
  #[inline]
  pub fn add_IsDefault(&mut self, IsDefault: bool) {
    self.fbb_.push_slot::<bool>(CostumeExcel::VT_ISDEFAULT, IsDefault, false);
  }
  #[inline]
  pub fn add_CollectionVisible(&mut self, CollectionVisible: bool) {
    self.fbb_.push_slot::<bool>(CostumeExcel::VT_COLLECTIONVISIBLE, CollectionVisible, false);
  }
  #[inline]
  pub fn add_ReleaseDate(&mut self, ReleaseDate: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CostumeExcel::VT_RELEASEDATE, ReleaseDate);
  }
  #[inline]
  pub fn add_CollectionVisibleStartDate(&mut self, CollectionVisibleStartDate: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CostumeExcel::VT_COLLECTIONVISIBLESTARTDATE, CollectionVisibleStartDate);
  }
  #[inline]
  pub fn add_CollectionVisibleEndDate(&mut self, CollectionVisibleEndDate: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CostumeExcel::VT_COLLECTIONVISIBLEENDDATE, CollectionVisibleEndDate);
  }
  #[inline]
  pub fn add_Rarity(&mut self, Rarity: Rarity) {
    self.fbb_.push_slot::<Rarity>(CostumeExcel::VT_RARITY, Rarity, Rarity::N);
  }
  #[inline]
  pub fn add_CharacterSkillListGroupId(&mut self, CharacterSkillListGroupId: i64) {
    self.fbb_.push_slot::<i64>(CostumeExcel::VT_CHARACTERSKILLLISTGROUPID, CharacterSkillListGroupId, 0);
  }
  #[inline]
  pub fn add_SpineResourceName(&mut self, SpineResourceName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CostumeExcel::VT_SPINERESOURCENAME, SpineResourceName);
  }
  #[inline]
  pub fn add_SpineResourceNameDiorama(&mut self, SpineResourceNameDiorama: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CostumeExcel::VT_SPINERESOURCENAMEDIORAMA, SpineResourceNameDiorama);
  }
  #[inline]
  pub fn add_spineResourceNameDioramaForFormConversion(&mut self, spineResourceNameDioramaForFormConversion: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CostumeExcel::VT_SPINERESOURCENAMEDIORAMAFORFORMCONVERSION, spineResourceNameDioramaForFormConversion);
  }
  #[inline]
  pub fn add_EntityMaterialType(&mut self, EntityMaterialType: EntityMaterialType) {
    self.fbb_.push_slot::<EntityMaterialType>(CostumeExcel::VT_ENTITYMATERIALTYPE, EntityMaterialType, EntityMaterialType::Wood);
  }
  #[inline]
  pub fn add_ModelPrefabName(&mut self, ModelPrefabName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CostumeExcel::VT_MODELPREFABNAME, ModelPrefabName);
  }
  #[inline]
  pub fn add_AnimatorName(&mut self, AnimatorName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CostumeExcel::VT_ANIMATORNAME, AnimatorName);
  }
  #[inline]
  pub fn add_CafeModelPrefabName(&mut self, CafeModelPrefabName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CostumeExcel::VT_CAFEMODELPREFABNAME, CafeModelPrefabName);
  }
  #[inline]
  pub fn add_EchelonModelPrefabName(&mut self, EchelonModelPrefabName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CostumeExcel::VT_ECHELONMODELPREFABNAME, EchelonModelPrefabName);
  }
  #[inline]
  pub fn add_StrategyModelPrefabName(&mut self, StrategyModelPrefabName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CostumeExcel::VT_STRATEGYMODELPREFABNAME, StrategyModelPrefabName);
  }
  #[inline]
  pub fn add_TextureDir(&mut self, TextureDir: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CostumeExcel::VT_TEXTUREDIR, TextureDir);
  }
  #[inline]
  pub fn add_CollectionTexturePath(&mut self, CollectionTexturePath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CostumeExcel::VT_COLLECTIONTEXTUREPATH, CollectionTexturePath);
  }
  #[inline]
  pub fn add_CollectionBGTexturePath(&mut self, CollectionBGTexturePath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CostumeExcel::VT_COLLECTIONBGTEXTUREPATH, CollectionBGTexturePath);
  }
  #[inline]
  pub fn add_CombatStyleTexturePath(&mut self, CombatStyleTexturePath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CostumeExcel::VT_COMBATSTYLETEXTUREPATH, CombatStyleTexturePath);
  }
  #[inline]
  pub fn add_UseObjectHPBAR(&mut self, UseObjectHPBAR: bool) {
    self.fbb_.push_slot::<bool>(CostumeExcel::VT_USEOBJECTHPBAR, UseObjectHPBAR, false);
  }
  #[inline]
  pub fn add_TextureBoss(&mut self, TextureBoss: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CostumeExcel::VT_TEXTUREBOSS, TextureBoss);
  }
  #[inline]
  pub fn add_textureSkillCard(&mut self, textureSkillCard: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CostumeExcel::VT_TEXTURESKILLCARD, textureSkillCard);
  }
  #[inline]
  pub fn add_InformationPacel(&mut self, InformationPacel: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CostumeExcel::VT_INFORMATIONPACEL, InformationPacel);
  }
  #[inline]
  pub fn add_AnimationSSR(&mut self, AnimationSSR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CostumeExcel::VT_ANIMATIONSSR, AnimationSSR);
  }
  #[inline]
  pub fn add_EnterStrategyAnimationName(&mut self, EnterStrategyAnimationName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CostumeExcel::VT_ENTERSTRATEGYANIMATIONNAME, EnterStrategyAnimationName);
  }
  #[inline]
  pub fn add_AnimationValidator(&mut self, AnimationValidator: bool) {
    self.fbb_.push_slot::<bool>(CostumeExcel::VT_ANIMATIONVALIDATOR, AnimationValidator, false);
  }
  #[inline]
  pub fn add_CharacterVoiceGroupId(&mut self, CharacterVoiceGroupId: i64) {
    self.fbb_.push_slot::<i64>(CostumeExcel::VT_CHARACTERVOICEGROUPID, CharacterVoiceGroupId, 0);
  }
  #[inline]
  pub fn add_ShowObjectHpStatus(&mut self, ShowObjectHpStatus: bool) {
    self.fbb_.push_slot::<bool>(CostumeExcel::VT_SHOWOBJECTHPSTATUS, ShowObjectHpStatus, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CostumeExcelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CostumeExcelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CostumeExcel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CostumeExcel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CostumeExcel");
      ds.field("CostumeGroupId", &self.CostumeGroupId());
      ds.field("CostumeUniqueId", &self.CostumeUniqueId());
      ds.field("DevName", &self.DevName());
      ds.field("ProductionStep", &self.ProductionStep());
      ds.field("IsDefault", &self.IsDefault());
      ds.field("CollectionVisible", &self.CollectionVisible());
      ds.field("ReleaseDate", &self.ReleaseDate());
      ds.field("CollectionVisibleStartDate", &self.CollectionVisibleStartDate());
      ds.field("CollectionVisibleEndDate", &self.CollectionVisibleEndDate());
      ds.field("Rarity", &self.Rarity());
      ds.field("CharacterSkillListGroupId", &self.CharacterSkillListGroupId());
      ds.field("SpineResourceName", &self.SpineResourceName());
      ds.field("SpineResourceNameDiorama", &self.SpineResourceNameDiorama());
      ds.field("spineResourceNameDioramaForFormConversion", &self.spineResourceNameDioramaForFormConversion());
      ds.field("EntityMaterialType", &self.EntityMaterialType());
      ds.field("ModelPrefabName", &self.ModelPrefabName());
      ds.field("AnimatorName", &self.AnimatorName());
      ds.field("CafeModelPrefabName", &self.CafeModelPrefabName());
      ds.field("EchelonModelPrefabName", &self.EchelonModelPrefabName());
      ds.field("StrategyModelPrefabName", &self.StrategyModelPrefabName());
      ds.field("TextureDir", &self.TextureDir());
      ds.field("CollectionTexturePath", &self.CollectionTexturePath());
      ds.field("CollectionBGTexturePath", &self.CollectionBGTexturePath());
      ds.field("CombatStyleTexturePath", &self.CombatStyleTexturePath());
      ds.field("UseObjectHPBAR", &self.UseObjectHPBAR());
      ds.field("TextureBoss", &self.TextureBoss());
      ds.field("textureSkillCard", &self.textureSkillCard());
      ds.field("InformationPacel", &self.InformationPacel());
      ds.field("AnimationSSR", &self.AnimationSSR());
      ds.field("EnterStrategyAnimationName", &self.EnterStrategyAnimationName());
      ds.field("AnimationValidator", &self.AnimationValidator());
      ds.field("CharacterVoiceGroupId", &self.CharacterVoiceGroupId());
      ds.field("ShowObjectHpStatus", &self.ShowObjectHpStatus());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CostumeExcelT {
  pub CostumeGroupId: i64,
  pub CostumeUniqueId: i64,
  pub DevName: Option<String>,
  pub ProductionStep: ProductionStep,
  pub IsDefault: bool,
  pub CollectionVisible: bool,
  pub ReleaseDate: Option<String>,
  pub CollectionVisibleStartDate: Option<String>,
  pub CollectionVisibleEndDate: Option<String>,
  pub Rarity: Rarity,
  pub CharacterSkillListGroupId: i64,
  pub SpineResourceName: Option<String>,
  pub SpineResourceNameDiorama: Option<String>,
  pub spineResourceNameDioramaForFormConversion: Option<Vec<String>>,
  pub EntityMaterialType: EntityMaterialType,
  pub ModelPrefabName: Option<String>,
  pub AnimatorName: Option<String>,
  pub CafeModelPrefabName: Option<String>,
  pub EchelonModelPrefabName: Option<String>,
  pub StrategyModelPrefabName: Option<String>,
  pub TextureDir: Option<String>,
  pub CollectionTexturePath: Option<String>,
  pub CollectionBGTexturePath: Option<String>,
  pub CombatStyleTexturePath: Option<String>,
  pub UseObjectHPBAR: bool,
  pub TextureBoss: Option<String>,
  pub textureSkillCard: Option<Vec<String>>,
  pub InformationPacel: Option<String>,
  pub AnimationSSR: Option<String>,
  pub EnterStrategyAnimationName: Option<String>,
  pub AnimationValidator: bool,
  pub CharacterVoiceGroupId: i64,
  pub ShowObjectHpStatus: bool,
}
impl Default for CostumeExcelT {
  fn default() -> Self {
    Self {
      CostumeGroupId: 0,
      CostumeUniqueId: 0,
      DevName: None,
      ProductionStep: ProductionStep::ToDo,
      IsDefault: false,
      CollectionVisible: false,
      ReleaseDate: None,
      CollectionVisibleStartDate: None,
      CollectionVisibleEndDate: None,
      Rarity: Rarity::N,
      CharacterSkillListGroupId: 0,
      SpineResourceName: None,
      SpineResourceNameDiorama: None,
      spineResourceNameDioramaForFormConversion: None,
      EntityMaterialType: EntityMaterialType::Wood,
      ModelPrefabName: None,
      AnimatorName: None,
      CafeModelPrefabName: None,
      EchelonModelPrefabName: None,
      StrategyModelPrefabName: None,
      TextureDir: None,
      CollectionTexturePath: None,
      CollectionBGTexturePath: None,
      CombatStyleTexturePath: None,
      UseObjectHPBAR: false,
      TextureBoss: None,
      textureSkillCard: None,
      InformationPacel: None,
      AnimationSSR: None,
      EnterStrategyAnimationName: None,
      AnimationValidator: false,
      CharacterVoiceGroupId: 0,
      ShowObjectHpStatus: false,
    }
  }
}
impl CostumeExcelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CostumeExcel<'b>> {
    let CostumeGroupId = self.CostumeGroupId;
    let CostumeUniqueId = self.CostumeUniqueId;
    let DevName = self.DevName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ProductionStep = self.ProductionStep;
    let IsDefault = self.IsDefault;
    let CollectionVisible = self.CollectionVisible;
    let ReleaseDate = self.ReleaseDate.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CollectionVisibleStartDate = self.CollectionVisibleStartDate.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CollectionVisibleEndDate = self.CollectionVisibleEndDate.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let Rarity = self.Rarity;
    let CharacterSkillListGroupId = self.CharacterSkillListGroupId;
    let SpineResourceName = self.SpineResourceName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SpineResourceNameDiorama = self.SpineResourceNameDiorama.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let spineResourceNameDioramaForFormConversion = self.spineResourceNameDioramaForFormConversion.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let EntityMaterialType = self.EntityMaterialType;
    let ModelPrefabName = self.ModelPrefabName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let AnimatorName = self.AnimatorName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CafeModelPrefabName = self.CafeModelPrefabName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EchelonModelPrefabName = self.EchelonModelPrefabName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let StrategyModelPrefabName = self.StrategyModelPrefabName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TextureDir = self.TextureDir.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CollectionTexturePath = self.CollectionTexturePath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CollectionBGTexturePath = self.CollectionBGTexturePath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CombatStyleTexturePath = self.CombatStyleTexturePath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let UseObjectHPBAR = self.UseObjectHPBAR;
    let TextureBoss = self.TextureBoss.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let textureSkillCard = self.textureSkillCard.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let InformationPacel = self.InformationPacel.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let AnimationSSR = self.AnimationSSR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EnterStrategyAnimationName = self.EnterStrategyAnimationName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let AnimationValidator = self.AnimationValidator;
    let CharacterVoiceGroupId = self.CharacterVoiceGroupId;
    let ShowObjectHpStatus = self.ShowObjectHpStatus;
    CostumeExcel::create(_fbb, &CostumeExcelArgs{
      CostumeGroupId,
      CostumeUniqueId,
      DevName,
      ProductionStep,
      IsDefault,
      CollectionVisible,
      ReleaseDate,
      CollectionVisibleStartDate,
      CollectionVisibleEndDate,
      Rarity,
      CharacterSkillListGroupId,
      SpineResourceName,
      SpineResourceNameDiorama,
      spineResourceNameDioramaForFormConversion,
      EntityMaterialType,
      ModelPrefabName,
      AnimatorName,
      CafeModelPrefabName,
      EchelonModelPrefabName,
      StrategyModelPrefabName,
      TextureDir,
      CollectionTexturePath,
      CollectionBGTexturePath,
      CombatStyleTexturePath,
      UseObjectHPBAR,
      TextureBoss,
      textureSkillCard,
      InformationPacel,
      AnimationSSR,
      EnterStrategyAnimationName,
      AnimationValidator,
      CharacterVoiceGroupId,
      ShowObjectHpStatus,
    })
  }
}
