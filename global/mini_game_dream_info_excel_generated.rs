// automatically generated by the FlatBuffers compiler, do not modify
// @generated
#![allow(unused_imports, dead_code)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum MiniGameDreamInfoExcelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MiniGameDreamInfoExcel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MiniGameDreamInfoExcel<'a> {
  type Inner = MiniGameDreamInfoExcel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MiniGameDreamInfoExcel<'a> {
  pub const VT_EVENTCONTENTID: flatbuffers::VOffsetT = 4;
  pub const VT_DREAMMAKERMULTIPLIERCONDITION: flatbuffers::VOffsetT = 6;
  pub const VT_DREAMMAKERMULTIPLIERCONDITIONVALUE: flatbuffers::VOffsetT = 8;
  pub const VT_DREAMMAKERMULTIPLIERMAX: flatbuffers::VOffsetT = 10;
  pub const VT_DREAMMAKERDAYS: flatbuffers::VOffsetT = 12;
  pub const VT_DREAMMAKERACTIONPOINT: flatbuffers::VOffsetT = 14;
  pub const VT_DREAMMAKERPARCELTYPE: flatbuffers::VOffsetT = 16;
  pub const VT_DREAMMAKERPARCELID: flatbuffers::VOffsetT = 18;
  pub const VT_DREAMMAKERDAILYPOINTPARCELTYPE: flatbuffers::VOffsetT = 20;
  pub const VT_DREAMMAKERDAILYPOINTID: flatbuffers::VOffsetT = 22;
  pub const VT_DREAMMAKERPARAMETERTRANSFER: flatbuffers::VOffsetT = 24;
  pub const VT_SCHEDULECOSTGOODSID: flatbuffers::VOffsetT = 26;
  pub const VT_LOBBYBGMCHANGESCENARIOID: flatbuffers::VOffsetT = 28;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MiniGameDreamInfoExcel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MiniGameDreamInfoExcelArgs
  ) -> flatbuffers::WIPOffset<MiniGameDreamInfoExcel<'bldr>> {
    let mut builder = MiniGameDreamInfoExcelBuilder::new(_fbb);
    let key = table_encryption_service::create_key(b"MiniGameDreamInfo");
      let x = args.LobbyBGMChangeScenarioId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_LobbyBGMChangeScenarioId(x);
      let x = args.ScheduleCostGoodsId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_ScheduleCostGoodsId(x);
      let x = args.DreamMakerParameterTransfer;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_DreamMakerParameterTransfer(x);
      let x = args.DreamMakerDailyPointId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_DreamMakerDailyPointId(x);
      let x = args.DreamMakerParcelId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_DreamMakerParcelId(x);
      let x = args.DreamMakerActionPoint;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_DreamMakerActionPoint(x);
      let x = args.DreamMakerDays;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_DreamMakerDays(x);
      let x = args.DreamMakerMultiplierMax;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_DreamMakerMultiplierMax(x);
      let x = args.DreamMakerMultiplierConditionValue;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_DreamMakerMultiplierConditionValue(x);
      let x = args.EventContentId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_EventContentId(x);
      let x = args.DreamMakerDailyPointParcelType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_DreamMakerDailyPointParcelType(x);
      let x = args.DreamMakerParcelType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_DreamMakerParcelType(x);
      let x = args.DreamMakerMultiplierCondition;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_DreamMakerMultiplierCondition(x);
    builder.finish()
  }

  pub fn unpack(&self) -> MiniGameDreamInfoExcelT {
    let key = table_encryption_service::create_key(b"MiniGameDreamInfo");
      let EventContentId = self.EventContentId();
      let DreamMakerMultiplierCondition = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.DreamMakerMultiplierCondition(), &key)
      } else {
        self.DreamMakerMultiplierCondition()
      };
      let DreamMakerMultiplierConditionValue = self.DreamMakerMultiplierConditionValue();
      let DreamMakerMultiplierMax = self.DreamMakerMultiplierMax();
      let DreamMakerDays = self.DreamMakerDays();
      let DreamMakerActionPoint = self.DreamMakerActionPoint();
      let DreamMakerParcelType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.DreamMakerParcelType(), &key)
      } else {
        self.DreamMakerParcelType()
      };
      let DreamMakerParcelId = self.DreamMakerParcelId();
      let DreamMakerDailyPointParcelType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.DreamMakerDailyPointParcelType(), &key)
      } else {
        self.DreamMakerDailyPointParcelType()
      };
      let DreamMakerDailyPointId = self.DreamMakerDailyPointId();
      let DreamMakerParameterTransfer = self.DreamMakerParameterTransfer();
      let ScheduleCostGoodsId = self.ScheduleCostGoodsId();
      let LobbyBGMChangeScenarioId = self.LobbyBGMChangeScenarioId();
    MiniGameDreamInfoExcelT {
      EventContentId,
      DreamMakerMultiplierCondition,
      DreamMakerMultiplierConditionValue,
      DreamMakerMultiplierMax,
      DreamMakerDays,
      DreamMakerActionPoint,
      DreamMakerParcelType,
      DreamMakerParcelId,
      DreamMakerDailyPointParcelType,
      DreamMakerDailyPointId,
      DreamMakerParameterTransfer,
      ScheduleCostGoodsId,
      LobbyBGMChangeScenarioId,
    }
  }

  #[inline]
  pub fn EventContentId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MiniGameDreamInfoExcel::VT_EVENTCONTENTID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn DreamMakerMultiplierCondition(&self) -> DreamMakerMultiplierCondition {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DreamMakerMultiplierCondition>(MiniGameDreamInfoExcel::VT_DREAMMAKERMULTIPLIERCONDITION, Some(DreamMakerMultiplierCondition::None)).unwrap()}
  }
  #[inline]
  pub fn DreamMakerMultiplierConditionValue(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MiniGameDreamInfoExcel::VT_DREAMMAKERMULTIPLIERCONDITIONVALUE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn DreamMakerMultiplierMax(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MiniGameDreamInfoExcel::VT_DREAMMAKERMULTIPLIERMAX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn DreamMakerDays(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MiniGameDreamInfoExcel::VT_DREAMMAKERDAYS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn DreamMakerActionPoint(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MiniGameDreamInfoExcel::VT_DREAMMAKERACTIONPOINT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn DreamMakerParcelType(&self) -> ParcelType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ParcelType>(MiniGameDreamInfoExcel::VT_DREAMMAKERPARCELTYPE, Some(ParcelType::None)).unwrap()}
  }
  #[inline]
  pub fn DreamMakerParcelId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MiniGameDreamInfoExcel::VT_DREAMMAKERPARCELID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn DreamMakerDailyPointParcelType(&self) -> ParcelType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ParcelType>(MiniGameDreamInfoExcel::VT_DREAMMAKERDAILYPOINTPARCELTYPE, Some(ParcelType::None)).unwrap()}
  }
  #[inline]
  pub fn DreamMakerDailyPointId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MiniGameDreamInfoExcel::VT_DREAMMAKERDAILYPOINTID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn DreamMakerParameterTransfer(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MiniGameDreamInfoExcel::VT_DREAMMAKERPARAMETERTRANSFER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ScheduleCostGoodsId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MiniGameDreamInfoExcel::VT_SCHEDULECOSTGOODSID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn LobbyBGMChangeScenarioId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MiniGameDreamInfoExcel::VT_LOBBYBGMCHANGESCENARIOID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for MiniGameDreamInfoExcel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("EventContentId", Self::VT_EVENTCONTENTID, false)?
     .visit_field::<DreamMakerMultiplierCondition>("DreamMakerMultiplierCondition", Self::VT_DREAMMAKERMULTIPLIERCONDITION, false)?
     .visit_field::<i64>("DreamMakerMultiplierConditionValue", Self::VT_DREAMMAKERMULTIPLIERCONDITIONVALUE, false)?
     .visit_field::<i64>("DreamMakerMultiplierMax", Self::VT_DREAMMAKERMULTIPLIERMAX, false)?
     .visit_field::<i64>("DreamMakerDays", Self::VT_DREAMMAKERDAYS, false)?
     .visit_field::<i64>("DreamMakerActionPoint", Self::VT_DREAMMAKERACTIONPOINT, false)?
     .visit_field::<ParcelType>("DreamMakerParcelType", Self::VT_DREAMMAKERPARCELTYPE, false)?
     .visit_field::<i64>("DreamMakerParcelId", Self::VT_DREAMMAKERPARCELID, false)?
     .visit_field::<ParcelType>("DreamMakerDailyPointParcelType", Self::VT_DREAMMAKERDAILYPOINTPARCELTYPE, false)?
     .visit_field::<i64>("DreamMakerDailyPointId", Self::VT_DREAMMAKERDAILYPOINTID, false)?
     .visit_field::<i64>("DreamMakerParameterTransfer", Self::VT_DREAMMAKERPARAMETERTRANSFER, false)?
     .visit_field::<i64>("ScheduleCostGoodsId", Self::VT_SCHEDULECOSTGOODSID, false)?
     .visit_field::<i64>("LobbyBGMChangeScenarioId", Self::VT_LOBBYBGMCHANGESCENARIOID, false)?
     .finish();
    Ok(())
  }
}
pub struct MiniGameDreamInfoExcelArgs {
    pub EventContentId: i64,
    pub DreamMakerMultiplierCondition: DreamMakerMultiplierCondition,
    pub DreamMakerMultiplierConditionValue: i64,
    pub DreamMakerMultiplierMax: i64,
    pub DreamMakerDays: i64,
    pub DreamMakerActionPoint: i64,
    pub DreamMakerParcelType: ParcelType,
    pub DreamMakerParcelId: i64,
    pub DreamMakerDailyPointParcelType: ParcelType,
    pub DreamMakerDailyPointId: i64,
    pub DreamMakerParameterTransfer: i64,
    pub ScheduleCostGoodsId: i64,
    pub LobbyBGMChangeScenarioId: i64,
}
impl<'a> Default for MiniGameDreamInfoExcelArgs {
  #[inline]
  fn default() -> Self {
    MiniGameDreamInfoExcelArgs {
      EventContentId: 0,
      DreamMakerMultiplierCondition: DreamMakerMultiplierCondition::None,
      DreamMakerMultiplierConditionValue: 0,
      DreamMakerMultiplierMax: 0,
      DreamMakerDays: 0,
      DreamMakerActionPoint: 0,
      DreamMakerParcelType: ParcelType::None,
      DreamMakerParcelId: 0,
      DreamMakerDailyPointParcelType: ParcelType::None,
      DreamMakerDailyPointId: 0,
      DreamMakerParameterTransfer: 0,
      ScheduleCostGoodsId: 0,
      LobbyBGMChangeScenarioId: 0,
    }
  }
}

impl Serialize for MiniGameDreamInfoExcel<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("MiniGameDreamInfoExcel", 13)?;
      s.serialize_field("EventContentId", &self.EventContentId())?;
      s.serialize_field("DreamMakerMultiplierCondition", &self.DreamMakerMultiplierCondition())?;
      s.serialize_field("DreamMakerMultiplierConditionValue", &self.DreamMakerMultiplierConditionValue())?;
      s.serialize_field("DreamMakerMultiplierMax", &self.DreamMakerMultiplierMax())?;
      s.serialize_field("DreamMakerDays", &self.DreamMakerDays())?;
      s.serialize_field("DreamMakerActionPoint", &self.DreamMakerActionPoint())?;
      s.serialize_field("DreamMakerParcelType", &self.DreamMakerParcelType())?;
      s.serialize_field("DreamMakerParcelId", &self.DreamMakerParcelId())?;
      s.serialize_field("DreamMakerDailyPointParcelType", &self.DreamMakerDailyPointParcelType())?;
      s.serialize_field("DreamMakerDailyPointId", &self.DreamMakerDailyPointId())?;
      s.serialize_field("DreamMakerParameterTransfer", &self.DreamMakerParameterTransfer())?;
      s.serialize_field("ScheduleCostGoodsId", &self.ScheduleCostGoodsId())?;
      s.serialize_field("LobbyBGMChangeScenarioId", &self.LobbyBGMChangeScenarioId())?;
    s.end()
  }
}

pub struct MiniGameDreamInfoExcelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MiniGameDreamInfoExcelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_EventContentId(&mut self, EventContentId: i64) {
    self.fbb_.push_slot::<i64>(MiniGameDreamInfoExcel::VT_EVENTCONTENTID, EventContentId, 0);
  }
  #[inline]
  pub fn add_DreamMakerMultiplierCondition(&mut self, DreamMakerMultiplierCondition: DreamMakerMultiplierCondition) {
    self.fbb_.push_slot::<DreamMakerMultiplierCondition>(MiniGameDreamInfoExcel::VT_DREAMMAKERMULTIPLIERCONDITION, DreamMakerMultiplierCondition, DreamMakerMultiplierCondition::None);
  }
  #[inline]
  pub fn add_DreamMakerMultiplierConditionValue(&mut self, DreamMakerMultiplierConditionValue: i64) {
    self.fbb_.push_slot::<i64>(MiniGameDreamInfoExcel::VT_DREAMMAKERMULTIPLIERCONDITIONVALUE, DreamMakerMultiplierConditionValue, 0);
  }
  #[inline]
  pub fn add_DreamMakerMultiplierMax(&mut self, DreamMakerMultiplierMax: i64) {
    self.fbb_.push_slot::<i64>(MiniGameDreamInfoExcel::VT_DREAMMAKERMULTIPLIERMAX, DreamMakerMultiplierMax, 0);
  }
  #[inline]
  pub fn add_DreamMakerDays(&mut self, DreamMakerDays: i64) {
    self.fbb_.push_slot::<i64>(MiniGameDreamInfoExcel::VT_DREAMMAKERDAYS, DreamMakerDays, 0);
  }
  #[inline]
  pub fn add_DreamMakerActionPoint(&mut self, DreamMakerActionPoint: i64) {
    self.fbb_.push_slot::<i64>(MiniGameDreamInfoExcel::VT_DREAMMAKERACTIONPOINT, DreamMakerActionPoint, 0);
  }
  #[inline]
  pub fn add_DreamMakerParcelType(&mut self, DreamMakerParcelType: ParcelType) {
    self.fbb_.push_slot::<ParcelType>(MiniGameDreamInfoExcel::VT_DREAMMAKERPARCELTYPE, DreamMakerParcelType, ParcelType::None);
  }
  #[inline]
  pub fn add_DreamMakerParcelId(&mut self, DreamMakerParcelId: i64) {
    self.fbb_.push_slot::<i64>(MiniGameDreamInfoExcel::VT_DREAMMAKERPARCELID, DreamMakerParcelId, 0);
  }
  #[inline]
  pub fn add_DreamMakerDailyPointParcelType(&mut self, DreamMakerDailyPointParcelType: ParcelType) {
    self.fbb_.push_slot::<ParcelType>(MiniGameDreamInfoExcel::VT_DREAMMAKERDAILYPOINTPARCELTYPE, DreamMakerDailyPointParcelType, ParcelType::None);
  }
  #[inline]
  pub fn add_DreamMakerDailyPointId(&mut self, DreamMakerDailyPointId: i64) {
    self.fbb_.push_slot::<i64>(MiniGameDreamInfoExcel::VT_DREAMMAKERDAILYPOINTID, DreamMakerDailyPointId, 0);
  }
  #[inline]
  pub fn add_DreamMakerParameterTransfer(&mut self, DreamMakerParameterTransfer: i64) {
    self.fbb_.push_slot::<i64>(MiniGameDreamInfoExcel::VT_DREAMMAKERPARAMETERTRANSFER, DreamMakerParameterTransfer, 0);
  }
  #[inline]
  pub fn add_ScheduleCostGoodsId(&mut self, ScheduleCostGoodsId: i64) {
    self.fbb_.push_slot::<i64>(MiniGameDreamInfoExcel::VT_SCHEDULECOSTGOODSID, ScheduleCostGoodsId, 0);
  }
  #[inline]
  pub fn add_LobbyBGMChangeScenarioId(&mut self, LobbyBGMChangeScenarioId: i64) {
    self.fbb_.push_slot::<i64>(MiniGameDreamInfoExcel::VT_LOBBYBGMCHANGESCENARIOID, LobbyBGMChangeScenarioId, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MiniGameDreamInfoExcelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MiniGameDreamInfoExcelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MiniGameDreamInfoExcel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MiniGameDreamInfoExcel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MiniGameDreamInfoExcel");
      ds.field("EventContentId", &self.EventContentId());
      ds.field("DreamMakerMultiplierCondition", &self.DreamMakerMultiplierCondition());
      ds.field("DreamMakerMultiplierConditionValue", &self.DreamMakerMultiplierConditionValue());
      ds.field("DreamMakerMultiplierMax", &self.DreamMakerMultiplierMax());
      ds.field("DreamMakerDays", &self.DreamMakerDays());
      ds.field("DreamMakerActionPoint", &self.DreamMakerActionPoint());
      ds.field("DreamMakerParcelType", &self.DreamMakerParcelType());
      ds.field("DreamMakerParcelId", &self.DreamMakerParcelId());
      ds.field("DreamMakerDailyPointParcelType", &self.DreamMakerDailyPointParcelType());
      ds.field("DreamMakerDailyPointId", &self.DreamMakerDailyPointId());
      ds.field("DreamMakerParameterTransfer", &self.DreamMakerParameterTransfer());
      ds.field("ScheduleCostGoodsId", &self.ScheduleCostGoodsId());
      ds.field("LobbyBGMChangeScenarioId", &self.LobbyBGMChangeScenarioId());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MiniGameDreamInfoExcelT {
  pub EventContentId: i64,
  pub DreamMakerMultiplierCondition: DreamMakerMultiplierCondition,
  pub DreamMakerMultiplierConditionValue: i64,
  pub DreamMakerMultiplierMax: i64,
  pub DreamMakerDays: i64,
  pub DreamMakerActionPoint: i64,
  pub DreamMakerParcelType: ParcelType,
  pub DreamMakerParcelId: i64,
  pub DreamMakerDailyPointParcelType: ParcelType,
  pub DreamMakerDailyPointId: i64,
  pub DreamMakerParameterTransfer: i64,
  pub ScheduleCostGoodsId: i64,
  pub LobbyBGMChangeScenarioId: i64,
}
impl Default for MiniGameDreamInfoExcelT {
  fn default() -> Self {
    Self {
      EventContentId: 0,
      DreamMakerMultiplierCondition: DreamMakerMultiplierCondition::None,
      DreamMakerMultiplierConditionValue: 0,
      DreamMakerMultiplierMax: 0,
      DreamMakerDays: 0,
      DreamMakerActionPoint: 0,
      DreamMakerParcelType: ParcelType::None,
      DreamMakerParcelId: 0,
      DreamMakerDailyPointParcelType: ParcelType::None,
      DreamMakerDailyPointId: 0,
      DreamMakerParameterTransfer: 0,
      ScheduleCostGoodsId: 0,
      LobbyBGMChangeScenarioId: 0,
    }
  }
}
impl MiniGameDreamInfoExcelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<MiniGameDreamInfoExcel<'b>> {
    let EventContentId = self.EventContentId;
    let DreamMakerMultiplierCondition = self.DreamMakerMultiplierCondition;
    let DreamMakerMultiplierConditionValue = self.DreamMakerMultiplierConditionValue;
    let DreamMakerMultiplierMax = self.DreamMakerMultiplierMax;
    let DreamMakerDays = self.DreamMakerDays;
    let DreamMakerActionPoint = self.DreamMakerActionPoint;
    let DreamMakerParcelType = self.DreamMakerParcelType;
    let DreamMakerParcelId = self.DreamMakerParcelId;
    let DreamMakerDailyPointParcelType = self.DreamMakerDailyPointParcelType;
    let DreamMakerDailyPointId = self.DreamMakerDailyPointId;
    let DreamMakerParameterTransfer = self.DreamMakerParameterTransfer;
    let ScheduleCostGoodsId = self.ScheduleCostGoodsId;
    let LobbyBGMChangeScenarioId = self.LobbyBGMChangeScenarioId;
    MiniGameDreamInfoExcel::create(_fbb, &MiniGameDreamInfoExcelArgs{
      EventContentId,
      DreamMakerMultiplierCondition,
      DreamMakerMultiplierConditionValue,
      DreamMakerMultiplierMax,
      DreamMakerDays,
      DreamMakerActionPoint,
      DreamMakerParcelType,
      DreamMakerParcelId,
      DreamMakerDailyPointParcelType,
      DreamMakerDailyPointId,
      DreamMakerParameterTransfer,
      ScheduleCostGoodsId,
      LobbyBGMChangeScenarioId,
    })
  }
}
