// automatically generated by the FlatBuffers compiler, do not modify
// @generated
#![allow(unused_imports, dead_code)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum WorldRaidSeasonManageExcelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct WorldRaidSeasonManageExcel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WorldRaidSeasonManageExcel<'a> {
  type Inner = WorldRaidSeasonManageExcel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> WorldRaidSeasonManageExcel<'a> {
  pub const VT_SEASONID: flatbuffers::VOffsetT = 4;
  pub const VT_EVENTCONTENTID: flatbuffers::VOffsetT = 6;
  pub const VT_ENTERTICKET: flatbuffers::VOffsetT = 8;
  pub const VT_WORLDRAIDLOBBYSCENE: flatbuffers::VOffsetT = 10;
  pub const VT_WORLDRAIDLOBBYBANNER: flatbuffers::VOffsetT = 12;
  pub const VT_WORLDRAIDLOBBYBG: flatbuffers::VOffsetT = 14;
  pub const VT_WORLDRAIDLOBBYBANNERSHOW: flatbuffers::VOffsetT = 16;
  pub const VT_SEASONOPENCONDITION: flatbuffers::VOffsetT = 18;
  pub const VT_WORLDRAIDLOBBYENTERSCENARIO: flatbuffers::VOffsetT = 20;
  pub const VT_CANPLAYNOTSEASONTIME: flatbuffers::VOffsetT = 22;
  pub const VT_WORLDRAIDUNIQUETHEMELOBBYUI: flatbuffers::VOffsetT = 24;
  pub const VT_WORLDRAIDUNIQUETHEMENAME: flatbuffers::VOffsetT = 26;
  pub const VT_CANWORLDRAIDGEMENTER: flatbuffers::VOffsetT = 28;
  pub const VT_HIDEWORLDRAIDTICKETUI: flatbuffers::VOffsetT = 30;
  pub const VT_HIDEWORLDRAIDBOSSCOMPLETEREWARDUI: flatbuffers::VOffsetT = 32;
  pub const VT_USEWORLDRAIDCOMMONTOAST: flatbuffers::VOffsetT = 34;
  pub const VT_OPENRAIDBOSSGROUPID: flatbuffers::VOffsetT = 36;
  pub const VT_BOSSSPAWNTIME: flatbuffers::VOffsetT = 38;
  pub const VT_ELIMINATETIME: flatbuffers::VOffsetT = 40;
  pub const VT_SCENARIOOUTPUTCONDITIONID: flatbuffers::VOffsetT = 42;
  pub const VT_CONDITIONSCENARIOGROUPID: flatbuffers::VOffsetT = 44;
  pub const VT_WORLDRAIDMAPENTEROPERATOR: flatbuffers::VOffsetT = 46;
  pub const VT_USEFAVORRANKBUFF: flatbuffers::VOffsetT = 48;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    WorldRaidSeasonManageExcel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args WorldRaidSeasonManageExcelArgs<'args>
  ) -> flatbuffers::WIPOffset<WorldRaidSeasonManageExcel<'bldr>> {
    let mut builder = WorldRaidSeasonManageExcelBuilder::new(_fbb);
    let key = table_encryption_service::create_key(b"WorldRaidSeasonManage");
      let x = args.WorldRaidLobbyEnterScenario;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_WorldRaidLobbyEnterScenario(x);
      let x = args.SeasonOpenCondition;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_SeasonOpenCondition(x);
      let x = args.EventContentId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_EventContentId(x);
      let x = args.SeasonId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_SeasonId(x);
      if let Some(x) = args.WorldRaidMapEnterOperator {
        builder.add_WorldRaidMapEnterOperator(x);
      }
      if let Some(x) = args.ConditionScenarioGroupid {
        builder.add_ConditionScenarioGroupid(x);
      }
      if let Some(x) = args.ScenarioOutputConditionId {
        builder.add_ScenarioOutputConditionId(x);
      }
      if let Some(x) = args.EliminateTime {
        builder.add_EliminateTime(x);
      }
      if let Some(x) = args.BossSpawnTime {
        builder.add_BossSpawnTime(x);
      }
      if let Some(x) = args.OpenRaidBossGroupId {
        builder.add_OpenRaidBossGroupId(x);
      }
      if let Some(x) = args.WorldRaidUniqueThemeName {
        builder.add_WorldRaidUniqueThemeName(x);
      }
      if let Some(x) = args.WorldRaidLobbyBG {
        builder.add_WorldRaidLobbyBG(x);
      }
      if let Some(x) = args.WorldRaidLobbyBanner {
        builder.add_WorldRaidLobbyBanner(x);
      }
      if let Some(x) = args.WorldRaidLobbyScene {
        builder.add_WorldRaidLobbyScene(x);
      }
      let x = args.EnterTicket;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_EnterTicket(x);
      builder.add_UseFavorRankBuff(args.UseFavorRankBuff);
      builder.add_UseWorldRaidCommonToast(args.UseWorldRaidCommonToast);
      builder.add_HideWorldRaidBossCompleteRewardUI(args.HideWorldRaidBossCompleteRewardUI);
      builder.add_HideWorldRaidTicketUI(args.HideWorldRaidTicketUI);
      builder.add_CanWorldRaidGemEnter(args.CanWorldRaidGemEnter);
      builder.add_WorldRaidUniqueThemeLobbyUI(args.WorldRaidUniqueThemeLobbyUI);
      builder.add_CanPlayNotSeasonTime(args.CanPlayNotSeasonTime);
      builder.add_WorldRaidLobbyBannerShow(args.WorldRaidLobbyBannerShow);
    builder.finish()
  }

  pub fn unpack(&self) -> WorldRaidSeasonManageExcelT {
    let key = table_encryption_service::create_key(b"WorldRaidSeasonManage");
      let SeasonId = self.SeasonId();
      let EventContentId = self.EventContentId();
      let EnterTicket = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.EnterTicket(), &key)
      } else {
        self.EnterTicket()
      };
    let WorldRaidLobbyScene = self.WorldRaidLobbyScene().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let WorldRaidLobbyBanner = self.WorldRaidLobbyBanner().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let WorldRaidLobbyBG = self.WorldRaidLobbyBG().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let WorldRaidLobbyBannerShow = self.WorldRaidLobbyBannerShow();
      let SeasonOpenCondition = self.SeasonOpenCondition();
      let WorldRaidLobbyEnterScenario = self.WorldRaidLobbyEnterScenario();
      let CanPlayNotSeasonTime = self.CanPlayNotSeasonTime();
      let WorldRaidUniqueThemeLobbyUI = self.WorldRaidUniqueThemeLobbyUI();
    let WorldRaidUniqueThemeName = self.WorldRaidUniqueThemeName().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let CanWorldRaidGemEnter = self.CanWorldRaidGemEnter();
      let HideWorldRaidTicketUI = self.HideWorldRaidTicketUI();
      let HideWorldRaidBossCompleteRewardUI = self.HideWorldRaidBossCompleteRewardUI();
      let UseWorldRaidCommonToast = self.UseWorldRaidCommonToast();
    let OpenRaidBossGroupId = self.OpenRaidBossGroupId().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_long(*val, &key) } else { *val }).collect()
    });
    let BossSpawnTime = self.BossSpawnTime().map(|x| {
      x.iter().map(|s| if table_encryption_service::use_encryption() { table_encryption_service::convert_string(s, &key).unwrap() } else { s.to_string() }).collect()
    });
    let EliminateTime = self.EliminateTime().map(|x| {
      x.iter().map(|s| if table_encryption_service::use_encryption() { table_encryption_service::convert_string(s, &key).unwrap() } else { s.to_string() }).collect()
    });
    let ScenarioOutputConditionId = self.ScenarioOutputConditionId().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_long(*val, &key) } else { *val }).collect()
    });
    let ConditionScenarioGroupid = self.ConditionScenarioGroupid().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_long(*val, &key) } else { *val }).collect()
    });
    let WorldRaidMapEnterOperator = self.WorldRaidMapEnterOperator().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let UseFavorRankBuff = self.UseFavorRankBuff();
    WorldRaidSeasonManageExcelT {
      SeasonId,
      EventContentId,
      EnterTicket,
      WorldRaidLobbyScene,
      WorldRaidLobbyBanner,
      WorldRaidLobbyBG,
      WorldRaidLobbyBannerShow,
      SeasonOpenCondition,
      WorldRaidLobbyEnterScenario,
      CanPlayNotSeasonTime,
      WorldRaidUniqueThemeLobbyUI,
      WorldRaidUniqueThemeName,
      CanWorldRaidGemEnter,
      HideWorldRaidTicketUI,
      HideWorldRaidBossCompleteRewardUI,
      UseWorldRaidCommonToast,
      OpenRaidBossGroupId,
      BossSpawnTime,
      EliminateTime,
      ScenarioOutputConditionId,
      ConditionScenarioGroupid,
      WorldRaidMapEnterOperator,
      UseFavorRankBuff,
    }
  }

  #[inline]
  pub fn SeasonId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(WorldRaidSeasonManageExcel::VT_SEASONID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EventContentId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(WorldRaidSeasonManageExcel::VT_EVENTCONTENTID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EnterTicket(&self) -> CurrencyTypes {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<CurrencyTypes>(WorldRaidSeasonManageExcel::VT_ENTERTICKET, Some(CurrencyTypes::Invalid)).unwrap()}
  }
  #[inline]
  pub fn WorldRaidLobbyScene(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WorldRaidSeasonManageExcel::VT_WORLDRAIDLOBBYSCENE, None)}
  }
  #[inline]
  pub fn WorldRaidLobbyBanner(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WorldRaidSeasonManageExcel::VT_WORLDRAIDLOBBYBANNER, None)}
  }
  #[inline]
  pub fn WorldRaidLobbyBG(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WorldRaidSeasonManageExcel::VT_WORLDRAIDLOBBYBG, None)}
  }
  #[inline]
  pub fn WorldRaidLobbyBannerShow(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(WorldRaidSeasonManageExcel::VT_WORLDRAIDLOBBYBANNERSHOW, Some(false)).unwrap()}
  }
  #[inline]
  pub fn SeasonOpenCondition(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(WorldRaidSeasonManageExcel::VT_SEASONOPENCONDITION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn WorldRaidLobbyEnterScenario(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(WorldRaidSeasonManageExcel::VT_WORLDRAIDLOBBYENTERSCENARIO, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CanPlayNotSeasonTime(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(WorldRaidSeasonManageExcel::VT_CANPLAYNOTSEASONTIME, Some(false)).unwrap()}
  }
  #[inline]
  pub fn WorldRaidUniqueThemeLobbyUI(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(WorldRaidSeasonManageExcel::VT_WORLDRAIDUNIQUETHEMELOBBYUI, Some(false)).unwrap()}
  }
  #[inline]
  pub fn WorldRaidUniqueThemeName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WorldRaidSeasonManageExcel::VT_WORLDRAIDUNIQUETHEMENAME, None)}
  }
  #[inline]
  pub fn CanWorldRaidGemEnter(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(WorldRaidSeasonManageExcel::VT_CANWORLDRAIDGEMENTER, Some(false)).unwrap()}
  }
  #[inline]
  pub fn HideWorldRaidTicketUI(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(WorldRaidSeasonManageExcel::VT_HIDEWORLDRAIDTICKETUI, Some(false)).unwrap()}
  }
  #[inline]
  pub fn HideWorldRaidBossCompleteRewardUI(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(WorldRaidSeasonManageExcel::VT_HIDEWORLDRAIDBOSSCOMPLETEREWARDUI, Some(false)).unwrap()}
  }
  #[inline]
  pub fn UseWorldRaidCommonToast(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(WorldRaidSeasonManageExcel::VT_USEWORLDRAIDCOMMONTOAST, Some(false)).unwrap()}
  }
  #[inline]
  pub fn OpenRaidBossGroupId(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(WorldRaidSeasonManageExcel::VT_OPENRAIDBOSSGROUPID, None)}
  }
  #[inline]
  pub fn BossSpawnTime(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(WorldRaidSeasonManageExcel::VT_BOSSSPAWNTIME, None)}
  }
  #[inline]
  pub fn EliminateTime(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(WorldRaidSeasonManageExcel::VT_ELIMINATETIME, None)}
  }
  #[inline]
  pub fn ScenarioOutputConditionId(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(WorldRaidSeasonManageExcel::VT_SCENARIOOUTPUTCONDITIONID, None)}
  }
  #[inline]
  pub fn ConditionScenarioGroupid(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(WorldRaidSeasonManageExcel::VT_CONDITIONSCENARIOGROUPID, None)}
  }
  #[inline]
  pub fn WorldRaidMapEnterOperator(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WorldRaidSeasonManageExcel::VT_WORLDRAIDMAPENTEROPERATOR, None)}
  }
  #[inline]
  pub fn UseFavorRankBuff(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(WorldRaidSeasonManageExcel::VT_USEFAVORRANKBUFF, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for WorldRaidSeasonManageExcel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("SeasonId", Self::VT_SEASONID, false)?
     .visit_field::<i64>("EventContentId", Self::VT_EVENTCONTENTID, false)?
     .visit_field::<CurrencyTypes>("EnterTicket", Self::VT_ENTERTICKET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("WorldRaidLobbyScene", Self::VT_WORLDRAIDLOBBYSCENE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("WorldRaidLobbyBanner", Self::VT_WORLDRAIDLOBBYBANNER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("WorldRaidLobbyBG", Self::VT_WORLDRAIDLOBBYBG, false)?
     .visit_field::<bool>("WorldRaidLobbyBannerShow", Self::VT_WORLDRAIDLOBBYBANNERSHOW, false)?
     .visit_field::<i64>("SeasonOpenCondition", Self::VT_SEASONOPENCONDITION, false)?
     .visit_field::<i64>("WorldRaidLobbyEnterScenario", Self::VT_WORLDRAIDLOBBYENTERSCENARIO, false)?
     .visit_field::<bool>("CanPlayNotSeasonTime", Self::VT_CANPLAYNOTSEASONTIME, false)?
     .visit_field::<bool>("WorldRaidUniqueThemeLobbyUI", Self::VT_WORLDRAIDUNIQUETHEMELOBBYUI, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("WorldRaidUniqueThemeName", Self::VT_WORLDRAIDUNIQUETHEMENAME, false)?
     .visit_field::<bool>("CanWorldRaidGemEnter", Self::VT_CANWORLDRAIDGEMENTER, false)?
     .visit_field::<bool>("HideWorldRaidTicketUI", Self::VT_HIDEWORLDRAIDTICKETUI, false)?
     .visit_field::<bool>("HideWorldRaidBossCompleteRewardUI", Self::VT_HIDEWORLDRAIDBOSSCOMPLETEREWARDUI, false)?
     .visit_field::<bool>("UseWorldRaidCommonToast", Self::VT_USEWORLDRAIDCOMMONTOAST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("OpenRaidBossGroupId", Self::VT_OPENRAIDBOSSGROUPID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("BossSpawnTime", Self::VT_BOSSSPAWNTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("EliminateTime", Self::VT_ELIMINATETIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("ScenarioOutputConditionId", Self::VT_SCENARIOOUTPUTCONDITIONID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("ConditionScenarioGroupid", Self::VT_CONDITIONSCENARIOGROUPID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("WorldRaidMapEnterOperator", Self::VT_WORLDRAIDMAPENTEROPERATOR, false)?
     .visit_field::<bool>("UseFavorRankBuff", Self::VT_USEFAVORRANKBUFF, false)?
     .finish();
    Ok(())
  }
}
pub struct WorldRaidSeasonManageExcelArgs<'a> {
    pub SeasonId: i64,
    pub EventContentId: i64,
    pub EnterTicket: CurrencyTypes,
    pub WorldRaidLobbyScene: Option<flatbuffers::WIPOffset<&'a str>>,
    pub WorldRaidLobbyBanner: Option<flatbuffers::WIPOffset<&'a str>>,
    pub WorldRaidLobbyBG: Option<flatbuffers::WIPOffset<&'a str>>,
    pub WorldRaidLobbyBannerShow: bool,
    pub SeasonOpenCondition: i64,
    pub WorldRaidLobbyEnterScenario: i64,
    pub CanPlayNotSeasonTime: bool,
    pub WorldRaidUniqueThemeLobbyUI: bool,
    pub WorldRaidUniqueThemeName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CanWorldRaidGemEnter: bool,
    pub HideWorldRaidTicketUI: bool,
    pub HideWorldRaidBossCompleteRewardUI: bool,
    pub UseWorldRaidCommonToast: bool,
    pub OpenRaidBossGroupId: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub BossSpawnTime: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub EliminateTime: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub ScenarioOutputConditionId: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub ConditionScenarioGroupid: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub WorldRaidMapEnterOperator: Option<flatbuffers::WIPOffset<&'a str>>,
    pub UseFavorRankBuff: bool,
}
impl<'a> Default for WorldRaidSeasonManageExcelArgs<'a> {
  #[inline]
  fn default() -> Self {
    WorldRaidSeasonManageExcelArgs {
      SeasonId: 0,
      EventContentId: 0,
      EnterTicket: CurrencyTypes::Invalid,
      WorldRaidLobbyScene: None,
      WorldRaidLobbyBanner: None,
      WorldRaidLobbyBG: None,
      WorldRaidLobbyBannerShow: false,
      SeasonOpenCondition: 0,
      WorldRaidLobbyEnterScenario: 0,
      CanPlayNotSeasonTime: false,
      WorldRaidUniqueThemeLobbyUI: false,
      WorldRaidUniqueThemeName: None,
      CanWorldRaidGemEnter: false,
      HideWorldRaidTicketUI: false,
      HideWorldRaidBossCompleteRewardUI: false,
      UseWorldRaidCommonToast: false,
      OpenRaidBossGroupId: None,
      BossSpawnTime: None,
      EliminateTime: None,
      ScenarioOutputConditionId: None,
      ConditionScenarioGroupid: None,
      WorldRaidMapEnterOperator: None,
      UseFavorRankBuff: false,
    }
  }
}

impl Serialize for WorldRaidSeasonManageExcel<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("WorldRaidSeasonManageExcel", 23)?;
      s.serialize_field("SeasonId", &self.SeasonId())?;
      s.serialize_field("EventContentId", &self.EventContentId())?;
      s.serialize_field("EnterTicket", &self.EnterTicket())?;
      if let Some(f) = self.WorldRaidLobbyScene() {
        s.serialize_field("WorldRaidLobbyScene", &f)?;
      } else {
        s.skip_field("WorldRaidLobbyScene")?;
      }
      if let Some(f) = self.WorldRaidLobbyBanner() {
        s.serialize_field("WorldRaidLobbyBanner", &f)?;
      } else {
        s.skip_field("WorldRaidLobbyBanner")?;
      }
      if let Some(f) = self.WorldRaidLobbyBG() {
        s.serialize_field("WorldRaidLobbyBG", &f)?;
      } else {
        s.skip_field("WorldRaidLobbyBG")?;
      }
      s.serialize_field("WorldRaidLobbyBannerShow", &self.WorldRaidLobbyBannerShow())?;
      s.serialize_field("SeasonOpenCondition", &self.SeasonOpenCondition())?;
      s.serialize_field("WorldRaidLobbyEnterScenario", &self.WorldRaidLobbyEnterScenario())?;
      s.serialize_field("CanPlayNotSeasonTime", &self.CanPlayNotSeasonTime())?;
      s.serialize_field("WorldRaidUniqueThemeLobbyUI", &self.WorldRaidUniqueThemeLobbyUI())?;
      if let Some(f) = self.WorldRaidUniqueThemeName() {
        s.serialize_field("WorldRaidUniqueThemeName", &f)?;
      } else {
        s.skip_field("WorldRaidUniqueThemeName")?;
      }
      s.serialize_field("CanWorldRaidGemEnter", &self.CanWorldRaidGemEnter())?;
      s.serialize_field("HideWorldRaidTicketUI", &self.HideWorldRaidTicketUI())?;
      s.serialize_field("HideWorldRaidBossCompleteRewardUI", &self.HideWorldRaidBossCompleteRewardUI())?;
      s.serialize_field("UseWorldRaidCommonToast", &self.UseWorldRaidCommonToast())?;
      if let Some(f) = self.OpenRaidBossGroupId() {
        s.serialize_field("OpenRaidBossGroupId", &f)?;
      } else {
        s.skip_field("OpenRaidBossGroupId")?;
      }
      if let Some(f) = self.BossSpawnTime() {
        s.serialize_field("BossSpawnTime", &f)?;
      } else {
        s.skip_field("BossSpawnTime")?;
      }
      if let Some(f) = self.EliminateTime() {
        s.serialize_field("EliminateTime", &f)?;
      } else {
        s.skip_field("EliminateTime")?;
      }
      if let Some(f) = self.ScenarioOutputConditionId() {
        s.serialize_field("ScenarioOutputConditionId", &f)?;
      } else {
        s.skip_field("ScenarioOutputConditionId")?;
      }
      if let Some(f) = self.ConditionScenarioGroupid() {
        s.serialize_field("ConditionScenarioGroupid", &f)?;
      } else {
        s.skip_field("ConditionScenarioGroupid")?;
      }
      if let Some(f) = self.WorldRaidMapEnterOperator() {
        s.serialize_field("WorldRaidMapEnterOperator", &f)?;
      } else {
        s.skip_field("WorldRaidMapEnterOperator")?;
      }
      s.serialize_field("UseFavorRankBuff", &self.UseFavorRankBuff())?;
    s.end()
  }
}

pub struct WorldRaidSeasonManageExcelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> WorldRaidSeasonManageExcelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_SeasonId(&mut self, SeasonId: i64) {
    self.fbb_.push_slot::<i64>(WorldRaidSeasonManageExcel::VT_SEASONID, SeasonId, 0);
  }
  #[inline]
  pub fn add_EventContentId(&mut self, EventContentId: i64) {
    self.fbb_.push_slot::<i64>(WorldRaidSeasonManageExcel::VT_EVENTCONTENTID, EventContentId, 0);
  }
  #[inline]
  pub fn add_EnterTicket(&mut self, EnterTicket: CurrencyTypes) {
    self.fbb_.push_slot::<CurrencyTypes>(WorldRaidSeasonManageExcel::VT_ENTERTICKET, EnterTicket, CurrencyTypes::Invalid);
  }
  #[inline]
  pub fn add_WorldRaidLobbyScene(&mut self, WorldRaidLobbyScene: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WorldRaidSeasonManageExcel::VT_WORLDRAIDLOBBYSCENE, WorldRaidLobbyScene);
  }
  #[inline]
  pub fn add_WorldRaidLobbyBanner(&mut self, WorldRaidLobbyBanner: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WorldRaidSeasonManageExcel::VT_WORLDRAIDLOBBYBANNER, WorldRaidLobbyBanner);
  }
  #[inline]
  pub fn add_WorldRaidLobbyBG(&mut self, WorldRaidLobbyBG: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WorldRaidSeasonManageExcel::VT_WORLDRAIDLOBBYBG, WorldRaidLobbyBG);
  }
  #[inline]
  pub fn add_WorldRaidLobbyBannerShow(&mut self, WorldRaidLobbyBannerShow: bool) {
    self.fbb_.push_slot::<bool>(WorldRaidSeasonManageExcel::VT_WORLDRAIDLOBBYBANNERSHOW, WorldRaidLobbyBannerShow, false);
  }
  #[inline]
  pub fn add_SeasonOpenCondition(&mut self, SeasonOpenCondition: i64) {
    self.fbb_.push_slot::<i64>(WorldRaidSeasonManageExcel::VT_SEASONOPENCONDITION, SeasonOpenCondition, 0);
  }
  #[inline]
  pub fn add_WorldRaidLobbyEnterScenario(&mut self, WorldRaidLobbyEnterScenario: i64) {
    self.fbb_.push_slot::<i64>(WorldRaidSeasonManageExcel::VT_WORLDRAIDLOBBYENTERSCENARIO, WorldRaidLobbyEnterScenario, 0);
  }
  #[inline]
  pub fn add_CanPlayNotSeasonTime(&mut self, CanPlayNotSeasonTime: bool) {
    self.fbb_.push_slot::<bool>(WorldRaidSeasonManageExcel::VT_CANPLAYNOTSEASONTIME, CanPlayNotSeasonTime, false);
  }
  #[inline]
  pub fn add_WorldRaidUniqueThemeLobbyUI(&mut self, WorldRaidUniqueThemeLobbyUI: bool) {
    self.fbb_.push_slot::<bool>(WorldRaidSeasonManageExcel::VT_WORLDRAIDUNIQUETHEMELOBBYUI, WorldRaidUniqueThemeLobbyUI, false);
  }
  #[inline]
  pub fn add_WorldRaidUniqueThemeName(&mut self, WorldRaidUniqueThemeName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WorldRaidSeasonManageExcel::VT_WORLDRAIDUNIQUETHEMENAME, WorldRaidUniqueThemeName);
  }
  #[inline]
  pub fn add_CanWorldRaidGemEnter(&mut self, CanWorldRaidGemEnter: bool) {
    self.fbb_.push_slot::<bool>(WorldRaidSeasonManageExcel::VT_CANWORLDRAIDGEMENTER, CanWorldRaidGemEnter, false);
  }
  #[inline]
  pub fn add_HideWorldRaidTicketUI(&mut self, HideWorldRaidTicketUI: bool) {
    self.fbb_.push_slot::<bool>(WorldRaidSeasonManageExcel::VT_HIDEWORLDRAIDTICKETUI, HideWorldRaidTicketUI, false);
  }
  #[inline]
  pub fn add_HideWorldRaidBossCompleteRewardUI(&mut self, HideWorldRaidBossCompleteRewardUI: bool) {
    self.fbb_.push_slot::<bool>(WorldRaidSeasonManageExcel::VT_HIDEWORLDRAIDBOSSCOMPLETEREWARDUI, HideWorldRaidBossCompleteRewardUI, false);
  }
  #[inline]
  pub fn add_UseWorldRaidCommonToast(&mut self, UseWorldRaidCommonToast: bool) {
    self.fbb_.push_slot::<bool>(WorldRaidSeasonManageExcel::VT_USEWORLDRAIDCOMMONTOAST, UseWorldRaidCommonToast, false);
  }
  #[inline]
  pub fn add_OpenRaidBossGroupId(&mut self, OpenRaidBossGroupId: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WorldRaidSeasonManageExcel::VT_OPENRAIDBOSSGROUPID, OpenRaidBossGroupId);
  }
  #[inline]
  pub fn add_BossSpawnTime(&mut self, BossSpawnTime: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WorldRaidSeasonManageExcel::VT_BOSSSPAWNTIME, BossSpawnTime);
  }
  #[inline]
  pub fn add_EliminateTime(&mut self, EliminateTime: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WorldRaidSeasonManageExcel::VT_ELIMINATETIME, EliminateTime);
  }
  #[inline]
  pub fn add_ScenarioOutputConditionId(&mut self, ScenarioOutputConditionId: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WorldRaidSeasonManageExcel::VT_SCENARIOOUTPUTCONDITIONID, ScenarioOutputConditionId);
  }
  #[inline]
  pub fn add_ConditionScenarioGroupid(&mut self, ConditionScenarioGroupid: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WorldRaidSeasonManageExcel::VT_CONDITIONSCENARIOGROUPID, ConditionScenarioGroupid);
  }
  #[inline]
  pub fn add_WorldRaidMapEnterOperator(&mut self, WorldRaidMapEnterOperator: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WorldRaidSeasonManageExcel::VT_WORLDRAIDMAPENTEROPERATOR, WorldRaidMapEnterOperator);
  }
  #[inline]
  pub fn add_UseFavorRankBuff(&mut self, UseFavorRankBuff: bool) {
    self.fbb_.push_slot::<bool>(WorldRaidSeasonManageExcel::VT_USEFAVORRANKBUFF, UseFavorRankBuff, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> WorldRaidSeasonManageExcelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    WorldRaidSeasonManageExcelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WorldRaidSeasonManageExcel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for WorldRaidSeasonManageExcel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("WorldRaidSeasonManageExcel");
      ds.field("SeasonId", &self.SeasonId());
      ds.field("EventContentId", &self.EventContentId());
      ds.field("EnterTicket", &self.EnterTicket());
      ds.field("WorldRaidLobbyScene", &self.WorldRaidLobbyScene());
      ds.field("WorldRaidLobbyBanner", &self.WorldRaidLobbyBanner());
      ds.field("WorldRaidLobbyBG", &self.WorldRaidLobbyBG());
      ds.field("WorldRaidLobbyBannerShow", &self.WorldRaidLobbyBannerShow());
      ds.field("SeasonOpenCondition", &self.SeasonOpenCondition());
      ds.field("WorldRaidLobbyEnterScenario", &self.WorldRaidLobbyEnterScenario());
      ds.field("CanPlayNotSeasonTime", &self.CanPlayNotSeasonTime());
      ds.field("WorldRaidUniqueThemeLobbyUI", &self.WorldRaidUniqueThemeLobbyUI());
      ds.field("WorldRaidUniqueThemeName", &self.WorldRaidUniqueThemeName());
      ds.field("CanWorldRaidGemEnter", &self.CanWorldRaidGemEnter());
      ds.field("HideWorldRaidTicketUI", &self.HideWorldRaidTicketUI());
      ds.field("HideWorldRaidBossCompleteRewardUI", &self.HideWorldRaidBossCompleteRewardUI());
      ds.field("UseWorldRaidCommonToast", &self.UseWorldRaidCommonToast());
      ds.field("OpenRaidBossGroupId", &self.OpenRaidBossGroupId());
      ds.field("BossSpawnTime", &self.BossSpawnTime());
      ds.field("EliminateTime", &self.EliminateTime());
      ds.field("ScenarioOutputConditionId", &self.ScenarioOutputConditionId());
      ds.field("ConditionScenarioGroupid", &self.ConditionScenarioGroupid());
      ds.field("WorldRaidMapEnterOperator", &self.WorldRaidMapEnterOperator());
      ds.field("UseFavorRankBuff", &self.UseFavorRankBuff());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct WorldRaidSeasonManageExcelT {
  pub SeasonId: i64,
  pub EventContentId: i64,
  pub EnterTicket: CurrencyTypes,
  pub WorldRaidLobbyScene: Option<String>,
  pub WorldRaidLobbyBanner: Option<String>,
  pub WorldRaidLobbyBG: Option<String>,
  pub WorldRaidLobbyBannerShow: bool,
  pub SeasonOpenCondition: i64,
  pub WorldRaidLobbyEnterScenario: i64,
  pub CanPlayNotSeasonTime: bool,
  pub WorldRaidUniqueThemeLobbyUI: bool,
  pub WorldRaidUniqueThemeName: Option<String>,
  pub CanWorldRaidGemEnter: bool,
  pub HideWorldRaidTicketUI: bool,
  pub HideWorldRaidBossCompleteRewardUI: bool,
  pub UseWorldRaidCommonToast: bool,
  pub OpenRaidBossGroupId: Option<Vec<i64>>,
  pub BossSpawnTime: Option<Vec<String>>,
  pub EliminateTime: Option<Vec<String>>,
  pub ScenarioOutputConditionId: Option<Vec<i64>>,
  pub ConditionScenarioGroupid: Option<Vec<i64>>,
  pub WorldRaidMapEnterOperator: Option<String>,
  pub UseFavorRankBuff: bool,
}
impl Default for WorldRaidSeasonManageExcelT {
  fn default() -> Self {
    Self {
      SeasonId: 0,
      EventContentId: 0,
      EnterTicket: CurrencyTypes::Invalid,
      WorldRaidLobbyScene: None,
      WorldRaidLobbyBanner: None,
      WorldRaidLobbyBG: None,
      WorldRaidLobbyBannerShow: false,
      SeasonOpenCondition: 0,
      WorldRaidLobbyEnterScenario: 0,
      CanPlayNotSeasonTime: false,
      WorldRaidUniqueThemeLobbyUI: false,
      WorldRaidUniqueThemeName: None,
      CanWorldRaidGemEnter: false,
      HideWorldRaidTicketUI: false,
      HideWorldRaidBossCompleteRewardUI: false,
      UseWorldRaidCommonToast: false,
      OpenRaidBossGroupId: None,
      BossSpawnTime: None,
      EliminateTime: None,
      ScenarioOutputConditionId: None,
      ConditionScenarioGroupid: None,
      WorldRaidMapEnterOperator: None,
      UseFavorRankBuff: false,
    }
  }
}
impl WorldRaidSeasonManageExcelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<WorldRaidSeasonManageExcel<'b>> {
    let SeasonId = self.SeasonId;
    let EventContentId = self.EventContentId;
    let EnterTicket = self.EnterTicket;
    let WorldRaidLobbyScene = self.WorldRaidLobbyScene.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let WorldRaidLobbyBanner = self.WorldRaidLobbyBanner.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let WorldRaidLobbyBG = self.WorldRaidLobbyBG.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let WorldRaidLobbyBannerShow = self.WorldRaidLobbyBannerShow;
    let SeasonOpenCondition = self.SeasonOpenCondition;
    let WorldRaidLobbyEnterScenario = self.WorldRaidLobbyEnterScenario;
    let CanPlayNotSeasonTime = self.CanPlayNotSeasonTime;
    let WorldRaidUniqueThemeLobbyUI = self.WorldRaidUniqueThemeLobbyUI;
    let WorldRaidUniqueThemeName = self.WorldRaidUniqueThemeName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CanWorldRaidGemEnter = self.CanWorldRaidGemEnter;
    let HideWorldRaidTicketUI = self.HideWorldRaidTicketUI;
    let HideWorldRaidBossCompleteRewardUI = self.HideWorldRaidBossCompleteRewardUI;
    let UseWorldRaidCommonToast = self.UseWorldRaidCommonToast;
    let OpenRaidBossGroupId = self.OpenRaidBossGroupId.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let BossSpawnTime = self.BossSpawnTime.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let EliminateTime = self.EliminateTime.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let ScenarioOutputConditionId = self.ScenarioOutputConditionId.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let ConditionScenarioGroupid = self.ConditionScenarioGroupid.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let WorldRaidMapEnterOperator = self.WorldRaidMapEnterOperator.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let UseFavorRankBuff = self.UseFavorRankBuff;
    WorldRaidSeasonManageExcel::create(_fbb, &WorldRaidSeasonManageExcelArgs{
      SeasonId,
      EventContentId,
      EnterTicket,
      WorldRaidLobbyScene,
      WorldRaidLobbyBanner,
      WorldRaidLobbyBG,
      WorldRaidLobbyBannerShow,
      SeasonOpenCondition,
      WorldRaidLobbyEnterScenario,
      CanPlayNotSeasonTime,
      WorldRaidUniqueThemeLobbyUI,
      WorldRaidUniqueThemeName,
      CanWorldRaidGemEnter,
      HideWorldRaidTicketUI,
      HideWorldRaidBossCompleteRewardUI,
      UseWorldRaidCommonToast,
      OpenRaidBossGroupId,
      BossSpawnTime,
      EliminateTime,
      ScenarioOutputConditionId,
      ConditionScenarioGroupid,
      WorldRaidMapEnterOperator,
      UseFavorRankBuff,
    })
  }
}
