// automatically generated by the FlatBuffers compiler, do not modify
// @generated
#![allow(unused_imports, dead_code)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum MultiFloorRaidStageExcelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MultiFloorRaidStageExcel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MultiFloorRaidStageExcel<'a> {
  type Inner = MultiFloorRaidStageExcel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MultiFloorRaidStageExcel<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_ECHELONEXTENSIONTYPE: flatbuffers::VOffsetT = 6;
  pub const VT_BOSSGROUPID: flatbuffers::VOffsetT = 8;
  pub const VT_ASSISTSLOT: flatbuffers::VOffsetT = 10;
  pub const VT_STAGEOPENCONDITION: flatbuffers::VOffsetT = 12;
  pub const VT_FLOORLISTSECTION: flatbuffers::VOffsetT = 14;
  pub const VT_FLOORLISTSECTIONOPENCONDITION: flatbuffers::VOffsetT = 16;
  pub const VT_FLOORLISTSECTIONLABEL: flatbuffers::VOffsetT = 18;
  pub const VT_DIFFICULTY: flatbuffers::VOffsetT = 20;
  pub const VT_USEBOSSINDEX: flatbuffers::VOffsetT = 22;
  pub const VT_USEBOSSAIPHASESYNC: flatbuffers::VOffsetT = 24;
  pub const VT_FLOORLISTIMGPATH: flatbuffers::VOffsetT = 26;
  pub const VT_FLOORIMGPATH: flatbuffers::VOffsetT = 28;
  pub const VT_RAIDCHARACTERID: flatbuffers::VOffsetT = 30;
  pub const VT_BOSSCHARACTERID: flatbuffers::VOffsetT = 32;
  pub const VT_STATCHANGEID: flatbuffers::VOffsetT = 34;
  pub const VT_BATTLEDURATION: flatbuffers::VOffsetT = 36;
  pub const VT_GROUNDID: flatbuffers::VOffsetT = 38;
  pub const VT_RECOMMENDLEVEL: flatbuffers::VOffsetT = 40;
  pub const VT_REWARDGROUPID: flatbuffers::VOffsetT = 42;
  pub const VT_BATTLEREADYTIMELINEPATH: flatbuffers::VOffsetT = 44;
  pub const VT_BATTLEREADYTIMELINEPHASESTART: flatbuffers::VOffsetT = 46;
  pub const VT_BATTLEREADYTIMELINEPHASEEND: flatbuffers::VOffsetT = 48;
  pub const VT_VICTORYTIMELINEPATH: flatbuffers::VOffsetT = 50;
  pub const VT_SHOWSKILLCARD: flatbuffers::VOffsetT = 52;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MultiFloorRaidStageExcel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MultiFloorRaidStageExcelArgs<'args>
  ) -> flatbuffers::WIPOffset<MultiFloorRaidStageExcel<'bldr>> {
    let mut builder = MultiFloorRaidStageExcelBuilder::new(_fbb);
    let key = table_encryption_service::create_key(b"MultiFloorRaidStage");
      let x = args.RewardGroupId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_RewardGroupId(x);
      let x = args.RecommendLevel;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_RecommendLevel(x);
      let x = args.GroundId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_GroundId(x);
      let x = args.BattleDuration;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_BattleDuration(x);
      let x = args.RaidCharacterId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_RaidCharacterId(x);
      let x = args.FloorListSectionOpenCondition;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_FloorListSectionOpenCondition(x);
      let x = args.StageOpenCondition;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_StageOpenCondition(x);
      let x = args.Id;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_Id(x);
      if let Some(x) = args.VictoryTimelinePath {
        builder.add_VictoryTimelinePath(x);
      }
      if let Some(x) = args.BattleReadyTimelinePhaseEnd {
        builder.add_BattleReadyTimelinePhaseEnd(x);
      }
      if let Some(x) = args.BattleReadyTimelinePhaseStart {
        builder.add_BattleReadyTimelinePhaseStart(x);
      }
      if let Some(x) = args.BattleReadyTimelinePath {
        builder.add_BattleReadyTimelinePath(x);
      }
      if let Some(x) = args.StatChangeId {
        builder.add_StatChangeId(x);
      }
      if let Some(x) = args.BossCharacterId {
        builder.add_BossCharacterId(x);
      }
      if let Some(x) = args.FloorImgPath {
        builder.add_FloorImgPath(x);
      }
      if let Some(x) = args.FloorListImgPath {
        builder.add_FloorListImgPath(x);
      }
      let x = args.Difficulty;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_Difficulty(x);
      let x = args.FloorListSectionLabel;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_uint(x, &key) } else { x };
      builder.add_FloorListSectionLabel(x);
      let x = args.AssistSlot;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_AssistSlot(x);
      if let Some(x) = args.BossGroupId {
        builder.add_BossGroupId(x);
      }
      let x = args.EchelonExtensionType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_EchelonExtensionType(x);
      builder.add_ShowSkillCard(args.ShowSkillCard);
      builder.add_UseBossAIPhaseSync(args.UseBossAIPhaseSync);
      builder.add_UseBossIndex(args.UseBossIndex);
      builder.add_FloorListSection(args.FloorListSection);
    builder.finish()
  }

  pub fn unpack(&self) -> MultiFloorRaidStageExcelT {
    let key = table_encryption_service::create_key(b"MultiFloorRaidStage");
      let Id = self.Id();
      let EchelonExtensionType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.EchelonExtensionType(), &key)
      } else {
        self.EchelonExtensionType()
      };
    let BossGroupId = self.BossGroupId().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let AssistSlot = self.AssistSlot();
      let StageOpenCondition = self.StageOpenCondition();
      let FloorListSection = self.FloorListSection();
      let FloorListSectionOpenCondition = self.FloorListSectionOpenCondition();
      let FloorListSectionLabel = self.FloorListSectionLabel();
      let Difficulty = self.Difficulty();
      let UseBossIndex = self.UseBossIndex();
      let UseBossAIPhaseSync = self.UseBossAIPhaseSync();
    let FloorListImgPath = self.FloorListImgPath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let FloorImgPath = self.FloorImgPath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let RaidCharacterId = self.RaidCharacterId();
    let BossCharacterId = self.BossCharacterId().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_long(*val, &key) } else { *val }).collect()
    });
    let StatChangeId = self.StatChangeId().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_long(*val, &key) } else { *val }).collect()
    });
      let BattleDuration = self.BattleDuration();
      let GroundId = self.GroundId();
      let RecommendLevel = self.RecommendLevel();
      let RewardGroupId = self.RewardGroupId();
    let BattleReadyTimelinePath = self.BattleReadyTimelinePath().map(|x| {
      x.iter().map(|s| if table_encryption_service::use_encryption() { table_encryption_service::convert_string(s, &key).unwrap() } else { s.to_string() }).collect()
    });
    let BattleReadyTimelinePhaseStart = self.BattleReadyTimelinePhaseStart().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_int(*val, &key) } else { *val }).collect()
    });
    let BattleReadyTimelinePhaseEnd = self.BattleReadyTimelinePhaseEnd().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_int(*val, &key) } else { *val }).collect()
    });
    let VictoryTimelinePath = self.VictoryTimelinePath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let ShowSkillCard = self.ShowSkillCard();
    MultiFloorRaidStageExcelT {
      Id,
      EchelonExtensionType,
      BossGroupId,
      AssistSlot,
      StageOpenCondition,
      FloorListSection,
      FloorListSectionOpenCondition,
      FloorListSectionLabel,
      Difficulty,
      UseBossIndex,
      UseBossAIPhaseSync,
      FloorListImgPath,
      FloorImgPath,
      RaidCharacterId,
      BossCharacterId,
      StatChangeId,
      BattleDuration,
      GroundId,
      RecommendLevel,
      RewardGroupId,
      BattleReadyTimelinePath,
      BattleReadyTimelinePhaseStart,
      BattleReadyTimelinePhaseEnd,
      VictoryTimelinePath,
      ShowSkillCard,
    }
  }

  #[inline]
  pub fn Id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MultiFloorRaidStageExcel::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EchelonExtensionType(&self) -> EchelonExtensionType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<EchelonExtensionType>(MultiFloorRaidStageExcel::VT_ECHELONEXTENSIONTYPE, Some(EchelonExtensionType::Base)).unwrap()}
  }
  #[inline]
  pub fn BossGroupId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MultiFloorRaidStageExcel::VT_BOSSGROUPID, None)}
  }
  #[inline]
  pub fn AssistSlot(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MultiFloorRaidStageExcel::VT_ASSISTSLOT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn StageOpenCondition(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MultiFloorRaidStageExcel::VT_STAGEOPENCONDITION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn FloorListSection(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(MultiFloorRaidStageExcel::VT_FLOORLISTSECTION, Some(false)).unwrap()}
  }
  #[inline]
  pub fn FloorListSectionOpenCondition(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MultiFloorRaidStageExcel::VT_FLOORLISTSECTIONOPENCONDITION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn FloorListSectionLabel(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(MultiFloorRaidStageExcel::VT_FLOORLISTSECTIONLABEL, Some(0)).unwrap()}
  }
  #[inline]
  pub fn Difficulty(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MultiFloorRaidStageExcel::VT_DIFFICULTY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn UseBossIndex(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(MultiFloorRaidStageExcel::VT_USEBOSSINDEX, Some(false)).unwrap()}
  }
  #[inline]
  pub fn UseBossAIPhaseSync(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(MultiFloorRaidStageExcel::VT_USEBOSSAIPHASESYNC, Some(false)).unwrap()}
  }
  #[inline]
  pub fn FloorListImgPath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MultiFloorRaidStageExcel::VT_FLOORLISTIMGPATH, None)}
  }
  #[inline]
  pub fn FloorImgPath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MultiFloorRaidStageExcel::VT_FLOORIMGPATH, None)}
  }
  #[inline]
  pub fn RaidCharacterId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MultiFloorRaidStageExcel::VT_RAIDCHARACTERID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn BossCharacterId(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(MultiFloorRaidStageExcel::VT_BOSSCHARACTERID, None)}
  }
  #[inline]
  pub fn StatChangeId(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(MultiFloorRaidStageExcel::VT_STATCHANGEID, None)}
  }
  #[inline]
  pub fn BattleDuration(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MultiFloorRaidStageExcel::VT_BATTLEDURATION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn GroundId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MultiFloorRaidStageExcel::VT_GROUNDID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn RecommendLevel(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MultiFloorRaidStageExcel::VT_RECOMMENDLEVEL, Some(0)).unwrap()}
  }
  #[inline]
  pub fn RewardGroupId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MultiFloorRaidStageExcel::VT_REWARDGROUPID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn BattleReadyTimelinePath(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(MultiFloorRaidStageExcel::VT_BATTLEREADYTIMELINEPATH, None)}
  }
  #[inline]
  pub fn BattleReadyTimelinePhaseStart(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(MultiFloorRaidStageExcel::VT_BATTLEREADYTIMELINEPHASESTART, None)}
  }
  #[inline]
  pub fn BattleReadyTimelinePhaseEnd(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(MultiFloorRaidStageExcel::VT_BATTLEREADYTIMELINEPHASEEND, None)}
  }
  #[inline]
  pub fn VictoryTimelinePath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MultiFloorRaidStageExcel::VT_VICTORYTIMELINEPATH, None)}
  }
  #[inline]
  pub fn ShowSkillCard(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(MultiFloorRaidStageExcel::VT_SHOWSKILLCARD, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for MultiFloorRaidStageExcel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("Id", Self::VT_ID, false)?
     .visit_field::<EchelonExtensionType>("EchelonExtensionType", Self::VT_ECHELONEXTENSIONTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("BossGroupId", Self::VT_BOSSGROUPID, false)?
     .visit_field::<i32>("AssistSlot", Self::VT_ASSISTSLOT, false)?
     .visit_field::<i64>("StageOpenCondition", Self::VT_STAGEOPENCONDITION, false)?
     .visit_field::<bool>("FloorListSection", Self::VT_FLOORLISTSECTION, false)?
     .visit_field::<i64>("FloorListSectionOpenCondition", Self::VT_FLOORLISTSECTIONOPENCONDITION, false)?
     .visit_field::<u32>("FloorListSectionLabel", Self::VT_FLOORLISTSECTIONLABEL, false)?
     .visit_field::<i32>("Difficulty", Self::VT_DIFFICULTY, false)?
     .visit_field::<bool>("UseBossIndex", Self::VT_USEBOSSINDEX, false)?
     .visit_field::<bool>("UseBossAIPhaseSync", Self::VT_USEBOSSAIPHASESYNC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("FloorListImgPath", Self::VT_FLOORLISTIMGPATH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("FloorImgPath", Self::VT_FLOORIMGPATH, false)?
     .visit_field::<i64>("RaidCharacterId", Self::VT_RAIDCHARACTERID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("BossCharacterId", Self::VT_BOSSCHARACTERID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("StatChangeId", Self::VT_STATCHANGEID, false)?
     .visit_field::<i64>("BattleDuration", Self::VT_BATTLEDURATION, false)?
     .visit_field::<i64>("GroundId", Self::VT_GROUNDID, false)?
     .visit_field::<i64>("RecommendLevel", Self::VT_RECOMMENDLEVEL, false)?
     .visit_field::<i64>("RewardGroupId", Self::VT_REWARDGROUPID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("BattleReadyTimelinePath", Self::VT_BATTLEREADYTIMELINEPATH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("BattleReadyTimelinePhaseStart", Self::VT_BATTLEREADYTIMELINEPHASESTART, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("BattleReadyTimelinePhaseEnd", Self::VT_BATTLEREADYTIMELINEPHASEEND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("VictoryTimelinePath", Self::VT_VICTORYTIMELINEPATH, false)?
     .visit_field::<bool>("ShowSkillCard", Self::VT_SHOWSKILLCARD, false)?
     .finish();
    Ok(())
  }
}
pub struct MultiFloorRaidStageExcelArgs<'a> {
    pub Id: i64,
    pub EchelonExtensionType: EchelonExtensionType,
    pub BossGroupId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub AssistSlot: i32,
    pub StageOpenCondition: i64,
    pub FloorListSection: bool,
    pub FloorListSectionOpenCondition: i64,
    pub FloorListSectionLabel: u32,
    pub Difficulty: i32,
    pub UseBossIndex: bool,
    pub UseBossAIPhaseSync: bool,
    pub FloorListImgPath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub FloorImgPath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub RaidCharacterId: i64,
    pub BossCharacterId: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub StatChangeId: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub BattleDuration: i64,
    pub GroundId: i64,
    pub RecommendLevel: i64,
    pub RewardGroupId: i64,
    pub BattleReadyTimelinePath: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub BattleReadyTimelinePhaseStart: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub BattleReadyTimelinePhaseEnd: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub VictoryTimelinePath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ShowSkillCard: bool,
}
impl<'a> Default for MultiFloorRaidStageExcelArgs<'a> {
  #[inline]
  fn default() -> Self {
    MultiFloorRaidStageExcelArgs {
      Id: 0,
      EchelonExtensionType: EchelonExtensionType::Base,
      BossGroupId: None,
      AssistSlot: 0,
      StageOpenCondition: 0,
      FloorListSection: false,
      FloorListSectionOpenCondition: 0,
      FloorListSectionLabel: 0,
      Difficulty: 0,
      UseBossIndex: false,
      UseBossAIPhaseSync: false,
      FloorListImgPath: None,
      FloorImgPath: None,
      RaidCharacterId: 0,
      BossCharacterId: None,
      StatChangeId: None,
      BattleDuration: 0,
      GroundId: 0,
      RecommendLevel: 0,
      RewardGroupId: 0,
      BattleReadyTimelinePath: None,
      BattleReadyTimelinePhaseStart: None,
      BattleReadyTimelinePhaseEnd: None,
      VictoryTimelinePath: None,
      ShowSkillCard: false,
    }
  }
}

impl Serialize for MultiFloorRaidStageExcel<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("MultiFloorRaidStageExcel", 25)?;
      s.serialize_field("Id", &self.Id())?;
      s.serialize_field("EchelonExtensionType", &self.EchelonExtensionType())?;
      if let Some(f) = self.BossGroupId() {
        s.serialize_field("BossGroupId", &f)?;
      } else {
        s.skip_field("BossGroupId")?;
      }
      s.serialize_field("AssistSlot", &self.AssistSlot())?;
      s.serialize_field("StageOpenCondition", &self.StageOpenCondition())?;
      s.serialize_field("FloorListSection", &self.FloorListSection())?;
      s.serialize_field("FloorListSectionOpenCondition", &self.FloorListSectionOpenCondition())?;
      s.serialize_field("FloorListSectionLabel", &self.FloorListSectionLabel())?;
      s.serialize_field("Difficulty", &self.Difficulty())?;
      s.serialize_field("UseBossIndex", &self.UseBossIndex())?;
      s.serialize_field("UseBossAIPhaseSync", &self.UseBossAIPhaseSync())?;
      if let Some(f) = self.FloorListImgPath() {
        s.serialize_field("FloorListImgPath", &f)?;
      } else {
        s.skip_field("FloorListImgPath")?;
      }
      if let Some(f) = self.FloorImgPath() {
        s.serialize_field("FloorImgPath", &f)?;
      } else {
        s.skip_field("FloorImgPath")?;
      }
      s.serialize_field("RaidCharacterId", &self.RaidCharacterId())?;
      if let Some(f) = self.BossCharacterId() {
        s.serialize_field("BossCharacterId", &f)?;
      } else {
        s.skip_field("BossCharacterId")?;
      }
      if let Some(f) = self.StatChangeId() {
        s.serialize_field("StatChangeId", &f)?;
      } else {
        s.skip_field("StatChangeId")?;
      }
      s.serialize_field("BattleDuration", &self.BattleDuration())?;
      s.serialize_field("GroundId", &self.GroundId())?;
      s.serialize_field("RecommendLevel", &self.RecommendLevel())?;
      s.serialize_field("RewardGroupId", &self.RewardGroupId())?;
      if let Some(f) = self.BattleReadyTimelinePath() {
        s.serialize_field("BattleReadyTimelinePath", &f)?;
      } else {
        s.skip_field("BattleReadyTimelinePath")?;
      }
      if let Some(f) = self.BattleReadyTimelinePhaseStart() {
        s.serialize_field("BattleReadyTimelinePhaseStart", &f)?;
      } else {
        s.skip_field("BattleReadyTimelinePhaseStart")?;
      }
      if let Some(f) = self.BattleReadyTimelinePhaseEnd() {
        s.serialize_field("BattleReadyTimelinePhaseEnd", &f)?;
      } else {
        s.skip_field("BattleReadyTimelinePhaseEnd")?;
      }
      if let Some(f) = self.VictoryTimelinePath() {
        s.serialize_field("VictoryTimelinePath", &f)?;
      } else {
        s.skip_field("VictoryTimelinePath")?;
      }
      s.serialize_field("ShowSkillCard", &self.ShowSkillCard())?;
    s.end()
  }
}

pub struct MultiFloorRaidStageExcelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MultiFloorRaidStageExcelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_Id(&mut self, Id: i64) {
    self.fbb_.push_slot::<i64>(MultiFloorRaidStageExcel::VT_ID, Id, 0);
  }
  #[inline]
  pub fn add_EchelonExtensionType(&mut self, EchelonExtensionType: EchelonExtensionType) {
    self.fbb_.push_slot::<EchelonExtensionType>(MultiFloorRaidStageExcel::VT_ECHELONEXTENSIONTYPE, EchelonExtensionType, EchelonExtensionType::Base);
  }
  #[inline]
  pub fn add_BossGroupId(&mut self, BossGroupId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MultiFloorRaidStageExcel::VT_BOSSGROUPID, BossGroupId);
  }
  #[inline]
  pub fn add_AssistSlot(&mut self, AssistSlot: i32) {
    self.fbb_.push_slot::<i32>(MultiFloorRaidStageExcel::VT_ASSISTSLOT, AssistSlot, 0);
  }
  #[inline]
  pub fn add_StageOpenCondition(&mut self, StageOpenCondition: i64) {
    self.fbb_.push_slot::<i64>(MultiFloorRaidStageExcel::VT_STAGEOPENCONDITION, StageOpenCondition, 0);
  }
  #[inline]
  pub fn add_FloorListSection(&mut self, FloorListSection: bool) {
    self.fbb_.push_slot::<bool>(MultiFloorRaidStageExcel::VT_FLOORLISTSECTION, FloorListSection, false);
  }
  #[inline]
  pub fn add_FloorListSectionOpenCondition(&mut self, FloorListSectionOpenCondition: i64) {
    self.fbb_.push_slot::<i64>(MultiFloorRaidStageExcel::VT_FLOORLISTSECTIONOPENCONDITION, FloorListSectionOpenCondition, 0);
  }
  #[inline]
  pub fn add_FloorListSectionLabel(&mut self, FloorListSectionLabel: u32) {
    self.fbb_.push_slot::<u32>(MultiFloorRaidStageExcel::VT_FLOORLISTSECTIONLABEL, FloorListSectionLabel, 0);
  }
  #[inline]
  pub fn add_Difficulty(&mut self, Difficulty: i32) {
    self.fbb_.push_slot::<i32>(MultiFloorRaidStageExcel::VT_DIFFICULTY, Difficulty, 0);
  }
  #[inline]
  pub fn add_UseBossIndex(&mut self, UseBossIndex: bool) {
    self.fbb_.push_slot::<bool>(MultiFloorRaidStageExcel::VT_USEBOSSINDEX, UseBossIndex, false);
  }
  #[inline]
  pub fn add_UseBossAIPhaseSync(&mut self, UseBossAIPhaseSync: bool) {
    self.fbb_.push_slot::<bool>(MultiFloorRaidStageExcel::VT_USEBOSSAIPHASESYNC, UseBossAIPhaseSync, false);
  }
  #[inline]
  pub fn add_FloorListImgPath(&mut self, FloorListImgPath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MultiFloorRaidStageExcel::VT_FLOORLISTIMGPATH, FloorListImgPath);
  }
  #[inline]
  pub fn add_FloorImgPath(&mut self, FloorImgPath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MultiFloorRaidStageExcel::VT_FLOORIMGPATH, FloorImgPath);
  }
  #[inline]
  pub fn add_RaidCharacterId(&mut self, RaidCharacterId: i64) {
    self.fbb_.push_slot::<i64>(MultiFloorRaidStageExcel::VT_RAIDCHARACTERID, RaidCharacterId, 0);
  }
  #[inline]
  pub fn add_BossCharacterId(&mut self, BossCharacterId: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MultiFloorRaidStageExcel::VT_BOSSCHARACTERID, BossCharacterId);
  }
  #[inline]
  pub fn add_StatChangeId(&mut self, StatChangeId: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MultiFloorRaidStageExcel::VT_STATCHANGEID, StatChangeId);
  }
  #[inline]
  pub fn add_BattleDuration(&mut self, BattleDuration: i64) {
    self.fbb_.push_slot::<i64>(MultiFloorRaidStageExcel::VT_BATTLEDURATION, BattleDuration, 0);
  }
  #[inline]
  pub fn add_GroundId(&mut self, GroundId: i64) {
    self.fbb_.push_slot::<i64>(MultiFloorRaidStageExcel::VT_GROUNDID, GroundId, 0);
  }
  #[inline]
  pub fn add_RecommendLevel(&mut self, RecommendLevel: i64) {
    self.fbb_.push_slot::<i64>(MultiFloorRaidStageExcel::VT_RECOMMENDLEVEL, RecommendLevel, 0);
  }
  #[inline]
  pub fn add_RewardGroupId(&mut self, RewardGroupId: i64) {
    self.fbb_.push_slot::<i64>(MultiFloorRaidStageExcel::VT_REWARDGROUPID, RewardGroupId, 0);
  }
  #[inline]
  pub fn add_BattleReadyTimelinePath(&mut self, BattleReadyTimelinePath: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MultiFloorRaidStageExcel::VT_BATTLEREADYTIMELINEPATH, BattleReadyTimelinePath);
  }
  #[inline]
  pub fn add_BattleReadyTimelinePhaseStart(&mut self, BattleReadyTimelinePhaseStart: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MultiFloorRaidStageExcel::VT_BATTLEREADYTIMELINEPHASESTART, BattleReadyTimelinePhaseStart);
  }
  #[inline]
  pub fn add_BattleReadyTimelinePhaseEnd(&mut self, BattleReadyTimelinePhaseEnd: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MultiFloorRaidStageExcel::VT_BATTLEREADYTIMELINEPHASEEND, BattleReadyTimelinePhaseEnd);
  }
  #[inline]
  pub fn add_VictoryTimelinePath(&mut self, VictoryTimelinePath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MultiFloorRaidStageExcel::VT_VICTORYTIMELINEPATH, VictoryTimelinePath);
  }
  #[inline]
  pub fn add_ShowSkillCard(&mut self, ShowSkillCard: bool) {
    self.fbb_.push_slot::<bool>(MultiFloorRaidStageExcel::VT_SHOWSKILLCARD, ShowSkillCard, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MultiFloorRaidStageExcelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MultiFloorRaidStageExcelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MultiFloorRaidStageExcel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MultiFloorRaidStageExcel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MultiFloorRaidStageExcel");
      ds.field("Id", &self.Id());
      ds.field("EchelonExtensionType", &self.EchelonExtensionType());
      ds.field("BossGroupId", &self.BossGroupId());
      ds.field("AssistSlot", &self.AssistSlot());
      ds.field("StageOpenCondition", &self.StageOpenCondition());
      ds.field("FloorListSection", &self.FloorListSection());
      ds.field("FloorListSectionOpenCondition", &self.FloorListSectionOpenCondition());
      ds.field("FloorListSectionLabel", &self.FloorListSectionLabel());
      ds.field("Difficulty", &self.Difficulty());
      ds.field("UseBossIndex", &self.UseBossIndex());
      ds.field("UseBossAIPhaseSync", &self.UseBossAIPhaseSync());
      ds.field("FloorListImgPath", &self.FloorListImgPath());
      ds.field("FloorImgPath", &self.FloorImgPath());
      ds.field("RaidCharacterId", &self.RaidCharacterId());
      ds.field("BossCharacterId", &self.BossCharacterId());
      ds.field("StatChangeId", &self.StatChangeId());
      ds.field("BattleDuration", &self.BattleDuration());
      ds.field("GroundId", &self.GroundId());
      ds.field("RecommendLevel", &self.RecommendLevel());
      ds.field("RewardGroupId", &self.RewardGroupId());
      ds.field("BattleReadyTimelinePath", &self.BattleReadyTimelinePath());
      ds.field("BattleReadyTimelinePhaseStart", &self.BattleReadyTimelinePhaseStart());
      ds.field("BattleReadyTimelinePhaseEnd", &self.BattleReadyTimelinePhaseEnd());
      ds.field("VictoryTimelinePath", &self.VictoryTimelinePath());
      ds.field("ShowSkillCard", &self.ShowSkillCard());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MultiFloorRaidStageExcelT {
  pub Id: i64,
  pub EchelonExtensionType: EchelonExtensionType,
  pub BossGroupId: Option<String>,
  pub AssistSlot: i32,
  pub StageOpenCondition: i64,
  pub FloorListSection: bool,
  pub FloorListSectionOpenCondition: i64,
  pub FloorListSectionLabel: u32,
  pub Difficulty: i32,
  pub UseBossIndex: bool,
  pub UseBossAIPhaseSync: bool,
  pub FloorListImgPath: Option<String>,
  pub FloorImgPath: Option<String>,
  pub RaidCharacterId: i64,
  pub BossCharacterId: Option<Vec<i64>>,
  pub StatChangeId: Option<Vec<i64>>,
  pub BattleDuration: i64,
  pub GroundId: i64,
  pub RecommendLevel: i64,
  pub RewardGroupId: i64,
  pub BattleReadyTimelinePath: Option<Vec<String>>,
  pub BattleReadyTimelinePhaseStart: Option<Vec<i32>>,
  pub BattleReadyTimelinePhaseEnd: Option<Vec<i32>>,
  pub VictoryTimelinePath: Option<String>,
  pub ShowSkillCard: bool,
}
impl Default for MultiFloorRaidStageExcelT {
  fn default() -> Self {
    Self {
      Id: 0,
      EchelonExtensionType: EchelonExtensionType::Base,
      BossGroupId: None,
      AssistSlot: 0,
      StageOpenCondition: 0,
      FloorListSection: false,
      FloorListSectionOpenCondition: 0,
      FloorListSectionLabel: 0,
      Difficulty: 0,
      UseBossIndex: false,
      UseBossAIPhaseSync: false,
      FloorListImgPath: None,
      FloorImgPath: None,
      RaidCharacterId: 0,
      BossCharacterId: None,
      StatChangeId: None,
      BattleDuration: 0,
      GroundId: 0,
      RecommendLevel: 0,
      RewardGroupId: 0,
      BattleReadyTimelinePath: None,
      BattleReadyTimelinePhaseStart: None,
      BattleReadyTimelinePhaseEnd: None,
      VictoryTimelinePath: None,
      ShowSkillCard: false,
    }
  }
}
impl MultiFloorRaidStageExcelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<MultiFloorRaidStageExcel<'b>> {
    let Id = self.Id;
    let EchelonExtensionType = self.EchelonExtensionType;
    let BossGroupId = self.BossGroupId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let AssistSlot = self.AssistSlot;
    let StageOpenCondition = self.StageOpenCondition;
    let FloorListSection = self.FloorListSection;
    let FloorListSectionOpenCondition = self.FloorListSectionOpenCondition;
    let FloorListSectionLabel = self.FloorListSectionLabel;
    let Difficulty = self.Difficulty;
    let UseBossIndex = self.UseBossIndex;
    let UseBossAIPhaseSync = self.UseBossAIPhaseSync;
    let FloorListImgPath = self.FloorListImgPath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let FloorImgPath = self.FloorImgPath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let RaidCharacterId = self.RaidCharacterId;
    let BossCharacterId = self.BossCharacterId.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let StatChangeId = self.StatChangeId.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let BattleDuration = self.BattleDuration;
    let GroundId = self.GroundId;
    let RecommendLevel = self.RecommendLevel;
    let RewardGroupId = self.RewardGroupId;
    let BattleReadyTimelinePath = self.BattleReadyTimelinePath.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let BattleReadyTimelinePhaseStart = self.BattleReadyTimelinePhaseStart.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let BattleReadyTimelinePhaseEnd = self.BattleReadyTimelinePhaseEnd.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let VictoryTimelinePath = self.VictoryTimelinePath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ShowSkillCard = self.ShowSkillCard;
    MultiFloorRaidStageExcel::create(_fbb, &MultiFloorRaidStageExcelArgs{
      Id,
      EchelonExtensionType,
      BossGroupId,
      AssistSlot,
      StageOpenCondition,
      FloorListSection,
      FloorListSectionOpenCondition,
      FloorListSectionLabel,
      Difficulty,
      UseBossIndex,
      UseBossAIPhaseSync,
      FloorListImgPath,
      FloorImgPath,
      RaidCharacterId,
      BossCharacterId,
      StatChangeId,
      BattleDuration,
      GroundId,
      RecommendLevel,
      RewardGroupId,
      BattleReadyTimelinePath,
      BattleReadyTimelinePhaseStart,
      BattleReadyTimelinePhaseEnd,
      VictoryTimelinePath,
      ShowSkillCard,
    })
  }
}
