// automatically generated by the FlatBuffers compiler, do not modify
// @generated
#![allow(unused_imports, dead_code)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum CharacterSkillListExcelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CharacterSkillListExcel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CharacterSkillListExcel<'a> {
  type Inner = CharacterSkillListExcel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CharacterSkillListExcel<'a> {
  pub const VT_CHARACTERSKILLLISTGROUPID: flatbuffers::VOffsetT = 4;
  pub const VT_MINIMUMGRADECHARACTERWEAPON: flatbuffers::VOffsetT = 6;
  pub const VT_MINIMUMTIERCHARACTERGEAR: flatbuffers::VOffsetT = 8;
  pub const VT_FORMINDEX: flatbuffers::VOffsetT = 10;
  pub const VT_ISROOTMOTION: flatbuffers::VOffsetT = 12;
  pub const VT_ISMOVELEFTRIGHT: flatbuffers::VOffsetT = 14;
  pub const VT_USERANDOMEXSKILLTIMELINE: flatbuffers::VOffsetT = 16;
  pub const VT_TSAINTERACTIONID: flatbuffers::VOffsetT = 18;
  pub const VT_NORMALSKILLGROUPID: flatbuffers::VOffsetT = 20;
  pub const VT_NORMALSKILLTIMELINEINDEX: flatbuffers::VOffsetT = 22;
  pub const VT_SELECTEXSKILLACTIONSKILLSLOT: flatbuffers::VOffsetT = 24;
  pub const VT_EXSKILLGROUPID: flatbuffers::VOffsetT = 26;
  pub const VT_EXSKILLCUTINTIMELINEINDEX: flatbuffers::VOffsetT = 28;
  pub const VT_EXSKILLLEVELTIMELINEINDEX: flatbuffers::VOffsetT = 30;
  pub const VT_PUBLICSKILLGROUPID: flatbuffers::VOffsetT = 32;
  pub const VT_PUBLICSKILLTIMELINEINDEX: flatbuffers::VOffsetT = 34;
  pub const VT_PASSIVESKILLGROUPID: flatbuffers::VOffsetT = 36;
  pub const VT_LEADERSKILLGROUPID: flatbuffers::VOffsetT = 38;
  pub const VT_EXTRAPASSIVESKILLGROUPID: flatbuffers::VOffsetT = 40;
  pub const VT_HIDDENPASSIVESKILLGROUPID: flatbuffers::VOffsetT = 42;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CharacterSkillListExcel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CharacterSkillListExcelArgs<'args>
  ) -> flatbuffers::WIPOffset<CharacterSkillListExcel<'bldr>> {
    let mut builder = CharacterSkillListExcelBuilder::new(_fbb);
    let key = table_encryption_service::create_key(b"CharacterSkillList");
      let x = args.TSAInteractionId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_TSAInteractionId(x);
      let x = args.CharacterSkillListGroupId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_CharacterSkillListGroupId(x);
      if let Some(x) = args.hiddenPassiveSkillGroupId {
        builder.add_hiddenPassiveSkillGroupId(x);
      }
      if let Some(x) = args.extraPassiveSkillGroupId {
        builder.add_extraPassiveSkillGroupId(x);
      }
      if let Some(x) = args.leaderSkillGroupId {
        builder.add_leaderSkillGroupId(x);
      }
      if let Some(x) = args.passiveSkillGroupId {
        builder.add_passiveSkillGroupId(x);
      }
      if let Some(x) = args.publicSkillTimeLineIndex {
        builder.add_publicSkillTimeLineIndex(x);
      }
      if let Some(x) = args.publicSkillGroupId {
        builder.add_publicSkillGroupId(x);
      }
      if let Some(x) = args.exSkillLevelTimeLineIndex {
        builder.add_exSkillLevelTimeLineIndex(x);
      }
      if let Some(x) = args.exSkillCutInTimeLineIndex {
        builder.add_exSkillCutInTimeLineIndex(x);
      }
      if let Some(x) = args.exSkillGroupId {
        builder.add_exSkillGroupId(x);
      }
      let x = args.SelectExSkillActionSkillSlot;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_SelectExSkillActionSkillSlot(x);
      if let Some(x) = args.normalSkillTimeLineIndex {
        builder.add_normalSkillTimeLineIndex(x);
      }
      if let Some(x) = args.normalSkillGroupId {
        builder.add_normalSkillGroupId(x);
      }
      let x = args.FormIndex;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_FormIndex(x);
      let x = args.MinimumTierCharacterGear;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_MinimumTierCharacterGear(x);
      let x = args.MinimumGradeCharacterWeapon;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_MinimumGradeCharacterWeapon(x);
      builder.add_UseRandomExSkillTimeline(args.UseRandomExSkillTimeline);
      builder.add_IsMoveLeftRight(args.IsMoveLeftRight);
      builder.add_IsRootMotion(args.IsRootMotion);
    builder.finish()
  }

  pub fn unpack(&self) -> CharacterSkillListExcelT {
    let key = table_encryption_service::create_key(b"CharacterSkillList");
      let CharacterSkillListGroupId = self.CharacterSkillListGroupId();
      let MinimumGradeCharacterWeapon = self.MinimumGradeCharacterWeapon();
      let MinimumTierCharacterGear = self.MinimumTierCharacterGear();
      let FormIndex = self.FormIndex();
      let IsRootMotion = self.IsRootMotion();
      let IsMoveLeftRight = self.IsMoveLeftRight();
      let UseRandomExSkillTimeline = self.UseRandomExSkillTimeline();
      let TSAInteractionId = self.TSAInteractionId();
    let normalSkillGroupId = self.normalSkillGroupId().map(|x| {
      x.iter().map(|s| if table_encryption_service::use_encryption() { table_encryption_service::convert_string(s, &key).unwrap() } else { s.to_string() }).collect()
    });
    let normalSkillTimeLineIndex = self.normalSkillTimeLineIndex().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_int(*val, &key) } else { *val }).collect()
    });
      let SelectExSkillActionSkillSlot = self.SelectExSkillActionSkillSlot();
    let exSkillGroupId = self.exSkillGroupId().map(|x| {
      x.iter().map(|s| if table_encryption_service::use_encryption() { table_encryption_service::convert_string(s, &key).unwrap() } else { s.to_string() }).collect()
    });
    let exSkillCutInTimeLineIndex = self.exSkillCutInTimeLineIndex().map(|x| {
      x.iter().map(|s| if table_encryption_service::use_encryption() { table_encryption_service::convert_string(s, &key).unwrap() } else { s.to_string() }).collect()
    });
    let exSkillLevelTimeLineIndex = self.exSkillLevelTimeLineIndex().map(|x| {
      x.iter().map(|s| if table_encryption_service::use_encryption() { table_encryption_service::convert_string(s, &key).unwrap() } else { s.to_string() }).collect()
    });
    let publicSkillGroupId = self.publicSkillGroupId().map(|x| {
      x.iter().map(|s| if table_encryption_service::use_encryption() { table_encryption_service::convert_string(s, &key).unwrap() } else { s.to_string() }).collect()
    });
    let publicSkillTimeLineIndex = self.publicSkillTimeLineIndex().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_int(*val, &key) } else { *val }).collect()
    });
    let passiveSkillGroupId = self.passiveSkillGroupId().map(|x| {
      x.iter().map(|s| if table_encryption_service::use_encryption() { table_encryption_service::convert_string(s, &key).unwrap() } else { s.to_string() }).collect()
    });
    let leaderSkillGroupId = self.leaderSkillGroupId().map(|x| {
      x.iter().map(|s| if table_encryption_service::use_encryption() { table_encryption_service::convert_string(s, &key).unwrap() } else { s.to_string() }).collect()
    });
    let extraPassiveSkillGroupId = self.extraPassiveSkillGroupId().map(|x| {
      x.iter().map(|s| if table_encryption_service::use_encryption() { table_encryption_service::convert_string(s, &key).unwrap() } else { s.to_string() }).collect()
    });
    let hiddenPassiveSkillGroupId = self.hiddenPassiveSkillGroupId().map(|x| {
      x.iter().map(|s| if table_encryption_service::use_encryption() { table_encryption_service::convert_string(s, &key).unwrap() } else { s.to_string() }).collect()
    });
    CharacterSkillListExcelT {
      CharacterSkillListGroupId,
      MinimumGradeCharacterWeapon,
      MinimumTierCharacterGear,
      FormIndex,
      IsRootMotion,
      IsMoveLeftRight,
      UseRandomExSkillTimeline,
      TSAInteractionId,
      normalSkillGroupId,
      normalSkillTimeLineIndex,
      SelectExSkillActionSkillSlot,
      exSkillGroupId,
      exSkillCutInTimeLineIndex,
      exSkillLevelTimeLineIndex,
      publicSkillGroupId,
      publicSkillTimeLineIndex,
      passiveSkillGroupId,
      leaderSkillGroupId,
      extraPassiveSkillGroupId,
      hiddenPassiveSkillGroupId,
    }
  }

  #[inline]
  pub fn CharacterSkillListGroupId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CharacterSkillListExcel::VT_CHARACTERSKILLLISTGROUPID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn MinimumGradeCharacterWeapon(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CharacterSkillListExcel::VT_MINIMUMGRADECHARACTERWEAPON, Some(0)).unwrap()}
  }
  #[inline]
  pub fn MinimumTierCharacterGear(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CharacterSkillListExcel::VT_MINIMUMTIERCHARACTERGEAR, Some(0)).unwrap()}
  }
  #[inline]
  pub fn FormIndex(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CharacterSkillListExcel::VT_FORMINDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn IsRootMotion(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CharacterSkillListExcel::VT_ISROOTMOTION, Some(false)).unwrap()}
  }
  #[inline]
  pub fn IsMoveLeftRight(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CharacterSkillListExcel::VT_ISMOVELEFTRIGHT, Some(false)).unwrap()}
  }
  #[inline]
  pub fn UseRandomExSkillTimeline(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CharacterSkillListExcel::VT_USERANDOMEXSKILLTIMELINE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn TSAInteractionId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CharacterSkillListExcel::VT_TSAINTERACTIONID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn normalSkillGroupId(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(CharacterSkillListExcel::VT_NORMALSKILLGROUPID, None)}
  }
  #[inline]
  pub fn normalSkillTimeLineIndex(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(CharacterSkillListExcel::VT_NORMALSKILLTIMELINEINDEX, None)}
  }
  #[inline]
  pub fn SelectExSkillActionSkillSlot(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CharacterSkillListExcel::VT_SELECTEXSKILLACTIONSKILLSLOT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn exSkillGroupId(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(CharacterSkillListExcel::VT_EXSKILLGROUPID, None)}
  }
  #[inline]
  pub fn exSkillCutInTimeLineIndex(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(CharacterSkillListExcel::VT_EXSKILLCUTINTIMELINEINDEX, None)}
  }
  #[inline]
  pub fn exSkillLevelTimeLineIndex(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(CharacterSkillListExcel::VT_EXSKILLLEVELTIMELINEINDEX, None)}
  }
  #[inline]
  pub fn publicSkillGroupId(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(CharacterSkillListExcel::VT_PUBLICSKILLGROUPID, None)}
  }
  #[inline]
  pub fn publicSkillTimeLineIndex(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(CharacterSkillListExcel::VT_PUBLICSKILLTIMELINEINDEX, None)}
  }
  #[inline]
  pub fn passiveSkillGroupId(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(CharacterSkillListExcel::VT_PASSIVESKILLGROUPID, None)}
  }
  #[inline]
  pub fn leaderSkillGroupId(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(CharacterSkillListExcel::VT_LEADERSKILLGROUPID, None)}
  }
  #[inline]
  pub fn extraPassiveSkillGroupId(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(CharacterSkillListExcel::VT_EXTRAPASSIVESKILLGROUPID, None)}
  }
  #[inline]
  pub fn hiddenPassiveSkillGroupId(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(CharacterSkillListExcel::VT_HIDDENPASSIVESKILLGROUPID, None)}
  }
}

impl flatbuffers::Verifiable for CharacterSkillListExcel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("CharacterSkillListGroupId", Self::VT_CHARACTERSKILLLISTGROUPID, false)?
     .visit_field::<i32>("MinimumGradeCharacterWeapon", Self::VT_MINIMUMGRADECHARACTERWEAPON, false)?
     .visit_field::<i32>("MinimumTierCharacterGear", Self::VT_MINIMUMTIERCHARACTERGEAR, false)?
     .visit_field::<i32>("FormIndex", Self::VT_FORMINDEX, false)?
     .visit_field::<bool>("IsRootMotion", Self::VT_ISROOTMOTION, false)?
     .visit_field::<bool>("IsMoveLeftRight", Self::VT_ISMOVELEFTRIGHT, false)?
     .visit_field::<bool>("UseRandomExSkillTimeline", Self::VT_USERANDOMEXSKILLTIMELINE, false)?
     .visit_field::<i64>("TSAInteractionId", Self::VT_TSAINTERACTIONID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("normalSkillGroupId", Self::VT_NORMALSKILLGROUPID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("normalSkillTimeLineIndex", Self::VT_NORMALSKILLTIMELINEINDEX, false)?
     .visit_field::<i32>("SelectExSkillActionSkillSlot", Self::VT_SELECTEXSKILLACTIONSKILLSLOT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("exSkillGroupId", Self::VT_EXSKILLGROUPID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("exSkillCutInTimeLineIndex", Self::VT_EXSKILLCUTINTIMELINEINDEX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("exSkillLevelTimeLineIndex", Self::VT_EXSKILLLEVELTIMELINEINDEX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("publicSkillGroupId", Self::VT_PUBLICSKILLGROUPID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("publicSkillTimeLineIndex", Self::VT_PUBLICSKILLTIMELINEINDEX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("passiveSkillGroupId", Self::VT_PASSIVESKILLGROUPID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("leaderSkillGroupId", Self::VT_LEADERSKILLGROUPID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("extraPassiveSkillGroupId", Self::VT_EXTRAPASSIVESKILLGROUPID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("hiddenPassiveSkillGroupId", Self::VT_HIDDENPASSIVESKILLGROUPID, false)?
     .finish();
    Ok(())
  }
}
pub struct CharacterSkillListExcelArgs<'a> {
    pub CharacterSkillListGroupId: i64,
    pub MinimumGradeCharacterWeapon: i32,
    pub MinimumTierCharacterGear: i32,
    pub FormIndex: i32,
    pub IsRootMotion: bool,
    pub IsMoveLeftRight: bool,
    pub UseRandomExSkillTimeline: bool,
    pub TSAInteractionId: i64,
    pub normalSkillGroupId: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub normalSkillTimeLineIndex: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub SelectExSkillActionSkillSlot: i32,
    pub exSkillGroupId: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub exSkillCutInTimeLineIndex: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub exSkillLevelTimeLineIndex: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub publicSkillGroupId: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub publicSkillTimeLineIndex: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub passiveSkillGroupId: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub leaderSkillGroupId: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub extraPassiveSkillGroupId: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub hiddenPassiveSkillGroupId: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for CharacterSkillListExcelArgs<'a> {
  #[inline]
  fn default() -> Self {
    CharacterSkillListExcelArgs {
      CharacterSkillListGroupId: 0,
      MinimumGradeCharacterWeapon: 0,
      MinimumTierCharacterGear: 0,
      FormIndex: 0,
      IsRootMotion: false,
      IsMoveLeftRight: false,
      UseRandomExSkillTimeline: false,
      TSAInteractionId: 0,
      normalSkillGroupId: None,
      normalSkillTimeLineIndex: None,
      SelectExSkillActionSkillSlot: 0,
      exSkillGroupId: None,
      exSkillCutInTimeLineIndex: None,
      exSkillLevelTimeLineIndex: None,
      publicSkillGroupId: None,
      publicSkillTimeLineIndex: None,
      passiveSkillGroupId: None,
      leaderSkillGroupId: None,
      extraPassiveSkillGroupId: None,
      hiddenPassiveSkillGroupId: None,
    }
  }
}

impl Serialize for CharacterSkillListExcel<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("CharacterSkillListExcel", 20)?;
      s.serialize_field("CharacterSkillListGroupId", &self.CharacterSkillListGroupId())?;
      s.serialize_field("MinimumGradeCharacterWeapon", &self.MinimumGradeCharacterWeapon())?;
      s.serialize_field("MinimumTierCharacterGear", &self.MinimumTierCharacterGear())?;
      s.serialize_field("FormIndex", &self.FormIndex())?;
      s.serialize_field("IsRootMotion", &self.IsRootMotion())?;
      s.serialize_field("IsMoveLeftRight", &self.IsMoveLeftRight())?;
      s.serialize_field("UseRandomExSkillTimeline", &self.UseRandomExSkillTimeline())?;
      s.serialize_field("TSAInteractionId", &self.TSAInteractionId())?;
      if let Some(f) = self.normalSkillGroupId() {
        s.serialize_field("normalSkillGroupId", &f)?;
      } else {
        s.skip_field("normalSkillGroupId")?;
      }
      if let Some(f) = self.normalSkillTimeLineIndex() {
        s.serialize_field("normalSkillTimeLineIndex", &f)?;
      } else {
        s.skip_field("normalSkillTimeLineIndex")?;
      }
      s.serialize_field("SelectExSkillActionSkillSlot", &self.SelectExSkillActionSkillSlot())?;
      if let Some(f) = self.exSkillGroupId() {
        s.serialize_field("exSkillGroupId", &f)?;
      } else {
        s.skip_field("exSkillGroupId")?;
      }
      if let Some(f) = self.exSkillCutInTimeLineIndex() {
        s.serialize_field("exSkillCutInTimeLineIndex", &f)?;
      } else {
        s.skip_field("exSkillCutInTimeLineIndex")?;
      }
      if let Some(f) = self.exSkillLevelTimeLineIndex() {
        s.serialize_field("exSkillLevelTimeLineIndex", &f)?;
      } else {
        s.skip_field("exSkillLevelTimeLineIndex")?;
      }
      if let Some(f) = self.publicSkillGroupId() {
        s.serialize_field("publicSkillGroupId", &f)?;
      } else {
        s.skip_field("publicSkillGroupId")?;
      }
      if let Some(f) = self.publicSkillTimeLineIndex() {
        s.serialize_field("publicSkillTimeLineIndex", &f)?;
      } else {
        s.skip_field("publicSkillTimeLineIndex")?;
      }
      if let Some(f) = self.passiveSkillGroupId() {
        s.serialize_field("passiveSkillGroupId", &f)?;
      } else {
        s.skip_field("passiveSkillGroupId")?;
      }
      if let Some(f) = self.leaderSkillGroupId() {
        s.serialize_field("leaderSkillGroupId", &f)?;
      } else {
        s.skip_field("leaderSkillGroupId")?;
      }
      if let Some(f) = self.extraPassiveSkillGroupId() {
        s.serialize_field("extraPassiveSkillGroupId", &f)?;
      } else {
        s.skip_field("extraPassiveSkillGroupId")?;
      }
      if let Some(f) = self.hiddenPassiveSkillGroupId() {
        s.serialize_field("hiddenPassiveSkillGroupId", &f)?;
      } else {
        s.skip_field("hiddenPassiveSkillGroupId")?;
      }
    s.end()
  }
}

pub struct CharacterSkillListExcelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CharacterSkillListExcelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_CharacterSkillListGroupId(&mut self, CharacterSkillListGroupId: i64) {
    self.fbb_.push_slot::<i64>(CharacterSkillListExcel::VT_CHARACTERSKILLLISTGROUPID, CharacterSkillListGroupId, 0);
  }
  #[inline]
  pub fn add_MinimumGradeCharacterWeapon(&mut self, MinimumGradeCharacterWeapon: i32) {
    self.fbb_.push_slot::<i32>(CharacterSkillListExcel::VT_MINIMUMGRADECHARACTERWEAPON, MinimumGradeCharacterWeapon, 0);
  }
  #[inline]
  pub fn add_MinimumTierCharacterGear(&mut self, MinimumTierCharacterGear: i32) {
    self.fbb_.push_slot::<i32>(CharacterSkillListExcel::VT_MINIMUMTIERCHARACTERGEAR, MinimumTierCharacterGear, 0);
  }
  #[inline]
  pub fn add_FormIndex(&mut self, FormIndex: i32) {
    self.fbb_.push_slot::<i32>(CharacterSkillListExcel::VT_FORMINDEX, FormIndex, 0);
  }
  #[inline]
  pub fn add_IsRootMotion(&mut self, IsRootMotion: bool) {
    self.fbb_.push_slot::<bool>(CharacterSkillListExcel::VT_ISROOTMOTION, IsRootMotion, false);
  }
  #[inline]
  pub fn add_IsMoveLeftRight(&mut self, IsMoveLeftRight: bool) {
    self.fbb_.push_slot::<bool>(CharacterSkillListExcel::VT_ISMOVELEFTRIGHT, IsMoveLeftRight, false);
  }
  #[inline]
  pub fn add_UseRandomExSkillTimeline(&mut self, UseRandomExSkillTimeline: bool) {
    self.fbb_.push_slot::<bool>(CharacterSkillListExcel::VT_USERANDOMEXSKILLTIMELINE, UseRandomExSkillTimeline, false);
  }
  #[inline]
  pub fn add_TSAInteractionId(&mut self, TSAInteractionId: i64) {
    self.fbb_.push_slot::<i64>(CharacterSkillListExcel::VT_TSAINTERACTIONID, TSAInteractionId, 0);
  }
  #[inline]
  pub fn add_normalSkillGroupId(&mut self, normalSkillGroupId: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CharacterSkillListExcel::VT_NORMALSKILLGROUPID, normalSkillGroupId);
  }
  #[inline]
  pub fn add_normalSkillTimeLineIndex(&mut self, normalSkillTimeLineIndex: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CharacterSkillListExcel::VT_NORMALSKILLTIMELINEINDEX, normalSkillTimeLineIndex);
  }
  #[inline]
  pub fn add_SelectExSkillActionSkillSlot(&mut self, SelectExSkillActionSkillSlot: i32) {
    self.fbb_.push_slot::<i32>(CharacterSkillListExcel::VT_SELECTEXSKILLACTIONSKILLSLOT, SelectExSkillActionSkillSlot, 0);
  }
  #[inline]
  pub fn add_exSkillGroupId(&mut self, exSkillGroupId: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CharacterSkillListExcel::VT_EXSKILLGROUPID, exSkillGroupId);
  }
  #[inline]
  pub fn add_exSkillCutInTimeLineIndex(&mut self, exSkillCutInTimeLineIndex: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CharacterSkillListExcel::VT_EXSKILLCUTINTIMELINEINDEX, exSkillCutInTimeLineIndex);
  }
  #[inline]
  pub fn add_exSkillLevelTimeLineIndex(&mut self, exSkillLevelTimeLineIndex: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CharacterSkillListExcel::VT_EXSKILLLEVELTIMELINEINDEX, exSkillLevelTimeLineIndex);
  }
  #[inline]
  pub fn add_publicSkillGroupId(&mut self, publicSkillGroupId: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CharacterSkillListExcel::VT_PUBLICSKILLGROUPID, publicSkillGroupId);
  }
  #[inline]
  pub fn add_publicSkillTimeLineIndex(&mut self, publicSkillTimeLineIndex: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CharacterSkillListExcel::VT_PUBLICSKILLTIMELINEINDEX, publicSkillTimeLineIndex);
  }
  #[inline]
  pub fn add_passiveSkillGroupId(&mut self, passiveSkillGroupId: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CharacterSkillListExcel::VT_PASSIVESKILLGROUPID, passiveSkillGroupId);
  }
  #[inline]
  pub fn add_leaderSkillGroupId(&mut self, leaderSkillGroupId: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CharacterSkillListExcel::VT_LEADERSKILLGROUPID, leaderSkillGroupId);
  }
  #[inline]
  pub fn add_extraPassiveSkillGroupId(&mut self, extraPassiveSkillGroupId: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CharacterSkillListExcel::VT_EXTRAPASSIVESKILLGROUPID, extraPassiveSkillGroupId);
  }
  #[inline]
  pub fn add_hiddenPassiveSkillGroupId(&mut self, hiddenPassiveSkillGroupId: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CharacterSkillListExcel::VT_HIDDENPASSIVESKILLGROUPID, hiddenPassiveSkillGroupId);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CharacterSkillListExcelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CharacterSkillListExcelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CharacterSkillListExcel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CharacterSkillListExcel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CharacterSkillListExcel");
      ds.field("CharacterSkillListGroupId", &self.CharacterSkillListGroupId());
      ds.field("MinimumGradeCharacterWeapon", &self.MinimumGradeCharacterWeapon());
      ds.field("MinimumTierCharacterGear", &self.MinimumTierCharacterGear());
      ds.field("FormIndex", &self.FormIndex());
      ds.field("IsRootMotion", &self.IsRootMotion());
      ds.field("IsMoveLeftRight", &self.IsMoveLeftRight());
      ds.field("UseRandomExSkillTimeline", &self.UseRandomExSkillTimeline());
      ds.field("TSAInteractionId", &self.TSAInteractionId());
      ds.field("normalSkillGroupId", &self.normalSkillGroupId());
      ds.field("normalSkillTimeLineIndex", &self.normalSkillTimeLineIndex());
      ds.field("SelectExSkillActionSkillSlot", &self.SelectExSkillActionSkillSlot());
      ds.field("exSkillGroupId", &self.exSkillGroupId());
      ds.field("exSkillCutInTimeLineIndex", &self.exSkillCutInTimeLineIndex());
      ds.field("exSkillLevelTimeLineIndex", &self.exSkillLevelTimeLineIndex());
      ds.field("publicSkillGroupId", &self.publicSkillGroupId());
      ds.field("publicSkillTimeLineIndex", &self.publicSkillTimeLineIndex());
      ds.field("passiveSkillGroupId", &self.passiveSkillGroupId());
      ds.field("leaderSkillGroupId", &self.leaderSkillGroupId());
      ds.field("extraPassiveSkillGroupId", &self.extraPassiveSkillGroupId());
      ds.field("hiddenPassiveSkillGroupId", &self.hiddenPassiveSkillGroupId());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CharacterSkillListExcelT {
  pub CharacterSkillListGroupId: i64,
  pub MinimumGradeCharacterWeapon: i32,
  pub MinimumTierCharacterGear: i32,
  pub FormIndex: i32,
  pub IsRootMotion: bool,
  pub IsMoveLeftRight: bool,
  pub UseRandomExSkillTimeline: bool,
  pub TSAInteractionId: i64,
  pub normalSkillGroupId: Option<Vec<String>>,
  pub normalSkillTimeLineIndex: Option<Vec<i32>>,
  pub SelectExSkillActionSkillSlot: i32,
  pub exSkillGroupId: Option<Vec<String>>,
  pub exSkillCutInTimeLineIndex: Option<Vec<String>>,
  pub exSkillLevelTimeLineIndex: Option<Vec<String>>,
  pub publicSkillGroupId: Option<Vec<String>>,
  pub publicSkillTimeLineIndex: Option<Vec<i32>>,
  pub passiveSkillGroupId: Option<Vec<String>>,
  pub leaderSkillGroupId: Option<Vec<String>>,
  pub extraPassiveSkillGroupId: Option<Vec<String>>,
  pub hiddenPassiveSkillGroupId: Option<Vec<String>>,
}
impl Default for CharacterSkillListExcelT {
  fn default() -> Self {
    Self {
      CharacterSkillListGroupId: 0,
      MinimumGradeCharacterWeapon: 0,
      MinimumTierCharacterGear: 0,
      FormIndex: 0,
      IsRootMotion: false,
      IsMoveLeftRight: false,
      UseRandomExSkillTimeline: false,
      TSAInteractionId: 0,
      normalSkillGroupId: None,
      normalSkillTimeLineIndex: None,
      SelectExSkillActionSkillSlot: 0,
      exSkillGroupId: None,
      exSkillCutInTimeLineIndex: None,
      exSkillLevelTimeLineIndex: None,
      publicSkillGroupId: None,
      publicSkillTimeLineIndex: None,
      passiveSkillGroupId: None,
      leaderSkillGroupId: None,
      extraPassiveSkillGroupId: None,
      hiddenPassiveSkillGroupId: None,
    }
  }
}
impl CharacterSkillListExcelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CharacterSkillListExcel<'b>> {
    let CharacterSkillListGroupId = self.CharacterSkillListGroupId;
    let MinimumGradeCharacterWeapon = self.MinimumGradeCharacterWeapon;
    let MinimumTierCharacterGear = self.MinimumTierCharacterGear;
    let FormIndex = self.FormIndex;
    let IsRootMotion = self.IsRootMotion;
    let IsMoveLeftRight = self.IsMoveLeftRight;
    let UseRandomExSkillTimeline = self.UseRandomExSkillTimeline;
    let TSAInteractionId = self.TSAInteractionId;
    let normalSkillGroupId = self.normalSkillGroupId.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let normalSkillTimeLineIndex = self.normalSkillTimeLineIndex.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let SelectExSkillActionSkillSlot = self.SelectExSkillActionSkillSlot;
    let exSkillGroupId = self.exSkillGroupId.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let exSkillCutInTimeLineIndex = self.exSkillCutInTimeLineIndex.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let exSkillLevelTimeLineIndex = self.exSkillLevelTimeLineIndex.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let publicSkillGroupId = self.publicSkillGroupId.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let publicSkillTimeLineIndex = self.publicSkillTimeLineIndex.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let passiveSkillGroupId = self.passiveSkillGroupId.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let leaderSkillGroupId = self.leaderSkillGroupId.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let extraPassiveSkillGroupId = self.extraPassiveSkillGroupId.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let hiddenPassiveSkillGroupId = self.hiddenPassiveSkillGroupId.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    CharacterSkillListExcel::create(_fbb, &CharacterSkillListExcelArgs{
      CharacterSkillListGroupId,
      MinimumGradeCharacterWeapon,
      MinimumTierCharacterGear,
      FormIndex,
      IsRootMotion,
      IsMoveLeftRight,
      UseRandomExSkillTimeline,
      TSAInteractionId,
      normalSkillGroupId,
      normalSkillTimeLineIndex,
      SelectExSkillActionSkillSlot,
      exSkillGroupId,
      exSkillCutInTimeLineIndex,
      exSkillLevelTimeLineIndex,
      publicSkillGroupId,
      publicSkillTimeLineIndex,
      passiveSkillGroupId,
      leaderSkillGroupId,
      extraPassiveSkillGroupId,
      hiddenPassiveSkillGroupId,
    })
  }
}
