// automatically generated by the FlatBuffers compiler, do not modify
// @generated
#![allow(unused_imports, dead_code)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum OpenConditionExcelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct OpenConditionExcel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OpenConditionExcel<'a> {
  type Inner = OpenConditionExcel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> OpenConditionExcel<'a> {
  pub const VT_OPENCONDITIONCONTENTTYPE: flatbuffers::VOffsetT = 4;
  pub const VT_LOCKUI: flatbuffers::VOffsetT = 6;
  pub const VT_SHORTCUTPOPUPPRIORITY: flatbuffers::VOffsetT = 8;
  pub const VT_SHORTCUTUINAME: flatbuffers::VOffsetT = 10;
  pub const VT_SHORTCUTPARAM: flatbuffers::VOffsetT = 12;
  pub const VT_SCENE: flatbuffers::VOffsetT = 14;
  pub const VT_HIDEWHENLOCKED: flatbuffers::VOffsetT = 16;
  pub const VT_ACCOUNTLEVEL: flatbuffers::VOffsetT = 18;
  pub const VT_SCENARIOMODEID: flatbuffers::VOffsetT = 20;
  pub const VT_CAMPAIGNSTAGEID: flatbuffers::VOffsetT = 22;
  pub const VT_MULTIPLECONDITIONCHECKTYPE: flatbuffers::VOffsetT = 24;
  pub const VT_OPENDAYOFWEEK: flatbuffers::VOffsetT = 26;
  pub const VT_OPENHOUR: flatbuffers::VOffsetT = 28;
  pub const VT_CLOSEDAYOFWEEK: flatbuffers::VOffsetT = 30;
  pub const VT_CLOSEHOUR: flatbuffers::VOffsetT = 32;
  pub const VT_OPENEDCAFEID: flatbuffers::VOffsetT = 34;
  pub const VT_CAFEIDFORCAFERANK: flatbuffers::VOffsetT = 36;
  pub const VT_CAFERANK: flatbuffers::VOffsetT = 38;
  pub const VT_CONTENTSOPENSHOW: flatbuffers::VOffsetT = 40;
  pub const VT_CONTENTSOPENSHORTCUTUI: flatbuffers::VOffsetT = 42;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    OpenConditionExcel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args OpenConditionExcelArgs<'args>
  ) -> flatbuffers::WIPOffset<OpenConditionExcel<'bldr>> {
    let mut builder = OpenConditionExcelBuilder::new(_fbb);
    let key = table_encryption_service::create_key(b"OpenCondition");
      let x = args.CafeRank;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_CafeRank(x);
      let x = args.CafeIdforCafeRank;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_CafeIdforCafeRank(x);
      let x = args.OpenedCafeId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_OpenedCafeId(x);
      let x = args.CloseHour;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_CloseHour(x);
      let x = args.OpenHour;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_OpenHour(x);
      let x = args.CampaignStageId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_CampaignStageId(x);
      let x = args.ScenarioModeId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_ScenarioModeId(x);
      let x = args.AccountLevel;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_AccountLevel(x);
      let x = args.ShortcutPopupPriority;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_ShortcutPopupPriority(x);
      if let Some(x) = args.ContentsOpenShortcutUI {
        builder.add_ContentsOpenShortcutUI(x);
      }
      let x = args.CloseDayOfWeek;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_CloseDayOfWeek(x);
      let x = args.OpenDayOfWeek;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_OpenDayOfWeek(x);
      let x = args.MultipleConditionCheckType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_MultipleConditionCheckType(x);
      if let Some(x) = args.Scene {
        builder.add_Scene(x);
      }
      let x = args.ShortcutParam;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_ShortcutParam(x);
      if let Some(x) = args.ShortcutUIName {
        builder.add_ShortcutUIName(x);
      }
      if let Some(x) = args.LockUI {
        builder.add_LockUI(x);
      }
      let x = args.OpenConditionContentType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_OpenConditionContentType(x);
      builder.add_ContentsOpenShow(args.ContentsOpenShow);
      builder.add_HideWhenLocked(args.HideWhenLocked);
    builder.finish()
  }

  pub fn unpack(&self) -> OpenConditionExcelT {
    let key = table_encryption_service::create_key(b"OpenCondition");
      let OpenConditionContentType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.OpenConditionContentType(), &key)
      } else {
        self.OpenConditionContentType()
      };
    let LockUI = self.LockUI().map(|x| {
      x.iter().map(|s| if table_encryption_service::use_encryption() { table_encryption_service::convert_string(s, &key).unwrap() } else { s.to_string() }).collect()
    });
      let ShortcutPopupPriority = self.ShortcutPopupPriority();
    let ShortcutUIName = self.ShortcutUIName().map(|x| {
      x.iter().map(|s| if table_encryption_service::use_encryption() { table_encryption_service::convert_string(s, &key).unwrap() } else { s.to_string() }).collect()
    });
      let ShortcutParam = self.ShortcutParam();
    let Scene = self.Scene().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let HideWhenLocked = self.HideWhenLocked();
      let AccountLevel = self.AccountLevel();
      let ScenarioModeId = self.ScenarioModeId();
      let CampaignStageId = self.CampaignStageId();
      let MultipleConditionCheckType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.MultipleConditionCheckType(), &key)
      } else {
        self.MultipleConditionCheckType()
      };
      let OpenDayOfWeek = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.OpenDayOfWeek(), &key)
      } else {
        self.OpenDayOfWeek()
      };
      let OpenHour = self.OpenHour();
      let CloseDayOfWeek = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.CloseDayOfWeek(), &key)
      } else {
        self.CloseDayOfWeek()
      };
      let CloseHour = self.CloseHour();
      let OpenedCafeId = self.OpenedCafeId();
      let CafeIdforCafeRank = self.CafeIdforCafeRank();
      let CafeRank = self.CafeRank();
      let ContentsOpenShow = self.ContentsOpenShow();
    let ContentsOpenShortcutUI = self.ContentsOpenShortcutUI().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    OpenConditionExcelT {
      OpenConditionContentType,
      LockUI,
      ShortcutPopupPriority,
      ShortcutUIName,
      ShortcutParam,
      Scene,
      HideWhenLocked,
      AccountLevel,
      ScenarioModeId,
      CampaignStageId,
      MultipleConditionCheckType,
      OpenDayOfWeek,
      OpenHour,
      CloseDayOfWeek,
      CloseHour,
      OpenedCafeId,
      CafeIdforCafeRank,
      CafeRank,
      ContentsOpenShow,
      ContentsOpenShortcutUI,
    }
  }

  #[inline]
  pub fn OpenConditionContentType(&self) -> OpenConditionContent {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<OpenConditionContent>(OpenConditionExcel::VT_OPENCONDITIONCONTENTTYPE, Some(OpenConditionContent::Shop)).unwrap()}
  }
  #[inline]
  pub fn LockUI(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(OpenConditionExcel::VT_LOCKUI, None)}
  }
  #[inline]
  pub fn ShortcutPopupPriority(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(OpenConditionExcel::VT_SHORTCUTPOPUPPRIORITY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ShortcutUIName(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(OpenConditionExcel::VT_SHORTCUTUINAME, None)}
  }
  #[inline]
  pub fn ShortcutParam(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(OpenConditionExcel::VT_SHORTCUTPARAM, Some(0)).unwrap()}
  }
  #[inline]
  pub fn Scene(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OpenConditionExcel::VT_SCENE, None)}
  }
  #[inline]
  pub fn HideWhenLocked(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(OpenConditionExcel::VT_HIDEWHENLOCKED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn AccountLevel(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(OpenConditionExcel::VT_ACCOUNTLEVEL, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ScenarioModeId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(OpenConditionExcel::VT_SCENARIOMODEID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CampaignStageId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(OpenConditionExcel::VT_CAMPAIGNSTAGEID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn MultipleConditionCheckType(&self) -> MultipleConditionCheckType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<MultipleConditionCheckType>(OpenConditionExcel::VT_MULTIPLECONDITIONCHECKTYPE, Some(MultipleConditionCheckType::And)).unwrap()}
  }
  #[inline]
  pub fn OpenDayOfWeek(&self) -> WeekDay {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<WeekDay>(OpenConditionExcel::VT_OPENDAYOFWEEK, Some(WeekDay::Sunday)).unwrap()}
  }
  #[inline]
  pub fn OpenHour(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(OpenConditionExcel::VT_OPENHOUR, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CloseDayOfWeek(&self) -> WeekDay {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<WeekDay>(OpenConditionExcel::VT_CLOSEDAYOFWEEK, Some(WeekDay::Sunday)).unwrap()}
  }
  #[inline]
  pub fn CloseHour(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(OpenConditionExcel::VT_CLOSEHOUR, Some(0)).unwrap()}
  }
  #[inline]
  pub fn OpenedCafeId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(OpenConditionExcel::VT_OPENEDCAFEID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CafeIdforCafeRank(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(OpenConditionExcel::VT_CAFEIDFORCAFERANK, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CafeRank(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(OpenConditionExcel::VT_CAFERANK, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ContentsOpenShow(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(OpenConditionExcel::VT_CONTENTSOPENSHOW, Some(false)).unwrap()}
  }
  #[inline]
  pub fn ContentsOpenShortcutUI(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OpenConditionExcel::VT_CONTENTSOPENSHORTCUTUI, None)}
  }
}

impl flatbuffers::Verifiable for OpenConditionExcel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<OpenConditionContent>("OpenConditionContentType", Self::VT_OPENCONDITIONCONTENTTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("LockUI", Self::VT_LOCKUI, false)?
     .visit_field::<i64>("ShortcutPopupPriority", Self::VT_SHORTCUTPOPUPPRIORITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("ShortcutUIName", Self::VT_SHORTCUTUINAME, false)?
     .visit_field::<i32>("ShortcutParam", Self::VT_SHORTCUTPARAM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("Scene", Self::VT_SCENE, false)?
     .visit_field::<bool>("HideWhenLocked", Self::VT_HIDEWHENLOCKED, false)?
     .visit_field::<i64>("AccountLevel", Self::VT_ACCOUNTLEVEL, false)?
     .visit_field::<i64>("ScenarioModeId", Self::VT_SCENARIOMODEID, false)?
     .visit_field::<i64>("CampaignStageId", Self::VT_CAMPAIGNSTAGEID, false)?
     .visit_field::<MultipleConditionCheckType>("MultipleConditionCheckType", Self::VT_MULTIPLECONDITIONCHECKTYPE, false)?
     .visit_field::<WeekDay>("OpenDayOfWeek", Self::VT_OPENDAYOFWEEK, false)?
     .visit_field::<i64>("OpenHour", Self::VT_OPENHOUR, false)?
     .visit_field::<WeekDay>("CloseDayOfWeek", Self::VT_CLOSEDAYOFWEEK, false)?
     .visit_field::<i64>("CloseHour", Self::VT_CLOSEHOUR, false)?
     .visit_field::<i64>("OpenedCafeId", Self::VT_OPENEDCAFEID, false)?
     .visit_field::<i64>("CafeIdforCafeRank", Self::VT_CAFEIDFORCAFERANK, false)?
     .visit_field::<i64>("CafeRank", Self::VT_CAFERANK, false)?
     .visit_field::<bool>("ContentsOpenShow", Self::VT_CONTENTSOPENSHOW, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ContentsOpenShortcutUI", Self::VT_CONTENTSOPENSHORTCUTUI, false)?
     .finish();
    Ok(())
  }
}
pub struct OpenConditionExcelArgs<'a> {
    pub OpenConditionContentType: OpenConditionContent,
    pub LockUI: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub ShortcutPopupPriority: i64,
    pub ShortcutUIName: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub ShortcutParam: i32,
    pub Scene: Option<flatbuffers::WIPOffset<&'a str>>,
    pub HideWhenLocked: bool,
    pub AccountLevel: i64,
    pub ScenarioModeId: i64,
    pub CampaignStageId: i64,
    pub MultipleConditionCheckType: MultipleConditionCheckType,
    pub OpenDayOfWeek: WeekDay,
    pub OpenHour: i64,
    pub CloseDayOfWeek: WeekDay,
    pub CloseHour: i64,
    pub OpenedCafeId: i64,
    pub CafeIdforCafeRank: i64,
    pub CafeRank: i64,
    pub ContentsOpenShow: bool,
    pub ContentsOpenShortcutUI: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for OpenConditionExcelArgs<'a> {
  #[inline]
  fn default() -> Self {
    OpenConditionExcelArgs {
      OpenConditionContentType: OpenConditionContent::Shop,
      LockUI: None,
      ShortcutPopupPriority: 0,
      ShortcutUIName: None,
      ShortcutParam: 0,
      Scene: None,
      HideWhenLocked: false,
      AccountLevel: 0,
      ScenarioModeId: 0,
      CampaignStageId: 0,
      MultipleConditionCheckType: MultipleConditionCheckType::And,
      OpenDayOfWeek: WeekDay::Sunday,
      OpenHour: 0,
      CloseDayOfWeek: WeekDay::Sunday,
      CloseHour: 0,
      OpenedCafeId: 0,
      CafeIdforCafeRank: 0,
      CafeRank: 0,
      ContentsOpenShow: false,
      ContentsOpenShortcutUI: None,
    }
  }
}

impl Serialize for OpenConditionExcel<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("OpenConditionExcel", 20)?;
      s.serialize_field("OpenConditionContentType", &self.OpenConditionContentType())?;
      if let Some(f) = self.LockUI() {
        s.serialize_field("LockUI", &f)?;
      } else {
        s.skip_field("LockUI")?;
      }
      s.serialize_field("ShortcutPopupPriority", &self.ShortcutPopupPriority())?;
      if let Some(f) = self.ShortcutUIName() {
        s.serialize_field("ShortcutUIName", &f)?;
      } else {
        s.skip_field("ShortcutUIName")?;
      }
      s.serialize_field("ShortcutParam", &self.ShortcutParam())?;
      if let Some(f) = self.Scene() {
        s.serialize_field("Scene", &f)?;
      } else {
        s.skip_field("Scene")?;
      }
      s.serialize_field("HideWhenLocked", &self.HideWhenLocked())?;
      s.serialize_field("AccountLevel", &self.AccountLevel())?;
      s.serialize_field("ScenarioModeId", &self.ScenarioModeId())?;
      s.serialize_field("CampaignStageId", &self.CampaignStageId())?;
      s.serialize_field("MultipleConditionCheckType", &self.MultipleConditionCheckType())?;
      s.serialize_field("OpenDayOfWeek", &self.OpenDayOfWeek())?;
      s.serialize_field("OpenHour", &self.OpenHour())?;
      s.serialize_field("CloseDayOfWeek", &self.CloseDayOfWeek())?;
      s.serialize_field("CloseHour", &self.CloseHour())?;
      s.serialize_field("OpenedCafeId", &self.OpenedCafeId())?;
      s.serialize_field("CafeIdforCafeRank", &self.CafeIdforCafeRank())?;
      s.serialize_field("CafeRank", &self.CafeRank())?;
      s.serialize_field("ContentsOpenShow", &self.ContentsOpenShow())?;
      if let Some(f) = self.ContentsOpenShortcutUI() {
        s.serialize_field("ContentsOpenShortcutUI", &f)?;
      } else {
        s.skip_field("ContentsOpenShortcutUI")?;
      }
    s.end()
  }
}

pub struct OpenConditionExcelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OpenConditionExcelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_OpenConditionContentType(&mut self, OpenConditionContentType: OpenConditionContent) {
    self.fbb_.push_slot::<OpenConditionContent>(OpenConditionExcel::VT_OPENCONDITIONCONTENTTYPE, OpenConditionContentType, OpenConditionContent::Shop);
  }
  #[inline]
  pub fn add_LockUI(&mut self, LockUI: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OpenConditionExcel::VT_LOCKUI, LockUI);
  }
  #[inline]
  pub fn add_ShortcutPopupPriority(&mut self, ShortcutPopupPriority: i64) {
    self.fbb_.push_slot::<i64>(OpenConditionExcel::VT_SHORTCUTPOPUPPRIORITY, ShortcutPopupPriority, 0);
  }
  #[inline]
  pub fn add_ShortcutUIName(&mut self, ShortcutUIName: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OpenConditionExcel::VT_SHORTCUTUINAME, ShortcutUIName);
  }
  #[inline]
  pub fn add_ShortcutParam(&mut self, ShortcutParam: i32) {
    self.fbb_.push_slot::<i32>(OpenConditionExcel::VT_SHORTCUTPARAM, ShortcutParam, 0);
  }
  #[inline]
  pub fn add_Scene(&mut self, Scene: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OpenConditionExcel::VT_SCENE, Scene);
  }
  #[inline]
  pub fn add_HideWhenLocked(&mut self, HideWhenLocked: bool) {
    self.fbb_.push_slot::<bool>(OpenConditionExcel::VT_HIDEWHENLOCKED, HideWhenLocked, false);
  }
  #[inline]
  pub fn add_AccountLevel(&mut self, AccountLevel: i64) {
    self.fbb_.push_slot::<i64>(OpenConditionExcel::VT_ACCOUNTLEVEL, AccountLevel, 0);
  }
  #[inline]
  pub fn add_ScenarioModeId(&mut self, ScenarioModeId: i64) {
    self.fbb_.push_slot::<i64>(OpenConditionExcel::VT_SCENARIOMODEID, ScenarioModeId, 0);
  }
  #[inline]
  pub fn add_CampaignStageId(&mut self, CampaignStageId: i64) {
    self.fbb_.push_slot::<i64>(OpenConditionExcel::VT_CAMPAIGNSTAGEID, CampaignStageId, 0);
  }
  #[inline]
  pub fn add_MultipleConditionCheckType(&mut self, MultipleConditionCheckType: MultipleConditionCheckType) {
    self.fbb_.push_slot::<MultipleConditionCheckType>(OpenConditionExcel::VT_MULTIPLECONDITIONCHECKTYPE, MultipleConditionCheckType, MultipleConditionCheckType::And);
  }
  #[inline]
  pub fn add_OpenDayOfWeek(&mut self, OpenDayOfWeek: WeekDay) {
    self.fbb_.push_slot::<WeekDay>(OpenConditionExcel::VT_OPENDAYOFWEEK, OpenDayOfWeek, WeekDay::Sunday);
  }
  #[inline]
  pub fn add_OpenHour(&mut self, OpenHour: i64) {
    self.fbb_.push_slot::<i64>(OpenConditionExcel::VT_OPENHOUR, OpenHour, 0);
  }
  #[inline]
  pub fn add_CloseDayOfWeek(&mut self, CloseDayOfWeek: WeekDay) {
    self.fbb_.push_slot::<WeekDay>(OpenConditionExcel::VT_CLOSEDAYOFWEEK, CloseDayOfWeek, WeekDay::Sunday);
  }
  #[inline]
  pub fn add_CloseHour(&mut self, CloseHour: i64) {
    self.fbb_.push_slot::<i64>(OpenConditionExcel::VT_CLOSEHOUR, CloseHour, 0);
  }
  #[inline]
  pub fn add_OpenedCafeId(&mut self, OpenedCafeId: i64) {
    self.fbb_.push_slot::<i64>(OpenConditionExcel::VT_OPENEDCAFEID, OpenedCafeId, 0);
  }
  #[inline]
  pub fn add_CafeIdforCafeRank(&mut self, CafeIdforCafeRank: i64) {
    self.fbb_.push_slot::<i64>(OpenConditionExcel::VT_CAFEIDFORCAFERANK, CafeIdforCafeRank, 0);
  }
  #[inline]
  pub fn add_CafeRank(&mut self, CafeRank: i64) {
    self.fbb_.push_slot::<i64>(OpenConditionExcel::VT_CAFERANK, CafeRank, 0);
  }
  #[inline]
  pub fn add_ContentsOpenShow(&mut self, ContentsOpenShow: bool) {
    self.fbb_.push_slot::<bool>(OpenConditionExcel::VT_CONTENTSOPENSHOW, ContentsOpenShow, false);
  }
  #[inline]
  pub fn add_ContentsOpenShortcutUI(&mut self, ContentsOpenShortcutUI: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OpenConditionExcel::VT_CONTENTSOPENSHORTCUTUI, ContentsOpenShortcutUI);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> OpenConditionExcelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    OpenConditionExcelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OpenConditionExcel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for OpenConditionExcel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("OpenConditionExcel");
      ds.field("OpenConditionContentType", &self.OpenConditionContentType());
      ds.field("LockUI", &self.LockUI());
      ds.field("ShortcutPopupPriority", &self.ShortcutPopupPriority());
      ds.field("ShortcutUIName", &self.ShortcutUIName());
      ds.field("ShortcutParam", &self.ShortcutParam());
      ds.field("Scene", &self.Scene());
      ds.field("HideWhenLocked", &self.HideWhenLocked());
      ds.field("AccountLevel", &self.AccountLevel());
      ds.field("ScenarioModeId", &self.ScenarioModeId());
      ds.field("CampaignStageId", &self.CampaignStageId());
      ds.field("MultipleConditionCheckType", &self.MultipleConditionCheckType());
      ds.field("OpenDayOfWeek", &self.OpenDayOfWeek());
      ds.field("OpenHour", &self.OpenHour());
      ds.field("CloseDayOfWeek", &self.CloseDayOfWeek());
      ds.field("CloseHour", &self.CloseHour());
      ds.field("OpenedCafeId", &self.OpenedCafeId());
      ds.field("CafeIdforCafeRank", &self.CafeIdforCafeRank());
      ds.field("CafeRank", &self.CafeRank());
      ds.field("ContentsOpenShow", &self.ContentsOpenShow());
      ds.field("ContentsOpenShortcutUI", &self.ContentsOpenShortcutUI());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct OpenConditionExcelT {
  pub OpenConditionContentType: OpenConditionContent,
  pub LockUI: Option<Vec<String>>,
  pub ShortcutPopupPriority: i64,
  pub ShortcutUIName: Option<Vec<String>>,
  pub ShortcutParam: i32,
  pub Scene: Option<String>,
  pub HideWhenLocked: bool,
  pub AccountLevel: i64,
  pub ScenarioModeId: i64,
  pub CampaignStageId: i64,
  pub MultipleConditionCheckType: MultipleConditionCheckType,
  pub OpenDayOfWeek: WeekDay,
  pub OpenHour: i64,
  pub CloseDayOfWeek: WeekDay,
  pub CloseHour: i64,
  pub OpenedCafeId: i64,
  pub CafeIdforCafeRank: i64,
  pub CafeRank: i64,
  pub ContentsOpenShow: bool,
  pub ContentsOpenShortcutUI: Option<String>,
}
impl Default for OpenConditionExcelT {
  fn default() -> Self {
    Self {
      OpenConditionContentType: OpenConditionContent::Shop,
      LockUI: None,
      ShortcutPopupPriority: 0,
      ShortcutUIName: None,
      ShortcutParam: 0,
      Scene: None,
      HideWhenLocked: false,
      AccountLevel: 0,
      ScenarioModeId: 0,
      CampaignStageId: 0,
      MultipleConditionCheckType: MultipleConditionCheckType::And,
      OpenDayOfWeek: WeekDay::Sunday,
      OpenHour: 0,
      CloseDayOfWeek: WeekDay::Sunday,
      CloseHour: 0,
      OpenedCafeId: 0,
      CafeIdforCafeRank: 0,
      CafeRank: 0,
      ContentsOpenShow: false,
      ContentsOpenShortcutUI: None,
    }
  }
}
impl OpenConditionExcelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<OpenConditionExcel<'b>> {
    let OpenConditionContentType = self.OpenConditionContentType;
    let LockUI = self.LockUI.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let ShortcutPopupPriority = self.ShortcutPopupPriority;
    let ShortcutUIName = self.ShortcutUIName.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let ShortcutParam = self.ShortcutParam;
    let Scene = self.Scene.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let HideWhenLocked = self.HideWhenLocked;
    let AccountLevel = self.AccountLevel;
    let ScenarioModeId = self.ScenarioModeId;
    let CampaignStageId = self.CampaignStageId;
    let MultipleConditionCheckType = self.MultipleConditionCheckType;
    let OpenDayOfWeek = self.OpenDayOfWeek;
    let OpenHour = self.OpenHour;
    let CloseDayOfWeek = self.CloseDayOfWeek;
    let CloseHour = self.CloseHour;
    let OpenedCafeId = self.OpenedCafeId;
    let CafeIdforCafeRank = self.CafeIdforCafeRank;
    let CafeRank = self.CafeRank;
    let ContentsOpenShow = self.ContentsOpenShow;
    let ContentsOpenShortcutUI = self.ContentsOpenShortcutUI.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    OpenConditionExcel::create(_fbb, &OpenConditionExcelArgs{
      OpenConditionContentType,
      LockUI,
      ShortcutPopupPriority,
      ShortcutUIName,
      ShortcutParam,
      Scene,
      HideWhenLocked,
      AccountLevel,
      ScenarioModeId,
      CampaignStageId,
      MultipleConditionCheckType,
      OpenDayOfWeek,
      OpenHour,
      CloseDayOfWeek,
      CloseHour,
      OpenedCafeId,
      CafeIdforCafeRank,
      CafeRank,
      ContentsOpenShow,
      ContentsOpenShortcutUI,
    })
  }
}
