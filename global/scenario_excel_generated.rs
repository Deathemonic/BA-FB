// automatically generated by the FlatBuffers compiler, do not modify
// @generated
#![allow(unused_imports, dead_code)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum ScenarioExcelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ScenarioExcel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ScenarioExcel<'a> {
  type Inner = ScenarioExcel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ScenarioExcel<'a> {
  pub const VT_NONE: flatbuffers::VOffsetT = 4;
  pub const VT_IDLE: flatbuffers::VOffsetT = 6;
  pub const VT_CAFE: flatbuffers::VOffsetT = 8;
  pub const VT_TALK: flatbuffers::VOffsetT = 10;
  pub const VT_OPEN: flatbuffers::VOffsetT = 12;
  pub const VT_ENTERCONVER: flatbuffers::VOffsetT = 14;
  pub const VT_CENTER: flatbuffers::VOffsetT = 16;
  pub const VT_INSTANT: flatbuffers::VOffsetT = 18;
  pub const VT_PROLOGUE: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ScenarioExcel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ScenarioExcelArgs<'args>
  ) -> flatbuffers::WIPOffset<ScenarioExcel<'bldr>> {
    let mut builder = ScenarioExcelBuilder::new(_fbb);
    let key = table_encryption_service::create_key(b"Scenario");
      let x = args.Prologue;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_Prologue(x);
      let x = args.Instant;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_Instant(x);
      let x = args.Center;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_Center(x);
      let x = args.EnterConver;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_EnterConver(x);
      let x = args.Open;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_Open(x);
      let x = args.Talk;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_Talk(x);
      let x = args.Cafe;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_Cafe(x);
      if let Some(x) = args.idle {
        builder.add_idle(x);
      }
      if let Some(x) = args.none {
        builder.add_none(x);
      }
    builder.finish()
  }

  pub fn unpack(&self) -> ScenarioExcelT {
    let key = table_encryption_service::create_key(b"Scenario");
    let none = self.none().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(*val, &key) } else { *val }).collect()
    });
    let idle = self.idle().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(*val, &key) } else { *val }).collect()
    });
      let Cafe = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.Cafe(), &key)
      } else {
        self.Cafe()
      };
      let Talk = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.Talk(), &key)
      } else {
        self.Talk()
      };
      let Open = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.Open(), &key)
      } else {
        self.Open()
      };
      let EnterConver = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.EnterConver(), &key)
      } else {
        self.EnterConver()
      };
      let Center = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.Center(), &key)
      } else {
        self.Center()
      };
      let Instant = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.Instant(), &key)
      } else {
        self.Instant()
      };
      let Prologue = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.Prologue(), &key)
      } else {
        self.Prologue()
      };
    ScenarioExcelT {
      none,
      idle,
      Cafe,
      Talk,
      Open,
      EnterConver,
      Center,
      Instant,
      Prologue,
    }
  }

  #[inline]
  pub fn none(&self) -> Option<flatbuffers::Vector<'a, ScenarioBGType>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, ScenarioBGType>>>(ScenarioExcel::VT_NONE, None)}
  }
  #[inline]
  pub fn idle(&self) -> Option<flatbuffers::Vector<'a, ScenarioCharacterAction>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, ScenarioCharacterAction>>>(ScenarioExcel::VT_IDLE, None)}
  }
  #[inline]
  pub fn Cafe(&self) -> DialogCategory {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DialogCategory>(ScenarioExcel::VT_CAFE, Some(DialogCategory::Cafe)).unwrap()}
  }
  #[inline]
  pub fn Talk(&self) -> DialogType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DialogType>(ScenarioExcel::VT_TALK, Some(DialogType::Talk)).unwrap()}
  }
  #[inline]
  pub fn Open(&self) -> StoryCondition {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<StoryCondition>(ScenarioExcel::VT_OPEN, Some(StoryCondition::Open)).unwrap()}
  }
  #[inline]
  pub fn EnterConver(&self) -> EmojiEvent {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<EmojiEvent>(ScenarioExcel::VT_ENTERCONVER, Some(EmojiEvent::EnterConver)).unwrap()}
  }
  #[inline]
  pub fn Center(&self) -> ScenarioZoomAnchors {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ScenarioZoomAnchors>(ScenarioExcel::VT_CENTER, Some(ScenarioZoomAnchors::Center)).unwrap()}
  }
  #[inline]
  pub fn Instant(&self) -> ScenarioZoomType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ScenarioZoomType>(ScenarioExcel::VT_INSTANT, Some(ScenarioZoomType::Instant)).unwrap()}
  }
  #[inline]
  pub fn Prologue(&self) -> ScenarioContentType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ScenarioContentType>(ScenarioExcel::VT_PROLOGUE, Some(ScenarioContentType::Prologue)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ScenarioExcel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, ScenarioBGType>>>("none", Self::VT_NONE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, ScenarioCharacterAction>>>("idle", Self::VT_IDLE, false)?
     .visit_field::<DialogCategory>("Cafe", Self::VT_CAFE, false)?
     .visit_field::<DialogType>("Talk", Self::VT_TALK, false)?
     .visit_field::<StoryCondition>("Open", Self::VT_OPEN, false)?
     .visit_field::<EmojiEvent>("EnterConver", Self::VT_ENTERCONVER, false)?
     .visit_field::<ScenarioZoomAnchors>("Center", Self::VT_CENTER, false)?
     .visit_field::<ScenarioZoomType>("Instant", Self::VT_INSTANT, false)?
     .visit_field::<ScenarioContentType>("Prologue", Self::VT_PROLOGUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ScenarioExcelArgs<'a> {
    pub none: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, ScenarioBGType>>>,
    pub idle: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, ScenarioCharacterAction>>>,
    pub Cafe: DialogCategory,
    pub Talk: DialogType,
    pub Open: StoryCondition,
    pub EnterConver: EmojiEvent,
    pub Center: ScenarioZoomAnchors,
    pub Instant: ScenarioZoomType,
    pub Prologue: ScenarioContentType,
}
impl<'a> Default for ScenarioExcelArgs<'a> {
  #[inline]
  fn default() -> Self {
    ScenarioExcelArgs {
      none: None,
      idle: None,
      Cafe: DialogCategory::Cafe,
      Talk: DialogType::Talk,
      Open: StoryCondition::Open,
      EnterConver: EmojiEvent::EnterConver,
      Center: ScenarioZoomAnchors::Center,
      Instant: ScenarioZoomType::Instant,
      Prologue: ScenarioContentType::Prologue,
    }
  }
}

impl Serialize for ScenarioExcel<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("ScenarioExcel", 9)?;
      if let Some(f) = self.none() {
        s.serialize_field("none", &f)?;
      } else {
        s.skip_field("none")?;
      }
      if let Some(f) = self.idle() {
        s.serialize_field("idle", &f)?;
      } else {
        s.skip_field("idle")?;
      }
      s.serialize_field("Cafe", &self.Cafe())?;
      s.serialize_field("Talk", &self.Talk())?;
      s.serialize_field("Open", &self.Open())?;
      s.serialize_field("EnterConver", &self.EnterConver())?;
      s.serialize_field("Center", &self.Center())?;
      s.serialize_field("Instant", &self.Instant())?;
      s.serialize_field("Prologue", &self.Prologue())?;
    s.end()
  }
}

pub struct ScenarioExcelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ScenarioExcelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_none(&mut self, none: flatbuffers::WIPOffset<flatbuffers::Vector<'b , ScenarioBGType>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ScenarioExcel::VT_NONE, none);
  }
  #[inline]
  pub fn add_idle(&mut self, idle: flatbuffers::WIPOffset<flatbuffers::Vector<'b , ScenarioCharacterAction>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ScenarioExcel::VT_IDLE, idle);
  }
  #[inline]
  pub fn add_Cafe(&mut self, Cafe: DialogCategory) {
    self.fbb_.push_slot::<DialogCategory>(ScenarioExcel::VT_CAFE, Cafe, DialogCategory::Cafe);
  }
  #[inline]
  pub fn add_Talk(&mut self, Talk: DialogType) {
    self.fbb_.push_slot::<DialogType>(ScenarioExcel::VT_TALK, Talk, DialogType::Talk);
  }
  #[inline]
  pub fn add_Open(&mut self, Open: StoryCondition) {
    self.fbb_.push_slot::<StoryCondition>(ScenarioExcel::VT_OPEN, Open, StoryCondition::Open);
  }
  #[inline]
  pub fn add_EnterConver(&mut self, EnterConver: EmojiEvent) {
    self.fbb_.push_slot::<EmojiEvent>(ScenarioExcel::VT_ENTERCONVER, EnterConver, EmojiEvent::EnterConver);
  }
  #[inline]
  pub fn add_Center(&mut self, Center: ScenarioZoomAnchors) {
    self.fbb_.push_slot::<ScenarioZoomAnchors>(ScenarioExcel::VT_CENTER, Center, ScenarioZoomAnchors::Center);
  }
  #[inline]
  pub fn add_Instant(&mut self, Instant: ScenarioZoomType) {
    self.fbb_.push_slot::<ScenarioZoomType>(ScenarioExcel::VT_INSTANT, Instant, ScenarioZoomType::Instant);
  }
  #[inline]
  pub fn add_Prologue(&mut self, Prologue: ScenarioContentType) {
    self.fbb_.push_slot::<ScenarioContentType>(ScenarioExcel::VT_PROLOGUE, Prologue, ScenarioContentType::Prologue);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ScenarioExcelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ScenarioExcelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ScenarioExcel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ScenarioExcel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ScenarioExcel");
      ds.field("none", &self.none());
      ds.field("idle", &self.idle());
      ds.field("Cafe", &self.Cafe());
      ds.field("Talk", &self.Talk());
      ds.field("Open", &self.Open());
      ds.field("EnterConver", &self.EnterConver());
      ds.field("Center", &self.Center());
      ds.field("Instant", &self.Instant());
      ds.field("Prologue", &self.Prologue());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ScenarioExcelT {
  pub none: Option<Vec<ScenarioBGType>>,
  pub idle: Option<Vec<ScenarioCharacterAction>>,
  pub Cafe: DialogCategory,
  pub Talk: DialogType,
  pub Open: StoryCondition,
  pub EnterConver: EmojiEvent,
  pub Center: ScenarioZoomAnchors,
  pub Instant: ScenarioZoomType,
  pub Prologue: ScenarioContentType,
}
impl Default for ScenarioExcelT {
  fn default() -> Self {
    Self {
      none: None,
      idle: None,
      Cafe: DialogCategory::Cafe,
      Talk: DialogType::Talk,
      Open: StoryCondition::Open,
      EnterConver: EmojiEvent::EnterConver,
      Center: ScenarioZoomAnchors::Center,
      Instant: ScenarioZoomType::Instant,
      Prologue: ScenarioContentType::Prologue,
    }
  }
}
impl ScenarioExcelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ScenarioExcel<'b>> {
    let none = self.none.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let idle = self.idle.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let Cafe = self.Cafe;
    let Talk = self.Talk;
    let Open = self.Open;
    let EnterConver = self.EnterConver;
    let Center = self.Center;
    let Instant = self.Instant;
    let Prologue = self.Prologue;
    ScenarioExcel::create(_fbb, &ScenarioExcelArgs{
      none,
      idle,
      Cafe,
      Talk,
      Open,
      EnterConver,
      Center,
      Instant,
      Prologue,
    })
  }
}
