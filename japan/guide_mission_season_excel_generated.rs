// automatically generated by the FlatBuffers compiler, do not modify
// @generated
#![allow(unused_imports, dead_code)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum GuideMissionSeasonExcelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GuideMissionSeasonExcel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GuideMissionSeasonExcel<'a> {
  type Inner = GuideMissionSeasonExcel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GuideMissionSeasonExcel<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_TITLELOCALIZECODE: flatbuffers::VOffsetT = 6;
  pub const VT_PERMANENTINFOMATIONLOCALIZECODE: flatbuffers::VOffsetT = 8;
  pub const VT_INFOMATIONLOCALIZECODE: flatbuffers::VOffsetT = 10;
  pub const VT_ACCOUNTTYPE: flatbuffers::VOffsetT = 12;
  pub const VT_ENABLED: flatbuffers::VOffsetT = 14;
  pub const VT_BANNEROPENDATE: flatbuffers::VOffsetT = 16;
  pub const VT_STARTDATE: flatbuffers::VOffsetT = 18;
  pub const VT_STARTABLEENDDATE: flatbuffers::VOffsetT = 20;
  pub const VT_ENDDATE: flatbuffers::VOffsetT = 22;
  pub const VT_CLOSEBANNERAFTERCOMPLETION: flatbuffers::VOffsetT = 24;
  pub const VT_MAXIMUMLOGINCOUNT: flatbuffers::VOffsetT = 26;
  pub const VT_EXPIRYDATE: flatbuffers::VOffsetT = 28;
  pub const VT_ICONORDER: flatbuffers::VOffsetT = 30;
  pub const VT_SPINECHARACTERID: flatbuffers::VOffsetT = 32;
  pub const VT_REQUIREMENTPARCELIMAGE: flatbuffers::VOffsetT = 34;
  pub const VT_REWARDIMAGE: flatbuffers::VOffsetT = 36;
  pub const VT_LOBBYBANNERIMAGE: flatbuffers::VOffsetT = 38;
  pub const VT_BACKGROUNDIMAGE: flatbuffers::VOffsetT = 40;
  pub const VT_TITLEIMAGE: flatbuffers::VOffsetT = 42;
  pub const VT_REQUIREMENTPARCELTYPE: flatbuffers::VOffsetT = 44;
  pub const VT_REQUIREMENTPARCELID: flatbuffers::VOffsetT = 46;
  pub const VT_REQUIREMENTPARCELAMOUNT: flatbuffers::VOffsetT = 48;
  pub const VT_TABTYPE: flatbuffers::VOffsetT = 50;
  pub const VT_ISPERMANENT: flatbuffers::VOffsetT = 52;
  pub const VT_PRESEASONID: flatbuffers::VOffsetT = 54;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GuideMissionSeasonExcel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GuideMissionSeasonExcelArgs<'args>
  ) -> flatbuffers::WIPOffset<GuideMissionSeasonExcel<'bldr>> {
    let mut builder = GuideMissionSeasonExcelBuilder::new(_fbb);
    let key = table_encryption_service::create_key(b"GuideMissionSeason");
      let x = args.PreSeasonId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_PreSeasonId(x);
      let x = args.RequirementParcelId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_RequirementParcelId(x);
      let x = args.SpineCharacterId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_SpineCharacterId(x);
      let x = args.IconOrder;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_IconOrder(x);
      let x = args.ExpiryDate;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_ExpiryDate(x);
      let x = args.MaximumLoginCount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_MaximumLoginCount(x);
      let x = args.Id;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_Id(x);
      let x = args.TabType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_TabType(x);
      let x = args.RequirementParcelAmount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_RequirementParcelAmount(x);
      let x = args.RequirementParcelType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_RequirementParcelType(x);
      if let Some(x) = args.TitleImage {
        builder.add_TitleImage(x);
      }
      if let Some(x) = args.BackgroundImage {
        builder.add_BackgroundImage(x);
      }
      if let Some(x) = args.LobbyBannerImage {
        builder.add_LobbyBannerImage(x);
      }
      if let Some(x) = args.RewardImage {
        builder.add_RewardImage(x);
      }
      if let Some(x) = args.RequirementParcelImage {
        builder.add_RequirementParcelImage(x);
      }
      if let Some(x) = args.EndDate {
        builder.add_EndDate(x);
      }
      if let Some(x) = args.StartableEndDate {
        builder.add_StartableEndDate(x);
      }
      if let Some(x) = args.StartDate {
        builder.add_StartDate(x);
      }
      if let Some(x) = args.BannerOpenDate {
        builder.add_BannerOpenDate(x);
      }
      let x = args.AccountType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_AccountType(x);
      if let Some(x) = args.InfomationLocalizeCode {
        builder.add_InfomationLocalizeCode(x);
      }
      if let Some(x) = args.PermanentInfomationLocalizeCode {
        builder.add_PermanentInfomationLocalizeCode(x);
      }
      if let Some(x) = args.TitleLocalizeCode {
        builder.add_TitleLocalizeCode(x);
      }
      builder.add_IsPermanent(args.IsPermanent);
      builder.add_CloseBannerAfterCompletion(args.CloseBannerAfterCompletion);
      builder.add_Enabled(args.Enabled);
    builder.finish()
  }

  pub fn unpack(&self) -> GuideMissionSeasonExcelT {
    let key = table_encryption_service::create_key(b"GuideMissionSeason");
      let Id = self.Id();
    let TitleLocalizeCode = self.TitleLocalizeCode().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let PermanentInfomationLocalizeCode = self.PermanentInfomationLocalizeCode().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let InfomationLocalizeCode = self.InfomationLocalizeCode().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let AccountType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.AccountType(), &key)
      } else {
        self.AccountType()
      };
      let Enabled = self.Enabled();
    let BannerOpenDate = self.BannerOpenDate().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let StartDate = self.StartDate().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let StartableEndDate = self.StartableEndDate().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let EndDate = self.EndDate().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let CloseBannerAfterCompletion = self.CloseBannerAfterCompletion();
      let MaximumLoginCount = self.MaximumLoginCount();
      let ExpiryDate = self.ExpiryDate();
      let IconOrder = self.IconOrder();
      let SpineCharacterId = self.SpineCharacterId();
    let RequirementParcelImage = self.RequirementParcelImage().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let RewardImage = self.RewardImage().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let LobbyBannerImage = self.LobbyBannerImage().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let BackgroundImage = self.BackgroundImage().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let TitleImage = self.TitleImage().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let RequirementParcelType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.RequirementParcelType(), &key)
      } else {
        self.RequirementParcelType()
      };
      let RequirementParcelId = self.RequirementParcelId();
      let RequirementParcelAmount = self.RequirementParcelAmount();
      let TabType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.TabType(), &key)
      } else {
        self.TabType()
      };
      let IsPermanent = self.IsPermanent();
      let PreSeasonId = self.PreSeasonId();
    GuideMissionSeasonExcelT {
      Id,
      TitleLocalizeCode,
      PermanentInfomationLocalizeCode,
      InfomationLocalizeCode,
      AccountType,
      Enabled,
      BannerOpenDate,
      StartDate,
      StartableEndDate,
      EndDate,
      CloseBannerAfterCompletion,
      MaximumLoginCount,
      ExpiryDate,
      IconOrder,
      SpineCharacterId,
      RequirementParcelImage,
      RewardImage,
      LobbyBannerImage,
      BackgroundImage,
      TitleImage,
      RequirementParcelType,
      RequirementParcelId,
      RequirementParcelAmount,
      TabType,
      IsPermanent,
      PreSeasonId,
    }
  }

  #[inline]
  pub fn Id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GuideMissionSeasonExcel::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn TitleLocalizeCode(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GuideMissionSeasonExcel::VT_TITLELOCALIZECODE, None)}
  }
  #[inline]
  pub fn PermanentInfomationLocalizeCode(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GuideMissionSeasonExcel::VT_PERMANENTINFOMATIONLOCALIZECODE, None)}
  }
  #[inline]
  pub fn InfomationLocalizeCode(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GuideMissionSeasonExcel::VT_INFOMATIONLOCALIZECODE, None)}
  }
  #[inline]
  pub fn AccountType(&self) -> AccountState {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<AccountState>(GuideMissionSeasonExcel::VT_ACCOUNTTYPE, Some(AccountState::WaitingSignIn)).unwrap()}
  }
  #[inline]
  pub fn Enabled(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GuideMissionSeasonExcel::VT_ENABLED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn BannerOpenDate(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GuideMissionSeasonExcel::VT_BANNEROPENDATE, None)}
  }
  #[inline]
  pub fn StartDate(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GuideMissionSeasonExcel::VT_STARTDATE, None)}
  }
  #[inline]
  pub fn StartableEndDate(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GuideMissionSeasonExcel::VT_STARTABLEENDDATE, None)}
  }
  #[inline]
  pub fn EndDate(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GuideMissionSeasonExcel::VT_ENDDATE, None)}
  }
  #[inline]
  pub fn CloseBannerAfterCompletion(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GuideMissionSeasonExcel::VT_CLOSEBANNERAFTERCOMPLETION, Some(false)).unwrap()}
  }
  #[inline]
  pub fn MaximumLoginCount(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GuideMissionSeasonExcel::VT_MAXIMUMLOGINCOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ExpiryDate(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GuideMissionSeasonExcel::VT_EXPIRYDATE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn IconOrder(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GuideMissionSeasonExcel::VT_ICONORDER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn SpineCharacterId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GuideMissionSeasonExcel::VT_SPINECHARACTERID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn RequirementParcelImage(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GuideMissionSeasonExcel::VT_REQUIREMENTPARCELIMAGE, None)}
  }
  #[inline]
  pub fn RewardImage(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GuideMissionSeasonExcel::VT_REWARDIMAGE, None)}
  }
  #[inline]
  pub fn LobbyBannerImage(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GuideMissionSeasonExcel::VT_LOBBYBANNERIMAGE, None)}
  }
  #[inline]
  pub fn BackgroundImage(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GuideMissionSeasonExcel::VT_BACKGROUNDIMAGE, None)}
  }
  #[inline]
  pub fn TitleImage(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GuideMissionSeasonExcel::VT_TITLEIMAGE, None)}
  }
  #[inline]
  pub fn RequirementParcelType(&self) -> ParcelType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ParcelType>(GuideMissionSeasonExcel::VT_REQUIREMENTPARCELTYPE, Some(ParcelType::None)).unwrap()}
  }
  #[inline]
  pub fn RequirementParcelId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GuideMissionSeasonExcel::VT_REQUIREMENTPARCELID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn RequirementParcelAmount(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(GuideMissionSeasonExcel::VT_REQUIREMENTPARCELAMOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn TabType(&self) -> GuideMissionTabType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GuideMissionTabType>(GuideMissionSeasonExcel::VT_TABTYPE, Some(GuideMissionTabType::None)).unwrap()}
  }
  #[inline]
  pub fn IsPermanent(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GuideMissionSeasonExcel::VT_ISPERMANENT, Some(false)).unwrap()}
  }
  #[inline]
  pub fn PreSeasonId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GuideMissionSeasonExcel::VT_PRESEASONID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GuideMissionSeasonExcel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("Id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TitleLocalizeCode", Self::VT_TITLELOCALIZECODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PermanentInfomationLocalizeCode", Self::VT_PERMANENTINFOMATIONLOCALIZECODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("InfomationLocalizeCode", Self::VT_INFOMATIONLOCALIZECODE, false)?
     .visit_field::<AccountState>("AccountType", Self::VT_ACCOUNTTYPE, false)?
     .visit_field::<bool>("Enabled", Self::VT_ENABLED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("BannerOpenDate", Self::VT_BANNEROPENDATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("StartDate", Self::VT_STARTDATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("StartableEndDate", Self::VT_STARTABLEENDDATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EndDate", Self::VT_ENDDATE, false)?
     .visit_field::<bool>("CloseBannerAfterCompletion", Self::VT_CLOSEBANNERAFTERCOMPLETION, false)?
     .visit_field::<i64>("MaximumLoginCount", Self::VT_MAXIMUMLOGINCOUNT, false)?
     .visit_field::<i64>("ExpiryDate", Self::VT_EXPIRYDATE, false)?
     .visit_field::<i64>("IconOrder", Self::VT_ICONORDER, false)?
     .visit_field::<i64>("SpineCharacterId", Self::VT_SPINECHARACTERID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("RequirementParcelImage", Self::VT_REQUIREMENTPARCELIMAGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("RewardImage", Self::VT_REWARDIMAGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LobbyBannerImage", Self::VT_LOBBYBANNERIMAGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("BackgroundImage", Self::VT_BACKGROUNDIMAGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TitleImage", Self::VT_TITLEIMAGE, false)?
     .visit_field::<ParcelType>("RequirementParcelType", Self::VT_REQUIREMENTPARCELTYPE, false)?
     .visit_field::<i64>("RequirementParcelId", Self::VT_REQUIREMENTPARCELID, false)?
     .visit_field::<i32>("RequirementParcelAmount", Self::VT_REQUIREMENTPARCELAMOUNT, false)?
     .visit_field::<GuideMissionTabType>("TabType", Self::VT_TABTYPE, false)?
     .visit_field::<bool>("IsPermanent", Self::VT_ISPERMANENT, false)?
     .visit_field::<i64>("PreSeasonId", Self::VT_PRESEASONID, false)?
     .finish();
    Ok(())
  }
}
pub struct GuideMissionSeasonExcelArgs<'a> {
    pub Id: i64,
    pub TitleLocalizeCode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PermanentInfomationLocalizeCode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub InfomationLocalizeCode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub AccountType: AccountState,
    pub Enabled: bool,
    pub BannerOpenDate: Option<flatbuffers::WIPOffset<&'a str>>,
    pub StartDate: Option<flatbuffers::WIPOffset<&'a str>>,
    pub StartableEndDate: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EndDate: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CloseBannerAfterCompletion: bool,
    pub MaximumLoginCount: i64,
    pub ExpiryDate: i64,
    pub IconOrder: i64,
    pub SpineCharacterId: i64,
    pub RequirementParcelImage: Option<flatbuffers::WIPOffset<&'a str>>,
    pub RewardImage: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LobbyBannerImage: Option<flatbuffers::WIPOffset<&'a str>>,
    pub BackgroundImage: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TitleImage: Option<flatbuffers::WIPOffset<&'a str>>,
    pub RequirementParcelType: ParcelType,
    pub RequirementParcelId: i64,
    pub RequirementParcelAmount: i32,
    pub TabType: GuideMissionTabType,
    pub IsPermanent: bool,
    pub PreSeasonId: i64,
}
impl<'a> Default for GuideMissionSeasonExcelArgs<'a> {
  #[inline]
  fn default() -> Self {
    GuideMissionSeasonExcelArgs {
      Id: 0,
      TitleLocalizeCode: None,
      PermanentInfomationLocalizeCode: None,
      InfomationLocalizeCode: None,
      AccountType: AccountState::WaitingSignIn,
      Enabled: false,
      BannerOpenDate: None,
      StartDate: None,
      StartableEndDate: None,
      EndDate: None,
      CloseBannerAfterCompletion: false,
      MaximumLoginCount: 0,
      ExpiryDate: 0,
      IconOrder: 0,
      SpineCharacterId: 0,
      RequirementParcelImage: None,
      RewardImage: None,
      LobbyBannerImage: None,
      BackgroundImage: None,
      TitleImage: None,
      RequirementParcelType: ParcelType::None,
      RequirementParcelId: 0,
      RequirementParcelAmount: 0,
      TabType: GuideMissionTabType::None,
      IsPermanent: false,
      PreSeasonId: 0,
    }
  }
}

impl Serialize for GuideMissionSeasonExcel<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("GuideMissionSeasonExcel", 26)?;
      s.serialize_field("Id", &self.Id())?;
      if let Some(f) = self.TitleLocalizeCode() {
        s.serialize_field("TitleLocalizeCode", &f)?;
      } else {
        s.skip_field("TitleLocalizeCode")?;
      }
      if let Some(f) = self.PermanentInfomationLocalizeCode() {
        s.serialize_field("PermanentInfomationLocalizeCode", &f)?;
      } else {
        s.skip_field("PermanentInfomationLocalizeCode")?;
      }
      if let Some(f) = self.InfomationLocalizeCode() {
        s.serialize_field("InfomationLocalizeCode", &f)?;
      } else {
        s.skip_field("InfomationLocalizeCode")?;
      }
      s.serialize_field("AccountType", &self.AccountType())?;
      s.serialize_field("Enabled", &self.Enabled())?;
      if let Some(f) = self.BannerOpenDate() {
        s.serialize_field("BannerOpenDate", &f)?;
      } else {
        s.skip_field("BannerOpenDate")?;
      }
      if let Some(f) = self.StartDate() {
        s.serialize_field("StartDate", &f)?;
      } else {
        s.skip_field("StartDate")?;
      }
      if let Some(f) = self.StartableEndDate() {
        s.serialize_field("StartableEndDate", &f)?;
      } else {
        s.skip_field("StartableEndDate")?;
      }
      if let Some(f) = self.EndDate() {
        s.serialize_field("EndDate", &f)?;
      } else {
        s.skip_field("EndDate")?;
      }
      s.serialize_field("CloseBannerAfterCompletion", &self.CloseBannerAfterCompletion())?;
      s.serialize_field("MaximumLoginCount", &self.MaximumLoginCount())?;
      s.serialize_field("ExpiryDate", &self.ExpiryDate())?;
      s.serialize_field("IconOrder", &self.IconOrder())?;
      s.serialize_field("SpineCharacterId", &self.SpineCharacterId())?;
      if let Some(f) = self.RequirementParcelImage() {
        s.serialize_field("RequirementParcelImage", &f)?;
      } else {
        s.skip_field("RequirementParcelImage")?;
      }
      if let Some(f) = self.RewardImage() {
        s.serialize_field("RewardImage", &f)?;
      } else {
        s.skip_field("RewardImage")?;
      }
      if let Some(f) = self.LobbyBannerImage() {
        s.serialize_field("LobbyBannerImage", &f)?;
      } else {
        s.skip_field("LobbyBannerImage")?;
      }
      if let Some(f) = self.BackgroundImage() {
        s.serialize_field("BackgroundImage", &f)?;
      } else {
        s.skip_field("BackgroundImage")?;
      }
      if let Some(f) = self.TitleImage() {
        s.serialize_field("TitleImage", &f)?;
      } else {
        s.skip_field("TitleImage")?;
      }
      s.serialize_field("RequirementParcelType", &self.RequirementParcelType())?;
      s.serialize_field("RequirementParcelId", &self.RequirementParcelId())?;
      s.serialize_field("RequirementParcelAmount", &self.RequirementParcelAmount())?;
      s.serialize_field("TabType", &self.TabType())?;
      s.serialize_field("IsPermanent", &self.IsPermanent())?;
      s.serialize_field("PreSeasonId", &self.PreSeasonId())?;
    s.end()
  }
}

pub struct GuideMissionSeasonExcelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GuideMissionSeasonExcelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_Id(&mut self, Id: i64) {
    self.fbb_.push_slot::<i64>(GuideMissionSeasonExcel::VT_ID, Id, 0);
  }
  #[inline]
  pub fn add_TitleLocalizeCode(&mut self, TitleLocalizeCode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GuideMissionSeasonExcel::VT_TITLELOCALIZECODE, TitleLocalizeCode);
  }
  #[inline]
  pub fn add_PermanentInfomationLocalizeCode(&mut self, PermanentInfomationLocalizeCode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GuideMissionSeasonExcel::VT_PERMANENTINFOMATIONLOCALIZECODE, PermanentInfomationLocalizeCode);
  }
  #[inline]
  pub fn add_InfomationLocalizeCode(&mut self, InfomationLocalizeCode: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GuideMissionSeasonExcel::VT_INFOMATIONLOCALIZECODE, InfomationLocalizeCode);
  }
  #[inline]
  pub fn add_AccountType(&mut self, AccountType: AccountState) {
    self.fbb_.push_slot::<AccountState>(GuideMissionSeasonExcel::VT_ACCOUNTTYPE, AccountType, AccountState::WaitingSignIn);
  }
  #[inline]
  pub fn add_Enabled(&mut self, Enabled: bool) {
    self.fbb_.push_slot::<bool>(GuideMissionSeasonExcel::VT_ENABLED, Enabled, false);
  }
  #[inline]
  pub fn add_BannerOpenDate(&mut self, BannerOpenDate: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GuideMissionSeasonExcel::VT_BANNEROPENDATE, BannerOpenDate);
  }
  #[inline]
  pub fn add_StartDate(&mut self, StartDate: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GuideMissionSeasonExcel::VT_STARTDATE, StartDate);
  }
  #[inline]
  pub fn add_StartableEndDate(&mut self, StartableEndDate: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GuideMissionSeasonExcel::VT_STARTABLEENDDATE, StartableEndDate);
  }
  #[inline]
  pub fn add_EndDate(&mut self, EndDate: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GuideMissionSeasonExcel::VT_ENDDATE, EndDate);
  }
  #[inline]
  pub fn add_CloseBannerAfterCompletion(&mut self, CloseBannerAfterCompletion: bool) {
    self.fbb_.push_slot::<bool>(GuideMissionSeasonExcel::VT_CLOSEBANNERAFTERCOMPLETION, CloseBannerAfterCompletion, false);
  }
  #[inline]
  pub fn add_MaximumLoginCount(&mut self, MaximumLoginCount: i64) {
    self.fbb_.push_slot::<i64>(GuideMissionSeasonExcel::VT_MAXIMUMLOGINCOUNT, MaximumLoginCount, 0);
  }
  #[inline]
  pub fn add_ExpiryDate(&mut self, ExpiryDate: i64) {
    self.fbb_.push_slot::<i64>(GuideMissionSeasonExcel::VT_EXPIRYDATE, ExpiryDate, 0);
  }
  #[inline]
  pub fn add_IconOrder(&mut self, IconOrder: i64) {
    self.fbb_.push_slot::<i64>(GuideMissionSeasonExcel::VT_ICONORDER, IconOrder, 0);
  }
  #[inline]
  pub fn add_SpineCharacterId(&mut self, SpineCharacterId: i64) {
    self.fbb_.push_slot::<i64>(GuideMissionSeasonExcel::VT_SPINECHARACTERID, SpineCharacterId, 0);
  }
  #[inline]
  pub fn add_RequirementParcelImage(&mut self, RequirementParcelImage: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GuideMissionSeasonExcel::VT_REQUIREMENTPARCELIMAGE, RequirementParcelImage);
  }
  #[inline]
  pub fn add_RewardImage(&mut self, RewardImage: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GuideMissionSeasonExcel::VT_REWARDIMAGE, RewardImage);
  }
  #[inline]
  pub fn add_LobbyBannerImage(&mut self, LobbyBannerImage: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GuideMissionSeasonExcel::VT_LOBBYBANNERIMAGE, LobbyBannerImage);
  }
  #[inline]
  pub fn add_BackgroundImage(&mut self, BackgroundImage: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GuideMissionSeasonExcel::VT_BACKGROUNDIMAGE, BackgroundImage);
  }
  #[inline]
  pub fn add_TitleImage(&mut self, TitleImage: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GuideMissionSeasonExcel::VT_TITLEIMAGE, TitleImage);
  }
  #[inline]
  pub fn add_RequirementParcelType(&mut self, RequirementParcelType: ParcelType) {
    self.fbb_.push_slot::<ParcelType>(GuideMissionSeasonExcel::VT_REQUIREMENTPARCELTYPE, RequirementParcelType, ParcelType::None);
  }
  #[inline]
  pub fn add_RequirementParcelId(&mut self, RequirementParcelId: i64) {
    self.fbb_.push_slot::<i64>(GuideMissionSeasonExcel::VT_REQUIREMENTPARCELID, RequirementParcelId, 0);
  }
  #[inline]
  pub fn add_RequirementParcelAmount(&mut self, RequirementParcelAmount: i32) {
    self.fbb_.push_slot::<i32>(GuideMissionSeasonExcel::VT_REQUIREMENTPARCELAMOUNT, RequirementParcelAmount, 0);
  }
  #[inline]
  pub fn add_TabType(&mut self, TabType: GuideMissionTabType) {
    self.fbb_.push_slot::<GuideMissionTabType>(GuideMissionSeasonExcel::VT_TABTYPE, TabType, GuideMissionTabType::None);
  }
  #[inline]
  pub fn add_IsPermanent(&mut self, IsPermanent: bool) {
    self.fbb_.push_slot::<bool>(GuideMissionSeasonExcel::VT_ISPERMANENT, IsPermanent, false);
  }
  #[inline]
  pub fn add_PreSeasonId(&mut self, PreSeasonId: i64) {
    self.fbb_.push_slot::<i64>(GuideMissionSeasonExcel::VT_PRESEASONID, PreSeasonId, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GuideMissionSeasonExcelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GuideMissionSeasonExcelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GuideMissionSeasonExcel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GuideMissionSeasonExcel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GuideMissionSeasonExcel");
      ds.field("Id", &self.Id());
      ds.field("TitleLocalizeCode", &self.TitleLocalizeCode());
      ds.field("PermanentInfomationLocalizeCode", &self.PermanentInfomationLocalizeCode());
      ds.field("InfomationLocalizeCode", &self.InfomationLocalizeCode());
      ds.field("AccountType", &self.AccountType());
      ds.field("Enabled", &self.Enabled());
      ds.field("BannerOpenDate", &self.BannerOpenDate());
      ds.field("StartDate", &self.StartDate());
      ds.field("StartableEndDate", &self.StartableEndDate());
      ds.field("EndDate", &self.EndDate());
      ds.field("CloseBannerAfterCompletion", &self.CloseBannerAfterCompletion());
      ds.field("MaximumLoginCount", &self.MaximumLoginCount());
      ds.field("ExpiryDate", &self.ExpiryDate());
      ds.field("IconOrder", &self.IconOrder());
      ds.field("SpineCharacterId", &self.SpineCharacterId());
      ds.field("RequirementParcelImage", &self.RequirementParcelImage());
      ds.field("RewardImage", &self.RewardImage());
      ds.field("LobbyBannerImage", &self.LobbyBannerImage());
      ds.field("BackgroundImage", &self.BackgroundImage());
      ds.field("TitleImage", &self.TitleImage());
      ds.field("RequirementParcelType", &self.RequirementParcelType());
      ds.field("RequirementParcelId", &self.RequirementParcelId());
      ds.field("RequirementParcelAmount", &self.RequirementParcelAmount());
      ds.field("TabType", &self.TabType());
      ds.field("IsPermanent", &self.IsPermanent());
      ds.field("PreSeasonId", &self.PreSeasonId());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GuideMissionSeasonExcelT {
  pub Id: i64,
  pub TitleLocalizeCode: Option<String>,
  pub PermanentInfomationLocalizeCode: Option<String>,
  pub InfomationLocalizeCode: Option<String>,
  pub AccountType: AccountState,
  pub Enabled: bool,
  pub BannerOpenDate: Option<String>,
  pub StartDate: Option<String>,
  pub StartableEndDate: Option<String>,
  pub EndDate: Option<String>,
  pub CloseBannerAfterCompletion: bool,
  pub MaximumLoginCount: i64,
  pub ExpiryDate: i64,
  pub IconOrder: i64,
  pub SpineCharacterId: i64,
  pub RequirementParcelImage: Option<String>,
  pub RewardImage: Option<String>,
  pub LobbyBannerImage: Option<String>,
  pub BackgroundImage: Option<String>,
  pub TitleImage: Option<String>,
  pub RequirementParcelType: ParcelType,
  pub RequirementParcelId: i64,
  pub RequirementParcelAmount: i32,
  pub TabType: GuideMissionTabType,
  pub IsPermanent: bool,
  pub PreSeasonId: i64,
}
impl Default for GuideMissionSeasonExcelT {
  fn default() -> Self {
    Self {
      Id: 0,
      TitleLocalizeCode: None,
      PermanentInfomationLocalizeCode: None,
      InfomationLocalizeCode: None,
      AccountType: AccountState::WaitingSignIn,
      Enabled: false,
      BannerOpenDate: None,
      StartDate: None,
      StartableEndDate: None,
      EndDate: None,
      CloseBannerAfterCompletion: false,
      MaximumLoginCount: 0,
      ExpiryDate: 0,
      IconOrder: 0,
      SpineCharacterId: 0,
      RequirementParcelImage: None,
      RewardImage: None,
      LobbyBannerImage: None,
      BackgroundImage: None,
      TitleImage: None,
      RequirementParcelType: ParcelType::None,
      RequirementParcelId: 0,
      RequirementParcelAmount: 0,
      TabType: GuideMissionTabType::None,
      IsPermanent: false,
      PreSeasonId: 0,
    }
  }
}
impl GuideMissionSeasonExcelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<GuideMissionSeasonExcel<'b>> {
    let Id = self.Id;
    let TitleLocalizeCode = self.TitleLocalizeCode.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PermanentInfomationLocalizeCode = self.PermanentInfomationLocalizeCode.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let InfomationLocalizeCode = self.InfomationLocalizeCode.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let AccountType = self.AccountType;
    let Enabled = self.Enabled;
    let BannerOpenDate = self.BannerOpenDate.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let StartDate = self.StartDate.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let StartableEndDate = self.StartableEndDate.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EndDate = self.EndDate.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CloseBannerAfterCompletion = self.CloseBannerAfterCompletion;
    let MaximumLoginCount = self.MaximumLoginCount;
    let ExpiryDate = self.ExpiryDate;
    let IconOrder = self.IconOrder;
    let SpineCharacterId = self.SpineCharacterId;
    let RequirementParcelImage = self.RequirementParcelImage.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let RewardImage = self.RewardImage.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LobbyBannerImage = self.LobbyBannerImage.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let BackgroundImage = self.BackgroundImage.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TitleImage = self.TitleImage.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let RequirementParcelType = self.RequirementParcelType;
    let RequirementParcelId = self.RequirementParcelId;
    let RequirementParcelAmount = self.RequirementParcelAmount;
    let TabType = self.TabType;
    let IsPermanent = self.IsPermanent;
    let PreSeasonId = self.PreSeasonId;
    GuideMissionSeasonExcel::create(_fbb, &GuideMissionSeasonExcelArgs{
      Id,
      TitleLocalizeCode,
      PermanentInfomationLocalizeCode,
      InfomationLocalizeCode,
      AccountType,
      Enabled,
      BannerOpenDate,
      StartDate,
      StartableEndDate,
      EndDate,
      CloseBannerAfterCompletion,
      MaximumLoginCount,
      ExpiryDate,
      IconOrder,
      SpineCharacterId,
      RequirementParcelImage,
      RewardImage,
      LobbyBannerImage,
      BackgroundImage,
      TitleImage,
      RequirementParcelType,
      RequirementParcelId,
      RequirementParcelAmount,
      TabType,
      IsPermanent,
      PreSeasonId,
    })
  }
}
