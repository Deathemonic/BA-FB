// automatically generated by the FlatBuffers compiler, do not modify
// @generated
#![allow(unused_imports, dead_code)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum CharacterWeaponExcelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CharacterWeaponExcel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CharacterWeaponExcel<'a> {
  type Inner = CharacterWeaponExcel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CharacterWeaponExcel<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_IMAGEPATH: flatbuffers::VOffsetT = 6;
  pub const VT_SETRECIPE: flatbuffers::VOffsetT = 8;
  pub const VT_STATLEVELUPTYPE: flatbuffers::VOffsetT = 10;
  pub const VT_ATTACKPOWER: flatbuffers::VOffsetT = 12;
  pub const VT_ATTACKPOWER100: flatbuffers::VOffsetT = 14;
  pub const VT_MAXHP: flatbuffers::VOffsetT = 16;
  pub const VT_MAXHP100: flatbuffers::VOffsetT = 18;
  pub const VT_HEALPOWER: flatbuffers::VOffsetT = 20;
  pub const VT_HEALPOWER100: flatbuffers::VOffsetT = 22;
  pub const VT_UNLOCK: flatbuffers::VOffsetT = 24;
  pub const VT_RECIPEID: flatbuffers::VOffsetT = 26;
  pub const VT_MAXLEVEL: flatbuffers::VOffsetT = 28;
  pub const VT_LEARNSKILLSLOT: flatbuffers::VOffsetT = 30;
  pub const VT_STATTYPE: flatbuffers::VOffsetT = 32;
  pub const VT_STATVALUE: flatbuffers::VOffsetT = 34;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CharacterWeaponExcel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CharacterWeaponExcelArgs<'args>
  ) -> flatbuffers::WIPOffset<CharacterWeaponExcel<'bldr>> {
    let mut builder = CharacterWeaponExcelBuilder::new(_fbb);
    let key = table_encryption_service::create_key(b"CharacterWeapon");
      let x = args.HealPower100;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_HealPower100(x);
      let x = args.HealPower;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_HealPower(x);
      let x = args.MaxHP100;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_MaxHP100(x);
      let x = args.MaxHP;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_MaxHP(x);
      let x = args.AttackPower100;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_AttackPower100(x);
      let x = args.AttackPower;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_AttackPower(x);
      let x = args.SetRecipe;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_SetRecipe(x);
      let x = args.Id;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_Id(x);
      if let Some(x) = args.StatValue {
        builder.add_StatValue(x);
      }
      if let Some(x) = args.StatType {
        builder.add_StatType(x);
      }
      if let Some(x) = args.LearnSkillSlot {
        builder.add_LearnSkillSlot(x);
      }
      if let Some(x) = args.MaxLevel {
        builder.add_MaxLevel(x);
      }
      if let Some(x) = args.RecipeId {
        builder.add_RecipeId(x);
      }
      if let Some(x) = args.Unlock {
        builder.add_Unlock(x);
      }
      let x = args.StatLevelUpType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_StatLevelUpType(x);
      if let Some(x) = args.ImagePath {
        builder.add_ImagePath(x);
      }
    builder.finish()
  }

  pub fn unpack(&self) -> CharacterWeaponExcelT {
    let key = table_encryption_service::create_key(b"CharacterWeapon");
      let Id = self.Id();
    let ImagePath = self.ImagePath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let SetRecipe = self.SetRecipe();
      let StatLevelUpType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.StatLevelUpType(), &key)
      } else {
        self.StatLevelUpType()
      };
      let AttackPower = self.AttackPower();
      let AttackPower100 = self.AttackPower100();
      let MaxHP = self.MaxHP();
      let MaxHP100 = self.MaxHP100();
      let HealPower = self.HealPower();
      let HealPower100 = self.HealPower100();
    let Unlock = self.Unlock().map(|x| {
      x.into_iter().collect()
    });
    let RecipeId = self.RecipeId().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_long(*val, &key) } else { *val }).collect()
    });
    let MaxLevel = self.MaxLevel().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_int(*val, &key) } else { *val }).collect()
    });
    let LearnSkillSlot = self.LearnSkillSlot().map(|x| {
      x.iter().map(|s| if table_encryption_service::use_encryption() { table_encryption_service::convert_string(s, &key).unwrap() } else { s.to_string() }).collect()
    });
    let StatType = self.StatType().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(*val, &key) } else { *val }).collect()
    });
    let StatValue = self.StatValue().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_long(*val, &key) } else { *val }).collect()
    });
    CharacterWeaponExcelT {
      Id,
      ImagePath,
      SetRecipe,
      StatLevelUpType,
      AttackPower,
      AttackPower100,
      MaxHP,
      MaxHP100,
      HealPower,
      HealPower100,
      Unlock,
      RecipeId,
      MaxLevel,
      LearnSkillSlot,
      StatType,
      StatValue,
    }
  }

  #[inline]
  pub fn Id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CharacterWeaponExcel::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ImagePath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CharacterWeaponExcel::VT_IMAGEPATH, None)}
  }
  #[inline]
  pub fn SetRecipe(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CharacterWeaponExcel::VT_SETRECIPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn StatLevelUpType(&self) -> StatLevelUpType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<StatLevelUpType>(CharacterWeaponExcel::VT_STATLEVELUPTYPE, Some(StatLevelUpType::Standard)).unwrap()}
  }
  #[inline]
  pub fn AttackPower(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CharacterWeaponExcel::VT_ATTACKPOWER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn AttackPower100(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CharacterWeaponExcel::VT_ATTACKPOWER100, Some(0)).unwrap()}
  }
  #[inline]
  pub fn MaxHP(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CharacterWeaponExcel::VT_MAXHP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn MaxHP100(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CharacterWeaponExcel::VT_MAXHP100, Some(0)).unwrap()}
  }
  #[inline]
  pub fn HealPower(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CharacterWeaponExcel::VT_HEALPOWER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn HealPower100(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CharacterWeaponExcel::VT_HEALPOWER100, Some(0)).unwrap()}
  }
  #[inline]
  pub fn Unlock(&self) -> Option<flatbuffers::Vector<'a, bool>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, bool>>>(CharacterWeaponExcel::VT_UNLOCK, None)}
  }
  #[inline]
  pub fn RecipeId(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(CharacterWeaponExcel::VT_RECIPEID, None)}
  }
  #[inline]
  pub fn MaxLevel(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(CharacterWeaponExcel::VT_MAXLEVEL, None)}
  }
  #[inline]
  pub fn LearnSkillSlot(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(CharacterWeaponExcel::VT_LEARNSKILLSLOT, None)}
  }
  #[inline]
  pub fn StatType(&self) -> Option<flatbuffers::Vector<'a, EquipmentOptionType>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, EquipmentOptionType>>>(CharacterWeaponExcel::VT_STATTYPE, None)}
  }
  #[inline]
  pub fn StatValue(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(CharacterWeaponExcel::VT_STATVALUE, None)}
  }
}

impl flatbuffers::Verifiable for CharacterWeaponExcel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("Id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ImagePath", Self::VT_IMAGEPATH, false)?
     .visit_field::<i64>("SetRecipe", Self::VT_SETRECIPE, false)?
     .visit_field::<StatLevelUpType>("StatLevelUpType", Self::VT_STATLEVELUPTYPE, false)?
     .visit_field::<i64>("AttackPower", Self::VT_ATTACKPOWER, false)?
     .visit_field::<i64>("AttackPower100", Self::VT_ATTACKPOWER100, false)?
     .visit_field::<i64>("MaxHP", Self::VT_MAXHP, false)?
     .visit_field::<i64>("MaxHP100", Self::VT_MAXHP100, false)?
     .visit_field::<i64>("HealPower", Self::VT_HEALPOWER, false)?
     .visit_field::<i64>("HealPower100", Self::VT_HEALPOWER100, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, bool>>>("Unlock", Self::VT_UNLOCK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("RecipeId", Self::VT_RECIPEID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("MaxLevel", Self::VT_MAXLEVEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("LearnSkillSlot", Self::VT_LEARNSKILLSLOT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, EquipmentOptionType>>>("StatType", Self::VT_STATTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("StatValue", Self::VT_STATVALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct CharacterWeaponExcelArgs<'a> {
    pub Id: i64,
    pub ImagePath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SetRecipe: i64,
    pub StatLevelUpType: StatLevelUpType,
    pub AttackPower: i64,
    pub AttackPower100: i64,
    pub MaxHP: i64,
    pub MaxHP100: i64,
    pub HealPower: i64,
    pub HealPower100: i64,
    pub Unlock: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, bool>>>,
    pub RecipeId: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub MaxLevel: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub LearnSkillSlot: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub StatType: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, EquipmentOptionType>>>,
    pub StatValue: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
}
impl<'a> Default for CharacterWeaponExcelArgs<'a> {
  #[inline]
  fn default() -> Self {
    CharacterWeaponExcelArgs {
      Id: 0,
      ImagePath: None,
      SetRecipe: 0,
      StatLevelUpType: StatLevelUpType::Standard,
      AttackPower: 0,
      AttackPower100: 0,
      MaxHP: 0,
      MaxHP100: 0,
      HealPower: 0,
      HealPower100: 0,
      Unlock: None,
      RecipeId: None,
      MaxLevel: None,
      LearnSkillSlot: None,
      StatType: None,
      StatValue: None,
    }
  }
}

impl Serialize for CharacterWeaponExcel<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("CharacterWeaponExcel", 16)?;
      s.serialize_field("Id", &self.Id())?;
      if let Some(f) = self.ImagePath() {
        s.serialize_field("ImagePath", &f)?;
      } else {
        s.skip_field("ImagePath")?;
      }
      s.serialize_field("SetRecipe", &self.SetRecipe())?;
      s.serialize_field("StatLevelUpType", &self.StatLevelUpType())?;
      s.serialize_field("AttackPower", &self.AttackPower())?;
      s.serialize_field("AttackPower100", &self.AttackPower100())?;
      s.serialize_field("MaxHP", &self.MaxHP())?;
      s.serialize_field("MaxHP100", &self.MaxHP100())?;
      s.serialize_field("HealPower", &self.HealPower())?;
      s.serialize_field("HealPower100", &self.HealPower100())?;
      if let Some(f) = self.Unlock() {
        s.serialize_field("Unlock", &f)?;
      } else {
        s.skip_field("Unlock")?;
      }
      if let Some(f) = self.RecipeId() {
        s.serialize_field("RecipeId", &f)?;
      } else {
        s.skip_field("RecipeId")?;
      }
      if let Some(f) = self.MaxLevel() {
        s.serialize_field("MaxLevel", &f)?;
      } else {
        s.skip_field("MaxLevel")?;
      }
      if let Some(f) = self.LearnSkillSlot() {
        s.serialize_field("LearnSkillSlot", &f)?;
      } else {
        s.skip_field("LearnSkillSlot")?;
      }
      if let Some(f) = self.StatType() {
        s.serialize_field("StatType", &f)?;
      } else {
        s.skip_field("StatType")?;
      }
      if let Some(f) = self.StatValue() {
        s.serialize_field("StatValue", &f)?;
      } else {
        s.skip_field("StatValue")?;
      }
    s.end()
  }
}

pub struct CharacterWeaponExcelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CharacterWeaponExcelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_Id(&mut self, Id: i64) {
    self.fbb_.push_slot::<i64>(CharacterWeaponExcel::VT_ID, Id, 0);
  }
  #[inline]
  pub fn add_ImagePath(&mut self, ImagePath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CharacterWeaponExcel::VT_IMAGEPATH, ImagePath);
  }
  #[inline]
  pub fn add_SetRecipe(&mut self, SetRecipe: i64) {
    self.fbb_.push_slot::<i64>(CharacterWeaponExcel::VT_SETRECIPE, SetRecipe, 0);
  }
  #[inline]
  pub fn add_StatLevelUpType(&mut self, StatLevelUpType: StatLevelUpType) {
    self.fbb_.push_slot::<StatLevelUpType>(CharacterWeaponExcel::VT_STATLEVELUPTYPE, StatLevelUpType, StatLevelUpType::Standard);
  }
  #[inline]
  pub fn add_AttackPower(&mut self, AttackPower: i64) {
    self.fbb_.push_slot::<i64>(CharacterWeaponExcel::VT_ATTACKPOWER, AttackPower, 0);
  }
  #[inline]
  pub fn add_AttackPower100(&mut self, AttackPower100: i64) {
    self.fbb_.push_slot::<i64>(CharacterWeaponExcel::VT_ATTACKPOWER100, AttackPower100, 0);
  }
  #[inline]
  pub fn add_MaxHP(&mut self, MaxHP: i64) {
    self.fbb_.push_slot::<i64>(CharacterWeaponExcel::VT_MAXHP, MaxHP, 0);
  }
  #[inline]
  pub fn add_MaxHP100(&mut self, MaxHP100: i64) {
    self.fbb_.push_slot::<i64>(CharacterWeaponExcel::VT_MAXHP100, MaxHP100, 0);
  }
  #[inline]
  pub fn add_HealPower(&mut self, HealPower: i64) {
    self.fbb_.push_slot::<i64>(CharacterWeaponExcel::VT_HEALPOWER, HealPower, 0);
  }
  #[inline]
  pub fn add_HealPower100(&mut self, HealPower100: i64) {
    self.fbb_.push_slot::<i64>(CharacterWeaponExcel::VT_HEALPOWER100, HealPower100, 0);
  }
  #[inline]
  pub fn add_Unlock(&mut self, Unlock: flatbuffers::WIPOffset<flatbuffers::Vector<'b , bool>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CharacterWeaponExcel::VT_UNLOCK, Unlock);
  }
  #[inline]
  pub fn add_RecipeId(&mut self, RecipeId: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CharacterWeaponExcel::VT_RECIPEID, RecipeId);
  }
  #[inline]
  pub fn add_MaxLevel(&mut self, MaxLevel: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CharacterWeaponExcel::VT_MAXLEVEL, MaxLevel);
  }
  #[inline]
  pub fn add_LearnSkillSlot(&mut self, LearnSkillSlot: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CharacterWeaponExcel::VT_LEARNSKILLSLOT, LearnSkillSlot);
  }
  #[inline]
  pub fn add_StatType(&mut self, StatType: flatbuffers::WIPOffset<flatbuffers::Vector<'b , EquipmentOptionType>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CharacterWeaponExcel::VT_STATTYPE, StatType);
  }
  #[inline]
  pub fn add_StatValue(&mut self, StatValue: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CharacterWeaponExcel::VT_STATVALUE, StatValue);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CharacterWeaponExcelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CharacterWeaponExcelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CharacterWeaponExcel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CharacterWeaponExcel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CharacterWeaponExcel");
      ds.field("Id", &self.Id());
      ds.field("ImagePath", &self.ImagePath());
      ds.field("SetRecipe", &self.SetRecipe());
      ds.field("StatLevelUpType", &self.StatLevelUpType());
      ds.field("AttackPower", &self.AttackPower());
      ds.field("AttackPower100", &self.AttackPower100());
      ds.field("MaxHP", &self.MaxHP());
      ds.field("MaxHP100", &self.MaxHP100());
      ds.field("HealPower", &self.HealPower());
      ds.field("HealPower100", &self.HealPower100());
      ds.field("Unlock", &self.Unlock());
      ds.field("RecipeId", &self.RecipeId());
      ds.field("MaxLevel", &self.MaxLevel());
      ds.field("LearnSkillSlot", &self.LearnSkillSlot());
      ds.field("StatType", &self.StatType());
      ds.field("StatValue", &self.StatValue());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CharacterWeaponExcelT {
  pub Id: i64,
  pub ImagePath: Option<String>,
  pub SetRecipe: i64,
  pub StatLevelUpType: StatLevelUpType,
  pub AttackPower: i64,
  pub AttackPower100: i64,
  pub MaxHP: i64,
  pub MaxHP100: i64,
  pub HealPower: i64,
  pub HealPower100: i64,
  pub Unlock: Option<Vec<bool>>,
  pub RecipeId: Option<Vec<i64>>,
  pub MaxLevel: Option<Vec<i32>>,
  pub LearnSkillSlot: Option<Vec<String>>,
  pub StatType: Option<Vec<EquipmentOptionType>>,
  pub StatValue: Option<Vec<i64>>,
}
impl Default for CharacterWeaponExcelT {
  fn default() -> Self {
    Self {
      Id: 0,
      ImagePath: None,
      SetRecipe: 0,
      StatLevelUpType: StatLevelUpType::Standard,
      AttackPower: 0,
      AttackPower100: 0,
      MaxHP: 0,
      MaxHP100: 0,
      HealPower: 0,
      HealPower100: 0,
      Unlock: None,
      RecipeId: None,
      MaxLevel: None,
      LearnSkillSlot: None,
      StatType: None,
      StatValue: None,
    }
  }
}
impl CharacterWeaponExcelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CharacterWeaponExcel<'b>> {
    let Id = self.Id;
    let ImagePath = self.ImagePath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SetRecipe = self.SetRecipe;
    let StatLevelUpType = self.StatLevelUpType;
    let AttackPower = self.AttackPower;
    let AttackPower100 = self.AttackPower100;
    let MaxHP = self.MaxHP;
    let MaxHP100 = self.MaxHP100;
    let HealPower = self.HealPower;
    let HealPower100 = self.HealPower100;
    let Unlock = self.Unlock.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let RecipeId = self.RecipeId.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let MaxLevel = self.MaxLevel.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let LearnSkillSlot = self.LearnSkillSlot.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let StatType = self.StatType.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let StatValue = self.StatValue.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    CharacterWeaponExcel::create(_fbb, &CharacterWeaponExcelArgs{
      Id,
      ImagePath,
      SetRecipe,
      StatLevelUpType,
      AttackPower,
      AttackPower100,
      MaxHP,
      MaxHP100,
      HealPower,
      HealPower100,
      Unlock,
      RecipeId,
      MaxLevel,
      LearnSkillSlot,
      StatType,
      StatValue,
    })
  }
}
