// automatically generated by the FlatBuffers compiler, do not modify
// @generated
#![allow(unused_imports, dead_code)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum RaidStageExcelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RaidStageExcel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RaidStageExcel<'a> {
  type Inner = RaidStageExcel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RaidStageExcel<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_USEBOSSINDEX: flatbuffers::VOffsetT = 6;
  pub const VT_USEBOSSAIPHASESYNC: flatbuffers::VOffsetT = 8;
  pub const VT_RAIDBOSSGROUP: flatbuffers::VOffsetT = 10;
  pub const VT_PORTRAITPATH: flatbuffers::VOffsetT = 12;
  pub const VT_BGPATH: flatbuffers::VOffsetT = 14;
  pub const VT_RAIDCHARACTERID: flatbuffers::VOffsetT = 16;
  pub const VT_BOSSCHARACTERID: flatbuffers::VOffsetT = 18;
  pub const VT_DIFFICULTY: flatbuffers::VOffsetT = 20;
  pub const VT_DIFFICULTYOPENCONDITION: flatbuffers::VOffsetT = 22;
  pub const VT_MAXPLAYERCOUNT: flatbuffers::VOffsetT = 24;
  pub const VT_RAIDROOMLIFETIME: flatbuffers::VOffsetT = 26;
  pub const VT_BATTLEDURATION: flatbuffers::VOffsetT = 28;
  pub const VT_GROUNDID: flatbuffers::VOffsetT = 30;
  pub const VT_GROUNDDEVNAME: flatbuffers::VOffsetT = 32;
  pub const VT_ENTERTIMELINE: flatbuffers::VOffsetT = 34;
  pub const VT_TACTICENVIRONMENT: flatbuffers::VOffsetT = 36;
  pub const VT_DEFAULTCLEARSCORE: flatbuffers::VOffsetT = 38;
  pub const VT_MAXIMUMSCORE: flatbuffers::VOffsetT = 40;
  pub const VT_PERSECONDMINUSSCORE: flatbuffers::VOffsetT = 42;
  pub const VT_HPPERCENTSCORE: flatbuffers::VOffsetT = 44;
  pub const VT_MINIMUMACQUISITIONSCORE: flatbuffers::VOffsetT = 46;
  pub const VT_MAXIMUMACQUISITIONSCORE: flatbuffers::VOffsetT = 48;
  pub const VT_RAIDREWARDGROUPID: flatbuffers::VOffsetT = 50;
  pub const VT_BATTLEREADYTIMELINEPATH: flatbuffers::VOffsetT = 52;
  pub const VT_BATTLEREADYTIMELINEPHASESTART: flatbuffers::VOffsetT = 54;
  pub const VT_BATTLEREADYTIMELINEPHASEEND: flatbuffers::VOffsetT = 56;
  pub const VT_VICTORYTIMELINEPATH: flatbuffers::VOffsetT = 58;
  pub const VT_PHASECHANGETIMELINEPATH: flatbuffers::VOffsetT = 60;
  pub const VT_TIMELINEPHASE: flatbuffers::VOffsetT = 62;
  pub const VT_ENTERSCENARIOKEY: flatbuffers::VOffsetT = 64;
  pub const VT_CLEARSCENARIOKEY: flatbuffers::VOffsetT = 66;
  pub const VT_SHOWSKILLCARD: flatbuffers::VOffsetT = 68;
  pub const VT_BOSSBGINFOKEY: flatbuffers::VOffsetT = 70;
  pub const VT_ECHELONEXTENSIONTYPE: flatbuffers::VOffsetT = 72;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RaidStageExcel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RaidStageExcelArgs<'args>
  ) -> flatbuffers::WIPOffset<RaidStageExcel<'bldr>> {
    let mut builder = RaidStageExcelBuilder::new(_fbb);
    let key = table_encryption_service::create_key(b"RaidStage");
      let x = args.TimeLinePhase;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_TimeLinePhase(x);
      let x = args.RaidRewardGroupId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_RaidRewardGroupId(x);
      let x = args.MaximumAcquisitionScore;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_MaximumAcquisitionScore(x);
      let x = args.MinimumAcquisitionScore;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_MinimumAcquisitionScore(x);
      let x = args.HPPercentScore;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_HPPercentScore(x);
      let x = args.PerSecondMinusScore;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_PerSecondMinusScore(x);
      let x = args.MaximumScore;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_MaximumScore(x);
      let x = args.DefaultClearScore;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_DefaultClearScore(x);
      let x = args.GroundId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_GroundId(x);
      let x = args.BattleDuration;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_BattleDuration(x);
      let x = args.MaxPlayerCount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_MaxPlayerCount(x);
      let x = args.RaidCharacterId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_RaidCharacterId(x);
      let x = args.Id;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_Id(x);
      let x = args.EchelonExtensionType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_EchelonExtensionType(x);
      let x = args.BossBGInfoKey;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_uint(x, &key) } else { x };
      builder.add_BossBGInfoKey(x);
      let x = args.ClearScenarioKey;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_uint(x, &key) } else { x };
      builder.add_ClearScenarioKey(x);
      let x = args.EnterScenarioKey;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_uint(x, &key) } else { x };
      builder.add_EnterScenarioKey(x);
      if let Some(x) = args.PhaseChangeTimelinePath {
        builder.add_PhaseChangeTimelinePath(x);
      }
      if let Some(x) = args.VictoryTimelinePath {
        builder.add_VictoryTimelinePath(x);
      }
      if let Some(x) = args.BattleReadyTimelinePhaseEnd {
        builder.add_BattleReadyTimelinePhaseEnd(x);
      }
      if let Some(x) = args.BattleReadyTimelinePhaseStart {
        builder.add_BattleReadyTimelinePhaseStart(x);
      }
      if let Some(x) = args.BattleReadyTimelinePath {
        builder.add_BattleReadyTimelinePath(x);
      }
      let x = args.TacticEnvironment;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_TacticEnvironment(x);
      if let Some(x) = args.EnterTimeLine {
        builder.add_EnterTimeLine(x);
      }
      if let Some(x) = args.GroundDevName {
        builder.add_GroundDevName(x);
      }
      let x = args.RaidRoomLifeTime;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_RaidRoomLifeTime(x);
      let x = args.Difficulty;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_Difficulty(x);
      if let Some(x) = args.BossCharacterId {
        builder.add_BossCharacterId(x);
      }
      if let Some(x) = args.BGPath {
        builder.add_BGPath(x);
      }
      if let Some(x) = args.PortraitPath {
        builder.add_PortraitPath(x);
      }
      if let Some(x) = args.RaidBossGroup {
        builder.add_RaidBossGroup(x);
      }
      builder.add_ShowSkillCard(args.ShowSkillCard);
      builder.add_DifficultyOpenCondition(args.DifficultyOpenCondition);
      builder.add_UseBossAIPhaseSync(args.UseBossAIPhaseSync);
      builder.add_UseBossIndex(args.UseBossIndex);
    builder.finish()
  }

  pub fn unpack(&self) -> RaidStageExcelT {
    let key = table_encryption_service::create_key(b"RaidStage");
      let Id = self.Id();
      let UseBossIndex = self.UseBossIndex();
      let UseBossAIPhaseSync = self.UseBossAIPhaseSync();
    let RaidBossGroup = self.RaidBossGroup().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let PortraitPath = self.PortraitPath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let BGPath = self.BGPath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let RaidCharacterId = self.RaidCharacterId();
    let BossCharacterId = self.BossCharacterId().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_long(*val, &key) } else { *val }).collect()
    });
      let Difficulty = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.Difficulty(), &key)
      } else {
        self.Difficulty()
      };
      let DifficultyOpenCondition = self.DifficultyOpenCondition();
      let MaxPlayerCount = self.MaxPlayerCount();
      let RaidRoomLifeTime = self.RaidRoomLifeTime();
      let BattleDuration = self.BattleDuration();
      let GroundId = self.GroundId();
    let GroundDevName = self.GroundDevName().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let EnterTimeLine = self.EnterTimeLine().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let TacticEnvironment = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.TacticEnvironment(), &key)
      } else {
        self.TacticEnvironment()
      };
      let DefaultClearScore = self.DefaultClearScore();
      let MaximumScore = self.MaximumScore();
      let PerSecondMinusScore = self.PerSecondMinusScore();
      let HPPercentScore = self.HPPercentScore();
      let MinimumAcquisitionScore = self.MinimumAcquisitionScore();
      let MaximumAcquisitionScore = self.MaximumAcquisitionScore();
      let RaidRewardGroupId = self.RaidRewardGroupId();
    let BattleReadyTimelinePath = self.BattleReadyTimelinePath().map(|x| {
      x.iter().map(|s| if table_encryption_service::use_encryption() { table_encryption_service::convert_string(s, &key).unwrap() } else { s.to_string() }).collect()
    });
    let BattleReadyTimelinePhaseStart = self.BattleReadyTimelinePhaseStart().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_int(*val, &key) } else { *val }).collect()
    });
    let BattleReadyTimelinePhaseEnd = self.BattleReadyTimelinePhaseEnd().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_int(*val, &key) } else { *val }).collect()
    });
    let VictoryTimelinePath = self.VictoryTimelinePath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let PhaseChangeTimelinePath = self.PhaseChangeTimelinePath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let TimeLinePhase = self.TimeLinePhase();
      let EnterScenarioKey = self.EnterScenarioKey();
      let ClearScenarioKey = self.ClearScenarioKey();
      let ShowSkillCard = self.ShowSkillCard();
      let BossBGInfoKey = self.BossBGInfoKey();
      let EchelonExtensionType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.EchelonExtensionType(), &key)
      } else {
        self.EchelonExtensionType()
      };
    RaidStageExcelT {
      Id,
      UseBossIndex,
      UseBossAIPhaseSync,
      RaidBossGroup,
      PortraitPath,
      BGPath,
      RaidCharacterId,
      BossCharacterId,
      Difficulty,
      DifficultyOpenCondition,
      MaxPlayerCount,
      RaidRoomLifeTime,
      BattleDuration,
      GroundId,
      GroundDevName,
      EnterTimeLine,
      TacticEnvironment,
      DefaultClearScore,
      MaximumScore,
      PerSecondMinusScore,
      HPPercentScore,
      MinimumAcquisitionScore,
      MaximumAcquisitionScore,
      RaidRewardGroupId,
      BattleReadyTimelinePath,
      BattleReadyTimelinePhaseStart,
      BattleReadyTimelinePhaseEnd,
      VictoryTimelinePath,
      PhaseChangeTimelinePath,
      TimeLinePhase,
      EnterScenarioKey,
      ClearScenarioKey,
      ShowSkillCard,
      BossBGInfoKey,
      EchelonExtensionType,
    }
  }

  #[inline]
  pub fn Id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(RaidStageExcel::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn UseBossIndex(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(RaidStageExcel::VT_USEBOSSINDEX, Some(false)).unwrap()}
  }
  #[inline]
  pub fn UseBossAIPhaseSync(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(RaidStageExcel::VT_USEBOSSAIPHASESYNC, Some(false)).unwrap()}
  }
  #[inline]
  pub fn RaidBossGroup(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RaidStageExcel::VT_RAIDBOSSGROUP, None)}
  }
  #[inline]
  pub fn PortraitPath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RaidStageExcel::VT_PORTRAITPATH, None)}
  }
  #[inline]
  pub fn BGPath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RaidStageExcel::VT_BGPATH, None)}
  }
  #[inline]
  pub fn RaidCharacterId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(RaidStageExcel::VT_RAIDCHARACTERID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn BossCharacterId(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(RaidStageExcel::VT_BOSSCHARACTERID, None)}
  }
  #[inline]
  pub fn Difficulty(&self) -> Difficulty {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Difficulty>(RaidStageExcel::VT_DIFFICULTY, Some(Difficulty::Normal)).unwrap()}
  }
  #[inline]
  pub fn DifficultyOpenCondition(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(RaidStageExcel::VT_DIFFICULTYOPENCONDITION, Some(false)).unwrap()}
  }
  #[inline]
  pub fn MaxPlayerCount(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(RaidStageExcel::VT_MAXPLAYERCOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn RaidRoomLifeTime(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(RaidStageExcel::VT_RAIDROOMLIFETIME, Some(0)).unwrap()}
  }
  #[inline]
  pub fn BattleDuration(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(RaidStageExcel::VT_BATTLEDURATION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn GroundId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(RaidStageExcel::VT_GROUNDID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn GroundDevName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RaidStageExcel::VT_GROUNDDEVNAME, None)}
  }
  #[inline]
  pub fn EnterTimeLine(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RaidStageExcel::VT_ENTERTIMELINE, None)}
  }
  #[inline]
  pub fn TacticEnvironment(&self) -> TacticEnvironment {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TacticEnvironment>(RaidStageExcel::VT_TACTICENVIRONMENT, Some(TacticEnvironment::None)).unwrap()}
  }
  #[inline]
  pub fn DefaultClearScore(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(RaidStageExcel::VT_DEFAULTCLEARSCORE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn MaximumScore(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(RaidStageExcel::VT_MAXIMUMSCORE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn PerSecondMinusScore(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(RaidStageExcel::VT_PERSECONDMINUSSCORE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn HPPercentScore(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(RaidStageExcel::VT_HPPERCENTSCORE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn MinimumAcquisitionScore(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(RaidStageExcel::VT_MINIMUMACQUISITIONSCORE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn MaximumAcquisitionScore(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(RaidStageExcel::VT_MAXIMUMACQUISITIONSCORE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn RaidRewardGroupId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(RaidStageExcel::VT_RAIDREWARDGROUPID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn BattleReadyTimelinePath(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(RaidStageExcel::VT_BATTLEREADYTIMELINEPATH, None)}
  }
  #[inline]
  pub fn BattleReadyTimelinePhaseStart(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(RaidStageExcel::VT_BATTLEREADYTIMELINEPHASESTART, None)}
  }
  #[inline]
  pub fn BattleReadyTimelinePhaseEnd(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(RaidStageExcel::VT_BATTLEREADYTIMELINEPHASEEND, None)}
  }
  #[inline]
  pub fn VictoryTimelinePath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RaidStageExcel::VT_VICTORYTIMELINEPATH, None)}
  }
  #[inline]
  pub fn PhaseChangeTimelinePath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RaidStageExcel::VT_PHASECHANGETIMELINEPATH, None)}
  }
  #[inline]
  pub fn TimeLinePhase(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(RaidStageExcel::VT_TIMELINEPHASE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EnterScenarioKey(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(RaidStageExcel::VT_ENTERSCENARIOKEY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ClearScenarioKey(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(RaidStageExcel::VT_CLEARSCENARIOKEY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ShowSkillCard(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(RaidStageExcel::VT_SHOWSKILLCARD, Some(false)).unwrap()}
  }
  #[inline]
  pub fn BossBGInfoKey(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(RaidStageExcel::VT_BOSSBGINFOKEY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EchelonExtensionType(&self) -> EchelonExtensionType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<EchelonExtensionType>(RaidStageExcel::VT_ECHELONEXTENSIONTYPE, Some(EchelonExtensionType::Base)).unwrap()}
  }
}

impl flatbuffers::Verifiable for RaidStageExcel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("Id", Self::VT_ID, false)?
     .visit_field::<bool>("UseBossIndex", Self::VT_USEBOSSINDEX, false)?
     .visit_field::<bool>("UseBossAIPhaseSync", Self::VT_USEBOSSAIPHASESYNC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("RaidBossGroup", Self::VT_RAIDBOSSGROUP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PortraitPath", Self::VT_PORTRAITPATH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("BGPath", Self::VT_BGPATH, false)?
     .visit_field::<i64>("RaidCharacterId", Self::VT_RAIDCHARACTERID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("BossCharacterId", Self::VT_BOSSCHARACTERID, false)?
     .visit_field::<Difficulty>("Difficulty", Self::VT_DIFFICULTY, false)?
     .visit_field::<bool>("DifficultyOpenCondition", Self::VT_DIFFICULTYOPENCONDITION, false)?
     .visit_field::<i64>("MaxPlayerCount", Self::VT_MAXPLAYERCOUNT, false)?
     .visit_field::<i32>("RaidRoomLifeTime", Self::VT_RAIDROOMLIFETIME, false)?
     .visit_field::<i64>("BattleDuration", Self::VT_BATTLEDURATION, false)?
     .visit_field::<i64>("GroundId", Self::VT_GROUNDID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("GroundDevName", Self::VT_GROUNDDEVNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EnterTimeLine", Self::VT_ENTERTIMELINE, false)?
     .visit_field::<TacticEnvironment>("TacticEnvironment", Self::VT_TACTICENVIRONMENT, false)?
     .visit_field::<i64>("DefaultClearScore", Self::VT_DEFAULTCLEARSCORE, false)?
     .visit_field::<i64>("MaximumScore", Self::VT_MAXIMUMSCORE, false)?
     .visit_field::<i64>("PerSecondMinusScore", Self::VT_PERSECONDMINUSSCORE, false)?
     .visit_field::<i64>("HPPercentScore", Self::VT_HPPERCENTSCORE, false)?
     .visit_field::<i64>("MinimumAcquisitionScore", Self::VT_MINIMUMACQUISITIONSCORE, false)?
     .visit_field::<i64>("MaximumAcquisitionScore", Self::VT_MAXIMUMACQUISITIONSCORE, false)?
     .visit_field::<i64>("RaidRewardGroupId", Self::VT_RAIDREWARDGROUPID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("BattleReadyTimelinePath", Self::VT_BATTLEREADYTIMELINEPATH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("BattleReadyTimelinePhaseStart", Self::VT_BATTLEREADYTIMELINEPHASESTART, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("BattleReadyTimelinePhaseEnd", Self::VT_BATTLEREADYTIMELINEPHASEEND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("VictoryTimelinePath", Self::VT_VICTORYTIMELINEPATH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PhaseChangeTimelinePath", Self::VT_PHASECHANGETIMELINEPATH, false)?
     .visit_field::<i64>("TimeLinePhase", Self::VT_TIMELINEPHASE, false)?
     .visit_field::<u32>("EnterScenarioKey", Self::VT_ENTERSCENARIOKEY, false)?
     .visit_field::<u32>("ClearScenarioKey", Self::VT_CLEARSCENARIOKEY, false)?
     .visit_field::<bool>("ShowSkillCard", Self::VT_SHOWSKILLCARD, false)?
     .visit_field::<u32>("BossBGInfoKey", Self::VT_BOSSBGINFOKEY, false)?
     .visit_field::<EchelonExtensionType>("EchelonExtensionType", Self::VT_ECHELONEXTENSIONTYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct RaidStageExcelArgs<'a> {
    pub Id: i64,
    pub UseBossIndex: bool,
    pub UseBossAIPhaseSync: bool,
    pub RaidBossGroup: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PortraitPath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub BGPath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub RaidCharacterId: i64,
    pub BossCharacterId: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub Difficulty: Difficulty,
    pub DifficultyOpenCondition: bool,
    pub MaxPlayerCount: i64,
    pub RaidRoomLifeTime: i32,
    pub BattleDuration: i64,
    pub GroundId: i64,
    pub GroundDevName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EnterTimeLine: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TacticEnvironment: TacticEnvironment,
    pub DefaultClearScore: i64,
    pub MaximumScore: i64,
    pub PerSecondMinusScore: i64,
    pub HPPercentScore: i64,
    pub MinimumAcquisitionScore: i64,
    pub MaximumAcquisitionScore: i64,
    pub RaidRewardGroupId: i64,
    pub BattleReadyTimelinePath: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub BattleReadyTimelinePhaseStart: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub BattleReadyTimelinePhaseEnd: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub VictoryTimelinePath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PhaseChangeTimelinePath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TimeLinePhase: i64,
    pub EnterScenarioKey: u32,
    pub ClearScenarioKey: u32,
    pub ShowSkillCard: bool,
    pub BossBGInfoKey: u32,
    pub EchelonExtensionType: EchelonExtensionType,
}
impl<'a> Default for RaidStageExcelArgs<'a> {
  #[inline]
  fn default() -> Self {
    RaidStageExcelArgs {
      Id: 0,
      UseBossIndex: false,
      UseBossAIPhaseSync: false,
      RaidBossGroup: None,
      PortraitPath: None,
      BGPath: None,
      RaidCharacterId: 0,
      BossCharacterId: None,
      Difficulty: Difficulty::Normal,
      DifficultyOpenCondition: false,
      MaxPlayerCount: 0,
      RaidRoomLifeTime: 0,
      BattleDuration: 0,
      GroundId: 0,
      GroundDevName: None,
      EnterTimeLine: None,
      TacticEnvironment: TacticEnvironment::None,
      DefaultClearScore: 0,
      MaximumScore: 0,
      PerSecondMinusScore: 0,
      HPPercentScore: 0,
      MinimumAcquisitionScore: 0,
      MaximumAcquisitionScore: 0,
      RaidRewardGroupId: 0,
      BattleReadyTimelinePath: None,
      BattleReadyTimelinePhaseStart: None,
      BattleReadyTimelinePhaseEnd: None,
      VictoryTimelinePath: None,
      PhaseChangeTimelinePath: None,
      TimeLinePhase: 0,
      EnterScenarioKey: 0,
      ClearScenarioKey: 0,
      ShowSkillCard: false,
      BossBGInfoKey: 0,
      EchelonExtensionType: EchelonExtensionType::Base,
    }
  }
}

impl Serialize for RaidStageExcel<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("RaidStageExcel", 35)?;
      s.serialize_field("Id", &self.Id())?;
      s.serialize_field("UseBossIndex", &self.UseBossIndex())?;
      s.serialize_field("UseBossAIPhaseSync", &self.UseBossAIPhaseSync())?;
      if let Some(f) = self.RaidBossGroup() {
        s.serialize_field("RaidBossGroup", &f)?;
      } else {
        s.skip_field("RaidBossGroup")?;
      }
      if let Some(f) = self.PortraitPath() {
        s.serialize_field("PortraitPath", &f)?;
      } else {
        s.skip_field("PortraitPath")?;
      }
      if let Some(f) = self.BGPath() {
        s.serialize_field("BGPath", &f)?;
      } else {
        s.skip_field("BGPath")?;
      }
      s.serialize_field("RaidCharacterId", &self.RaidCharacterId())?;
      if let Some(f) = self.BossCharacterId() {
        s.serialize_field("BossCharacterId", &f)?;
      } else {
        s.skip_field("BossCharacterId")?;
      }
      s.serialize_field("Difficulty", &self.Difficulty())?;
      s.serialize_field("DifficultyOpenCondition", &self.DifficultyOpenCondition())?;
      s.serialize_field("MaxPlayerCount", &self.MaxPlayerCount())?;
      s.serialize_field("RaidRoomLifeTime", &self.RaidRoomLifeTime())?;
      s.serialize_field("BattleDuration", &self.BattleDuration())?;
      s.serialize_field("GroundId", &self.GroundId())?;
      if let Some(f) = self.GroundDevName() {
        s.serialize_field("GroundDevName", &f)?;
      } else {
        s.skip_field("GroundDevName")?;
      }
      if let Some(f) = self.EnterTimeLine() {
        s.serialize_field("EnterTimeLine", &f)?;
      } else {
        s.skip_field("EnterTimeLine")?;
      }
      s.serialize_field("TacticEnvironment", &self.TacticEnvironment())?;
      s.serialize_field("DefaultClearScore", &self.DefaultClearScore())?;
      s.serialize_field("MaximumScore", &self.MaximumScore())?;
      s.serialize_field("PerSecondMinusScore", &self.PerSecondMinusScore())?;
      s.serialize_field("HPPercentScore", &self.HPPercentScore())?;
      s.serialize_field("MinimumAcquisitionScore", &self.MinimumAcquisitionScore())?;
      s.serialize_field("MaximumAcquisitionScore", &self.MaximumAcquisitionScore())?;
      s.serialize_field("RaidRewardGroupId", &self.RaidRewardGroupId())?;
      if let Some(f) = self.BattleReadyTimelinePath() {
        s.serialize_field("BattleReadyTimelinePath", &f)?;
      } else {
        s.skip_field("BattleReadyTimelinePath")?;
      }
      if let Some(f) = self.BattleReadyTimelinePhaseStart() {
        s.serialize_field("BattleReadyTimelinePhaseStart", &f)?;
      } else {
        s.skip_field("BattleReadyTimelinePhaseStart")?;
      }
      if let Some(f) = self.BattleReadyTimelinePhaseEnd() {
        s.serialize_field("BattleReadyTimelinePhaseEnd", &f)?;
      } else {
        s.skip_field("BattleReadyTimelinePhaseEnd")?;
      }
      if let Some(f) = self.VictoryTimelinePath() {
        s.serialize_field("VictoryTimelinePath", &f)?;
      } else {
        s.skip_field("VictoryTimelinePath")?;
      }
      if let Some(f) = self.PhaseChangeTimelinePath() {
        s.serialize_field("PhaseChangeTimelinePath", &f)?;
      } else {
        s.skip_field("PhaseChangeTimelinePath")?;
      }
      s.serialize_field("TimeLinePhase", &self.TimeLinePhase())?;
      s.serialize_field("EnterScenarioKey", &self.EnterScenarioKey())?;
      s.serialize_field("ClearScenarioKey", &self.ClearScenarioKey())?;
      s.serialize_field("ShowSkillCard", &self.ShowSkillCard())?;
      s.serialize_field("BossBGInfoKey", &self.BossBGInfoKey())?;
      s.serialize_field("EchelonExtensionType", &self.EchelonExtensionType())?;
    s.end()
  }
}

pub struct RaidStageExcelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RaidStageExcelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_Id(&mut self, Id: i64) {
    self.fbb_.push_slot::<i64>(RaidStageExcel::VT_ID, Id, 0);
  }
  #[inline]
  pub fn add_UseBossIndex(&mut self, UseBossIndex: bool) {
    self.fbb_.push_slot::<bool>(RaidStageExcel::VT_USEBOSSINDEX, UseBossIndex, false);
  }
  #[inline]
  pub fn add_UseBossAIPhaseSync(&mut self, UseBossAIPhaseSync: bool) {
    self.fbb_.push_slot::<bool>(RaidStageExcel::VT_USEBOSSAIPHASESYNC, UseBossAIPhaseSync, false);
  }
  #[inline]
  pub fn add_RaidBossGroup(&mut self, RaidBossGroup: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RaidStageExcel::VT_RAIDBOSSGROUP, RaidBossGroup);
  }
  #[inline]
  pub fn add_PortraitPath(&mut self, PortraitPath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RaidStageExcel::VT_PORTRAITPATH, PortraitPath);
  }
  #[inline]
  pub fn add_BGPath(&mut self, BGPath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RaidStageExcel::VT_BGPATH, BGPath);
  }
  #[inline]
  pub fn add_RaidCharacterId(&mut self, RaidCharacterId: i64) {
    self.fbb_.push_slot::<i64>(RaidStageExcel::VT_RAIDCHARACTERID, RaidCharacterId, 0);
  }
  #[inline]
  pub fn add_BossCharacterId(&mut self, BossCharacterId: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RaidStageExcel::VT_BOSSCHARACTERID, BossCharacterId);
  }
  #[inline]
  pub fn add_Difficulty(&mut self, Difficulty: Difficulty) {
    self.fbb_.push_slot::<Difficulty>(RaidStageExcel::VT_DIFFICULTY, Difficulty, Difficulty::Normal);
  }
  #[inline]
  pub fn add_DifficultyOpenCondition(&mut self, DifficultyOpenCondition: bool) {
    self.fbb_.push_slot::<bool>(RaidStageExcel::VT_DIFFICULTYOPENCONDITION, DifficultyOpenCondition, false);
  }
  #[inline]
  pub fn add_MaxPlayerCount(&mut self, MaxPlayerCount: i64) {
    self.fbb_.push_slot::<i64>(RaidStageExcel::VT_MAXPLAYERCOUNT, MaxPlayerCount, 0);
  }
  #[inline]
  pub fn add_RaidRoomLifeTime(&mut self, RaidRoomLifeTime: i32) {
    self.fbb_.push_slot::<i32>(RaidStageExcel::VT_RAIDROOMLIFETIME, RaidRoomLifeTime, 0);
  }
  #[inline]
  pub fn add_BattleDuration(&mut self, BattleDuration: i64) {
    self.fbb_.push_slot::<i64>(RaidStageExcel::VT_BATTLEDURATION, BattleDuration, 0);
  }
  #[inline]
  pub fn add_GroundId(&mut self, GroundId: i64) {
    self.fbb_.push_slot::<i64>(RaidStageExcel::VT_GROUNDID, GroundId, 0);
  }
  #[inline]
  pub fn add_GroundDevName(&mut self, GroundDevName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RaidStageExcel::VT_GROUNDDEVNAME, GroundDevName);
  }
  #[inline]
  pub fn add_EnterTimeLine(&mut self, EnterTimeLine: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RaidStageExcel::VT_ENTERTIMELINE, EnterTimeLine);
  }
  #[inline]
  pub fn add_TacticEnvironment(&mut self, TacticEnvironment: TacticEnvironment) {
    self.fbb_.push_slot::<TacticEnvironment>(RaidStageExcel::VT_TACTICENVIRONMENT, TacticEnvironment, TacticEnvironment::None);
  }
  #[inline]
  pub fn add_DefaultClearScore(&mut self, DefaultClearScore: i64) {
    self.fbb_.push_slot::<i64>(RaidStageExcel::VT_DEFAULTCLEARSCORE, DefaultClearScore, 0);
  }
  #[inline]
  pub fn add_MaximumScore(&mut self, MaximumScore: i64) {
    self.fbb_.push_slot::<i64>(RaidStageExcel::VT_MAXIMUMSCORE, MaximumScore, 0);
  }
  #[inline]
  pub fn add_PerSecondMinusScore(&mut self, PerSecondMinusScore: i64) {
    self.fbb_.push_slot::<i64>(RaidStageExcel::VT_PERSECONDMINUSSCORE, PerSecondMinusScore, 0);
  }
  #[inline]
  pub fn add_HPPercentScore(&mut self, HPPercentScore: i64) {
    self.fbb_.push_slot::<i64>(RaidStageExcel::VT_HPPERCENTSCORE, HPPercentScore, 0);
  }
  #[inline]
  pub fn add_MinimumAcquisitionScore(&mut self, MinimumAcquisitionScore: i64) {
    self.fbb_.push_slot::<i64>(RaidStageExcel::VT_MINIMUMACQUISITIONSCORE, MinimumAcquisitionScore, 0);
  }
  #[inline]
  pub fn add_MaximumAcquisitionScore(&mut self, MaximumAcquisitionScore: i64) {
    self.fbb_.push_slot::<i64>(RaidStageExcel::VT_MAXIMUMACQUISITIONSCORE, MaximumAcquisitionScore, 0);
  }
  #[inline]
  pub fn add_RaidRewardGroupId(&mut self, RaidRewardGroupId: i64) {
    self.fbb_.push_slot::<i64>(RaidStageExcel::VT_RAIDREWARDGROUPID, RaidRewardGroupId, 0);
  }
  #[inline]
  pub fn add_BattleReadyTimelinePath(&mut self, BattleReadyTimelinePath: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RaidStageExcel::VT_BATTLEREADYTIMELINEPATH, BattleReadyTimelinePath);
  }
  #[inline]
  pub fn add_BattleReadyTimelinePhaseStart(&mut self, BattleReadyTimelinePhaseStart: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RaidStageExcel::VT_BATTLEREADYTIMELINEPHASESTART, BattleReadyTimelinePhaseStart);
  }
  #[inline]
  pub fn add_BattleReadyTimelinePhaseEnd(&mut self, BattleReadyTimelinePhaseEnd: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RaidStageExcel::VT_BATTLEREADYTIMELINEPHASEEND, BattleReadyTimelinePhaseEnd);
  }
  #[inline]
  pub fn add_VictoryTimelinePath(&mut self, VictoryTimelinePath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RaidStageExcel::VT_VICTORYTIMELINEPATH, VictoryTimelinePath);
  }
  #[inline]
  pub fn add_PhaseChangeTimelinePath(&mut self, PhaseChangeTimelinePath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RaidStageExcel::VT_PHASECHANGETIMELINEPATH, PhaseChangeTimelinePath);
  }
  #[inline]
  pub fn add_TimeLinePhase(&mut self, TimeLinePhase: i64) {
    self.fbb_.push_slot::<i64>(RaidStageExcel::VT_TIMELINEPHASE, TimeLinePhase, 0);
  }
  #[inline]
  pub fn add_EnterScenarioKey(&mut self, EnterScenarioKey: u32) {
    self.fbb_.push_slot::<u32>(RaidStageExcel::VT_ENTERSCENARIOKEY, EnterScenarioKey, 0);
  }
  #[inline]
  pub fn add_ClearScenarioKey(&mut self, ClearScenarioKey: u32) {
    self.fbb_.push_slot::<u32>(RaidStageExcel::VT_CLEARSCENARIOKEY, ClearScenarioKey, 0);
  }
  #[inline]
  pub fn add_ShowSkillCard(&mut self, ShowSkillCard: bool) {
    self.fbb_.push_slot::<bool>(RaidStageExcel::VT_SHOWSKILLCARD, ShowSkillCard, false);
  }
  #[inline]
  pub fn add_BossBGInfoKey(&mut self, BossBGInfoKey: u32) {
    self.fbb_.push_slot::<u32>(RaidStageExcel::VT_BOSSBGINFOKEY, BossBGInfoKey, 0);
  }
  #[inline]
  pub fn add_EchelonExtensionType(&mut self, EchelonExtensionType: EchelonExtensionType) {
    self.fbb_.push_slot::<EchelonExtensionType>(RaidStageExcel::VT_ECHELONEXTENSIONTYPE, EchelonExtensionType, EchelonExtensionType::Base);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RaidStageExcelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RaidStageExcelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RaidStageExcel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RaidStageExcel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RaidStageExcel");
      ds.field("Id", &self.Id());
      ds.field("UseBossIndex", &self.UseBossIndex());
      ds.field("UseBossAIPhaseSync", &self.UseBossAIPhaseSync());
      ds.field("RaidBossGroup", &self.RaidBossGroup());
      ds.field("PortraitPath", &self.PortraitPath());
      ds.field("BGPath", &self.BGPath());
      ds.field("RaidCharacterId", &self.RaidCharacterId());
      ds.field("BossCharacterId", &self.BossCharacterId());
      ds.field("Difficulty", &self.Difficulty());
      ds.field("DifficultyOpenCondition", &self.DifficultyOpenCondition());
      ds.field("MaxPlayerCount", &self.MaxPlayerCount());
      ds.field("RaidRoomLifeTime", &self.RaidRoomLifeTime());
      ds.field("BattleDuration", &self.BattleDuration());
      ds.field("GroundId", &self.GroundId());
      ds.field("GroundDevName", &self.GroundDevName());
      ds.field("EnterTimeLine", &self.EnterTimeLine());
      ds.field("TacticEnvironment", &self.TacticEnvironment());
      ds.field("DefaultClearScore", &self.DefaultClearScore());
      ds.field("MaximumScore", &self.MaximumScore());
      ds.field("PerSecondMinusScore", &self.PerSecondMinusScore());
      ds.field("HPPercentScore", &self.HPPercentScore());
      ds.field("MinimumAcquisitionScore", &self.MinimumAcquisitionScore());
      ds.field("MaximumAcquisitionScore", &self.MaximumAcquisitionScore());
      ds.field("RaidRewardGroupId", &self.RaidRewardGroupId());
      ds.field("BattleReadyTimelinePath", &self.BattleReadyTimelinePath());
      ds.field("BattleReadyTimelinePhaseStart", &self.BattleReadyTimelinePhaseStart());
      ds.field("BattleReadyTimelinePhaseEnd", &self.BattleReadyTimelinePhaseEnd());
      ds.field("VictoryTimelinePath", &self.VictoryTimelinePath());
      ds.field("PhaseChangeTimelinePath", &self.PhaseChangeTimelinePath());
      ds.field("TimeLinePhase", &self.TimeLinePhase());
      ds.field("EnterScenarioKey", &self.EnterScenarioKey());
      ds.field("ClearScenarioKey", &self.ClearScenarioKey());
      ds.field("ShowSkillCard", &self.ShowSkillCard());
      ds.field("BossBGInfoKey", &self.BossBGInfoKey());
      ds.field("EchelonExtensionType", &self.EchelonExtensionType());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct RaidStageExcelT {
  pub Id: i64,
  pub UseBossIndex: bool,
  pub UseBossAIPhaseSync: bool,
  pub RaidBossGroup: Option<String>,
  pub PortraitPath: Option<String>,
  pub BGPath: Option<String>,
  pub RaidCharacterId: i64,
  pub BossCharacterId: Option<Vec<i64>>,
  pub Difficulty: Difficulty,
  pub DifficultyOpenCondition: bool,
  pub MaxPlayerCount: i64,
  pub RaidRoomLifeTime: i32,
  pub BattleDuration: i64,
  pub GroundId: i64,
  pub GroundDevName: Option<String>,
  pub EnterTimeLine: Option<String>,
  pub TacticEnvironment: TacticEnvironment,
  pub DefaultClearScore: i64,
  pub MaximumScore: i64,
  pub PerSecondMinusScore: i64,
  pub HPPercentScore: i64,
  pub MinimumAcquisitionScore: i64,
  pub MaximumAcquisitionScore: i64,
  pub RaidRewardGroupId: i64,
  pub BattleReadyTimelinePath: Option<Vec<String>>,
  pub BattleReadyTimelinePhaseStart: Option<Vec<i32>>,
  pub BattleReadyTimelinePhaseEnd: Option<Vec<i32>>,
  pub VictoryTimelinePath: Option<String>,
  pub PhaseChangeTimelinePath: Option<String>,
  pub TimeLinePhase: i64,
  pub EnterScenarioKey: u32,
  pub ClearScenarioKey: u32,
  pub ShowSkillCard: bool,
  pub BossBGInfoKey: u32,
  pub EchelonExtensionType: EchelonExtensionType,
}
impl Default for RaidStageExcelT {
  fn default() -> Self {
    Self {
      Id: 0,
      UseBossIndex: false,
      UseBossAIPhaseSync: false,
      RaidBossGroup: None,
      PortraitPath: None,
      BGPath: None,
      RaidCharacterId: 0,
      BossCharacterId: None,
      Difficulty: Difficulty::Normal,
      DifficultyOpenCondition: false,
      MaxPlayerCount: 0,
      RaidRoomLifeTime: 0,
      BattleDuration: 0,
      GroundId: 0,
      GroundDevName: None,
      EnterTimeLine: None,
      TacticEnvironment: TacticEnvironment::None,
      DefaultClearScore: 0,
      MaximumScore: 0,
      PerSecondMinusScore: 0,
      HPPercentScore: 0,
      MinimumAcquisitionScore: 0,
      MaximumAcquisitionScore: 0,
      RaidRewardGroupId: 0,
      BattleReadyTimelinePath: None,
      BattleReadyTimelinePhaseStart: None,
      BattleReadyTimelinePhaseEnd: None,
      VictoryTimelinePath: None,
      PhaseChangeTimelinePath: None,
      TimeLinePhase: 0,
      EnterScenarioKey: 0,
      ClearScenarioKey: 0,
      ShowSkillCard: false,
      BossBGInfoKey: 0,
      EchelonExtensionType: EchelonExtensionType::Base,
    }
  }
}
impl RaidStageExcelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<RaidStageExcel<'b>> {
    let Id = self.Id;
    let UseBossIndex = self.UseBossIndex;
    let UseBossAIPhaseSync = self.UseBossAIPhaseSync;
    let RaidBossGroup = self.RaidBossGroup.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PortraitPath = self.PortraitPath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let BGPath = self.BGPath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let RaidCharacterId = self.RaidCharacterId;
    let BossCharacterId = self.BossCharacterId.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let Difficulty = self.Difficulty;
    let DifficultyOpenCondition = self.DifficultyOpenCondition;
    let MaxPlayerCount = self.MaxPlayerCount;
    let RaidRoomLifeTime = self.RaidRoomLifeTime;
    let BattleDuration = self.BattleDuration;
    let GroundId = self.GroundId;
    let GroundDevName = self.GroundDevName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EnterTimeLine = self.EnterTimeLine.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TacticEnvironment = self.TacticEnvironment;
    let DefaultClearScore = self.DefaultClearScore;
    let MaximumScore = self.MaximumScore;
    let PerSecondMinusScore = self.PerSecondMinusScore;
    let HPPercentScore = self.HPPercentScore;
    let MinimumAcquisitionScore = self.MinimumAcquisitionScore;
    let MaximumAcquisitionScore = self.MaximumAcquisitionScore;
    let RaidRewardGroupId = self.RaidRewardGroupId;
    let BattleReadyTimelinePath = self.BattleReadyTimelinePath.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let BattleReadyTimelinePhaseStart = self.BattleReadyTimelinePhaseStart.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let BattleReadyTimelinePhaseEnd = self.BattleReadyTimelinePhaseEnd.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let VictoryTimelinePath = self.VictoryTimelinePath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PhaseChangeTimelinePath = self.PhaseChangeTimelinePath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TimeLinePhase = self.TimeLinePhase;
    let EnterScenarioKey = self.EnterScenarioKey;
    let ClearScenarioKey = self.ClearScenarioKey;
    let ShowSkillCard = self.ShowSkillCard;
    let BossBGInfoKey = self.BossBGInfoKey;
    let EchelonExtensionType = self.EchelonExtensionType;
    RaidStageExcel::create(_fbb, &RaidStageExcelArgs{
      Id,
      UseBossIndex,
      UseBossAIPhaseSync,
      RaidBossGroup,
      PortraitPath,
      BGPath,
      RaidCharacterId,
      BossCharacterId,
      Difficulty,
      DifficultyOpenCondition,
      MaxPlayerCount,
      RaidRoomLifeTime,
      BattleDuration,
      GroundId,
      GroundDevName,
      EnterTimeLine,
      TacticEnvironment,
      DefaultClearScore,
      MaximumScore,
      PerSecondMinusScore,
      HPPercentScore,
      MinimumAcquisitionScore,
      MaximumAcquisitionScore,
      RaidRewardGroupId,
      BattleReadyTimelinePath,
      BattleReadyTimelinePhaseStart,
      BattleReadyTimelinePhaseEnd,
      VictoryTimelinePath,
      PhaseChangeTimelinePath,
      TimeLinePhase,
      EnterScenarioKey,
      ClearScenarioKey,
      ShowSkillCard,
      BossBGInfoKey,
      EchelonExtensionType,
    })
  }
}
