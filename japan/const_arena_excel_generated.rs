// automatically generated by the FlatBuffers compiler, do not modify
// @generated
#![allow(unused_imports, dead_code)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum ConstArenaExcelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ConstArenaExcel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConstArenaExcel<'a> {
  type Inner = ConstArenaExcel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ConstArenaExcel<'a> {
  pub const VT_ATTACKCOOLTIME: flatbuffers::VOffsetT = 4;
  pub const VT_BATTLEDURATION: flatbuffers::VOffsetT = 6;
  pub const VT_DEFENSECOOLTIME: flatbuffers::VOffsetT = 8;
  pub const VT_TSSSTARTCOOLTIME: flatbuffers::VOffsetT = 10;
  pub const VT_ENDALARM: flatbuffers::VOffsetT = 12;
  pub const VT_TIMEREWARDMAXAMOUNT: flatbuffers::VOffsetT = 14;
  pub const VT_ENTERCOSTTYPE: flatbuffers::VOffsetT = 16;
  pub const VT_ENTERCOSTID: flatbuffers::VOffsetT = 18;
  pub const VT_TICKETCOST: flatbuffers::VOffsetT = 20;
  pub const VT_DAILYREWARDRESETTIME: flatbuffers::VOffsetT = 22;
  pub const VT_OPENSCENARIOID: flatbuffers::VOffsetT = 24;
  pub const VT_CHARACTERSLOTHIDERANK: flatbuffers::VOffsetT = 26;
  pub const VT_MAPSLOTHIDERANK: flatbuffers::VOffsetT = 28;
  pub const VT_RELATIVEOPPONENTRANKSTART: flatbuffers::VOffsetT = 30;
  pub const VT_RELATIVEOPPONENTRANKEND: flatbuffers::VOffsetT = 32;
  pub const VT_MODIFIEDSTATTYPE: flatbuffers::VOffsetT = 34;
  pub const VT_STATMULFACTOR: flatbuffers::VOffsetT = 36;
  pub const VT_STATSUMFACTOR: flatbuffers::VOffsetT = 38;
  pub const VT_NPCNAME: flatbuffers::VOffsetT = 40;
  pub const VT_NPCMAINCHARACTERCOUNT: flatbuffers::VOffsetT = 42;
  pub const VT_NPCSUPPORTCHARACTERCOUNT: flatbuffers::VOffsetT = 44;
  pub const VT_NPCCHARACTERSKILLLEVEL: flatbuffers::VOffsetT = 46;
  pub const VT_TIMESPANINDAYSFORBATTLEHISTORY: flatbuffers::VOffsetT = 48;
  pub const VT_HIDDENCHARACTERIMAGEPATH: flatbuffers::VOffsetT = 50;
  pub const VT_DEFENSEVICTORYREWARDMAXCOUNT: flatbuffers::VOffsetT = 52;
  pub const VT_TOPRANKERCOUNTLIMIT: flatbuffers::VOffsetT = 54;
  pub const VT_AUTOREFRESHINTERVALMILLISECONDS: flatbuffers::VOffsetT = 56;
  pub const VT_ECHELONSETTINGINTERVALMILLISECONDS: flatbuffers::VOffsetT = 58;
  pub const VT_SKIPALLOWEDTIMEMILLISECONDS: flatbuffers::VOffsetT = 60;
  pub const VT_SHOWSEASONCHANGEINFOSTARTTIME: flatbuffers::VOffsetT = 62;
  pub const VT_SHOWSEASONCHANGEINFOENDTIME: flatbuffers::VOffsetT = 64;
  pub const VT_SHOWSEASONID: flatbuffers::VOffsetT = 66;
  pub const VT_ARENAHISTORYQUERYLIMITDAYS: flatbuffers::VOffsetT = 68;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ConstArenaExcel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ConstArenaExcelArgs<'args>
  ) -> flatbuffers::WIPOffset<ConstArenaExcel<'bldr>> {
    let mut builder = ConstArenaExcelBuilder::new(_fbb);
    let key = table_encryption_service::create_key(b"ConstArena");
      let x = args.ShowSeasonId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_ShowSeasonId(x);
      let x = args.SkipAllowedTimeMilliSeconds;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_SkipAllowedTimeMilliSeconds(x);
      let x = args.EchelonSettingIntervalMilliSeconds;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_EchelonSettingIntervalMilliSeconds(x);
      let x = args.AutoRefreshIntervalMilliSeconds;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_AutoRefreshIntervalMilliSeconds(x);
      let x = args.TopRankerCountLimit;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_TopRankerCountLimit(x);
      let x = args.DefenseVictoryRewardMaxCount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_DefenseVictoryRewardMaxCount(x);
      let x = args.TimeSpanInDaysForBattleHistory;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_TimeSpanInDaysForBattleHistory(x);
      let x = args.NPCCharacterSkillLevel;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_NPCCharacterSkillLevel(x);
      let x = args.NPCSupportCharacterCount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_NPCSupportCharacterCount(x);
      let x = args.NPCMainCharacterCount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_NPCMainCharacterCount(x);
      let x = args.MapSlotHideRank;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_MapSlotHideRank(x);
      let x = args.TicketCost;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_TicketCost(x);
      let x = args.EnterCostId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_EnterCostId(x);
      let x = args.TimeRewardMaxAmount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_TimeRewardMaxAmount(x);
      let x = args.EndAlarm;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_EndAlarm(x);
      let x = args.TSSStartCoolTime;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_TSSStartCoolTime(x);
      let x = args.DefenseCoolTime;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_DefenseCoolTime(x);
      let x = args.BattleDuration;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_BattleDuration(x);
      let x = args.AttackCoolTime;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_AttackCoolTime(x);
      let x = args.ArenaHistoryQueryLimitDays;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_ArenaHistoryQueryLimitDays(x);
      if let Some(x) = args.ShowSeasonChangeInfoEndTime {
        builder.add_ShowSeasonChangeInfoEndTime(x);
      }
      if let Some(x) = args.ShowSeasonChangeInfoStartTime {
        builder.add_ShowSeasonChangeInfoStartTime(x);
      }
      if let Some(x) = args.HiddenCharacterImagePath {
        builder.add_HiddenCharacterImagePath(x);
      }
      if let Some(x) = args.nPCName {
        builder.add_nPCName(x);
      }
      if let Some(x) = args.statSumFactor {
        builder.add_statSumFactor(x);
      }
      if let Some(x) = args.statMulFactor {
        builder.add_statMulFactor(x);
      }
      if let Some(x) = args.modifiedStatType {
        builder.add_modifiedStatType(x);
      }
      if let Some(x) = args.relativeOpponentRankEnd {
        builder.add_relativeOpponentRankEnd(x);
      }
      if let Some(x) = args.relativeOpponentRankStart {
        builder.add_relativeOpponentRankStart(x);
      }
      if let Some(x) = args.characterSlotHideRank {
        builder.add_characterSlotHideRank(x);
      }
      if let Some(x) = args.OpenScenarioId {
        builder.add_OpenScenarioId(x);
      }
      if let Some(x) = args.DailyRewardResetTime {
        builder.add_DailyRewardResetTime(x);
      }
      let x = args.EnterCostType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_EnterCostType(x);
    builder.finish()
  }

  pub fn unpack(&self) -> ConstArenaExcelT {
    let key = table_encryption_service::create_key(b"ConstArena");
      let AttackCoolTime = self.AttackCoolTime();
      let BattleDuration = self.BattleDuration();
      let DefenseCoolTime = self.DefenseCoolTime();
      let TSSStartCoolTime = self.TSSStartCoolTime();
      let EndAlarm = self.EndAlarm();
      let TimeRewardMaxAmount = self.TimeRewardMaxAmount();
      let EnterCostType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.EnterCostType(), &key)
      } else {
        self.EnterCostType()
      };
      let EnterCostId = self.EnterCostId();
      let TicketCost = self.TicketCost();
    let DailyRewardResetTime = self.DailyRewardResetTime().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let OpenScenarioId = self.OpenScenarioId().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let characterSlotHideRank = self.characterSlotHideRank().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_long(*val, &key) } else { *val }).collect()
    });
      let MapSlotHideRank = self.MapSlotHideRank();
    let relativeOpponentRankStart = self.relativeOpponentRankStart().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_long(*val, &key) } else { *val }).collect()
    });
    let relativeOpponentRankEnd = self.relativeOpponentRankEnd().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_long(*val, &key) } else { *val }).collect()
    });
    let modifiedStatType = self.modifiedStatType().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(*val, &key) } else { *val }).collect()
    });
    let statMulFactor = self.statMulFactor().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_long(*val, &key) } else { *val }).collect()
    });
    let statSumFactor = self.statSumFactor().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_long(*val, &key) } else { *val }).collect()
    });
    let nPCName = self.nPCName().map(|x| {
      x.iter().map(|s| if table_encryption_service::use_encryption() { table_encryption_service::convert_string(s, &key).unwrap() } else { s.to_string() }).collect()
    });
      let NPCMainCharacterCount = self.NPCMainCharacterCount();
      let NPCSupportCharacterCount = self.NPCSupportCharacterCount();
      let NPCCharacterSkillLevel = self.NPCCharacterSkillLevel();
      let TimeSpanInDaysForBattleHistory = self.TimeSpanInDaysForBattleHistory();
    let HiddenCharacterImagePath = self.HiddenCharacterImagePath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let DefenseVictoryRewardMaxCount = self.DefenseVictoryRewardMaxCount();
      let TopRankerCountLimit = self.TopRankerCountLimit();
      let AutoRefreshIntervalMilliSeconds = self.AutoRefreshIntervalMilliSeconds();
      let EchelonSettingIntervalMilliSeconds = self.EchelonSettingIntervalMilliSeconds();
      let SkipAllowedTimeMilliSeconds = self.SkipAllowedTimeMilliSeconds();
    let ShowSeasonChangeInfoStartTime = self.ShowSeasonChangeInfoStartTime().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let ShowSeasonChangeInfoEndTime = self.ShowSeasonChangeInfoEndTime().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let ShowSeasonId = self.ShowSeasonId();
      let ArenaHistoryQueryLimitDays = self.ArenaHistoryQueryLimitDays();
    ConstArenaExcelT {
      AttackCoolTime,
      BattleDuration,
      DefenseCoolTime,
      TSSStartCoolTime,
      EndAlarm,
      TimeRewardMaxAmount,
      EnterCostType,
      EnterCostId,
      TicketCost,
      DailyRewardResetTime,
      OpenScenarioId,
      characterSlotHideRank,
      MapSlotHideRank,
      relativeOpponentRankStart,
      relativeOpponentRankEnd,
      modifiedStatType,
      statMulFactor,
      statSumFactor,
      nPCName,
      NPCMainCharacterCount,
      NPCSupportCharacterCount,
      NPCCharacterSkillLevel,
      TimeSpanInDaysForBattleHistory,
      HiddenCharacterImagePath,
      DefenseVictoryRewardMaxCount,
      TopRankerCountLimit,
      AutoRefreshIntervalMilliSeconds,
      EchelonSettingIntervalMilliSeconds,
      SkipAllowedTimeMilliSeconds,
      ShowSeasonChangeInfoStartTime,
      ShowSeasonChangeInfoEndTime,
      ShowSeasonId,
      ArenaHistoryQueryLimitDays,
    }
  }

  #[inline]
  pub fn AttackCoolTime(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstArenaExcel::VT_ATTACKCOOLTIME, Some(0)).unwrap()}
  }
  #[inline]
  pub fn BattleDuration(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstArenaExcel::VT_BATTLEDURATION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn DefenseCoolTime(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstArenaExcel::VT_DEFENSECOOLTIME, Some(0)).unwrap()}
  }
  #[inline]
  pub fn TSSStartCoolTime(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstArenaExcel::VT_TSSSTARTCOOLTIME, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EndAlarm(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstArenaExcel::VT_ENDALARM, Some(0)).unwrap()}
  }
  #[inline]
  pub fn TimeRewardMaxAmount(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstArenaExcel::VT_TIMEREWARDMAXAMOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EnterCostType(&self) -> ParcelType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ParcelType>(ConstArenaExcel::VT_ENTERCOSTTYPE, Some(ParcelType::None)).unwrap()}
  }
  #[inline]
  pub fn EnterCostId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstArenaExcel::VT_ENTERCOSTID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn TicketCost(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstArenaExcel::VT_TICKETCOST, Some(0)).unwrap()}
  }
  #[inline]
  pub fn DailyRewardResetTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ConstArenaExcel::VT_DAILYREWARDRESETTIME, None)}
  }
  #[inline]
  pub fn OpenScenarioId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ConstArenaExcel::VT_OPENSCENARIOID, None)}
  }
  #[inline]
  pub fn characterSlotHideRank(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(ConstArenaExcel::VT_CHARACTERSLOTHIDERANK, None)}
  }
  #[inline]
  pub fn MapSlotHideRank(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstArenaExcel::VT_MAPSLOTHIDERANK, Some(0)).unwrap()}
  }
  #[inline]
  pub fn relativeOpponentRankStart(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(ConstArenaExcel::VT_RELATIVEOPPONENTRANKSTART, None)}
  }
  #[inline]
  pub fn relativeOpponentRankEnd(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(ConstArenaExcel::VT_RELATIVEOPPONENTRANKEND, None)}
  }
  #[inline]
  pub fn modifiedStatType(&self) -> Option<flatbuffers::Vector<'a, StatType>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, StatType>>>(ConstArenaExcel::VT_MODIFIEDSTATTYPE, None)}
  }
  #[inline]
  pub fn statMulFactor(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(ConstArenaExcel::VT_STATMULFACTOR, None)}
  }
  #[inline]
  pub fn statSumFactor(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(ConstArenaExcel::VT_STATSUMFACTOR, None)}
  }
  #[inline]
  pub fn nPCName(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(ConstArenaExcel::VT_NPCNAME, None)}
  }
  #[inline]
  pub fn NPCMainCharacterCount(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstArenaExcel::VT_NPCMAINCHARACTERCOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn NPCSupportCharacterCount(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstArenaExcel::VT_NPCSUPPORTCHARACTERCOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn NPCCharacterSkillLevel(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstArenaExcel::VT_NPCCHARACTERSKILLLEVEL, Some(0)).unwrap()}
  }
  #[inline]
  pub fn TimeSpanInDaysForBattleHistory(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstArenaExcel::VT_TIMESPANINDAYSFORBATTLEHISTORY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn HiddenCharacterImagePath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ConstArenaExcel::VT_HIDDENCHARACTERIMAGEPATH, None)}
  }
  #[inline]
  pub fn DefenseVictoryRewardMaxCount(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstArenaExcel::VT_DEFENSEVICTORYREWARDMAXCOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn TopRankerCountLimit(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstArenaExcel::VT_TOPRANKERCOUNTLIMIT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn AutoRefreshIntervalMilliSeconds(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstArenaExcel::VT_AUTOREFRESHINTERVALMILLISECONDS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EchelonSettingIntervalMilliSeconds(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstArenaExcel::VT_ECHELONSETTINGINTERVALMILLISECONDS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn SkipAllowedTimeMilliSeconds(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstArenaExcel::VT_SKIPALLOWEDTIMEMILLISECONDS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ShowSeasonChangeInfoStartTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ConstArenaExcel::VT_SHOWSEASONCHANGEINFOSTARTTIME, None)}
  }
  #[inline]
  pub fn ShowSeasonChangeInfoEndTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ConstArenaExcel::VT_SHOWSEASONCHANGEINFOENDTIME, None)}
  }
  #[inline]
  pub fn ShowSeasonId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstArenaExcel::VT_SHOWSEASONID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ArenaHistoryQueryLimitDays(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstArenaExcel::VT_ARENAHISTORYQUERYLIMITDAYS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ConstArenaExcel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("AttackCoolTime", Self::VT_ATTACKCOOLTIME, false)?
     .visit_field::<i64>("BattleDuration", Self::VT_BATTLEDURATION, false)?
     .visit_field::<i64>("DefenseCoolTime", Self::VT_DEFENSECOOLTIME, false)?
     .visit_field::<i64>("TSSStartCoolTime", Self::VT_TSSSTARTCOOLTIME, false)?
     .visit_field::<i64>("EndAlarm", Self::VT_ENDALARM, false)?
     .visit_field::<i64>("TimeRewardMaxAmount", Self::VT_TIMEREWARDMAXAMOUNT, false)?
     .visit_field::<ParcelType>("EnterCostType", Self::VT_ENTERCOSTTYPE, false)?
     .visit_field::<i64>("EnterCostId", Self::VT_ENTERCOSTID, false)?
     .visit_field::<i64>("TicketCost", Self::VT_TICKETCOST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DailyRewardResetTime", Self::VT_DAILYREWARDRESETTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OpenScenarioId", Self::VT_OPENSCENARIOID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("characterSlotHideRank", Self::VT_CHARACTERSLOTHIDERANK, false)?
     .visit_field::<i64>("MapSlotHideRank", Self::VT_MAPSLOTHIDERANK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("relativeOpponentRankStart", Self::VT_RELATIVEOPPONENTRANKSTART, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("relativeOpponentRankEnd", Self::VT_RELATIVEOPPONENTRANKEND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, StatType>>>("modifiedStatType", Self::VT_MODIFIEDSTATTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("statMulFactor", Self::VT_STATMULFACTOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("statSumFactor", Self::VT_STATSUMFACTOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("nPCName", Self::VT_NPCNAME, false)?
     .visit_field::<i64>("NPCMainCharacterCount", Self::VT_NPCMAINCHARACTERCOUNT, false)?
     .visit_field::<i64>("NPCSupportCharacterCount", Self::VT_NPCSUPPORTCHARACTERCOUNT, false)?
     .visit_field::<i64>("NPCCharacterSkillLevel", Self::VT_NPCCHARACTERSKILLLEVEL, false)?
     .visit_field::<i64>("TimeSpanInDaysForBattleHistory", Self::VT_TIMESPANINDAYSFORBATTLEHISTORY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("HiddenCharacterImagePath", Self::VT_HIDDENCHARACTERIMAGEPATH, false)?
     .visit_field::<i64>("DefenseVictoryRewardMaxCount", Self::VT_DEFENSEVICTORYREWARDMAXCOUNT, false)?
     .visit_field::<i64>("TopRankerCountLimit", Self::VT_TOPRANKERCOUNTLIMIT, false)?
     .visit_field::<i64>("AutoRefreshIntervalMilliSeconds", Self::VT_AUTOREFRESHINTERVALMILLISECONDS, false)?
     .visit_field::<i64>("EchelonSettingIntervalMilliSeconds", Self::VT_ECHELONSETTINGINTERVALMILLISECONDS, false)?
     .visit_field::<i64>("SkipAllowedTimeMilliSeconds", Self::VT_SKIPALLOWEDTIMEMILLISECONDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ShowSeasonChangeInfoStartTime", Self::VT_SHOWSEASONCHANGEINFOSTARTTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ShowSeasonChangeInfoEndTime", Self::VT_SHOWSEASONCHANGEINFOENDTIME, false)?
     .visit_field::<i64>("ShowSeasonId", Self::VT_SHOWSEASONID, false)?
     .visit_field::<i32>("ArenaHistoryQueryLimitDays", Self::VT_ARENAHISTORYQUERYLIMITDAYS, false)?
     .finish();
    Ok(())
  }
}
pub struct ConstArenaExcelArgs<'a> {
    pub AttackCoolTime: i64,
    pub BattleDuration: i64,
    pub DefenseCoolTime: i64,
    pub TSSStartCoolTime: i64,
    pub EndAlarm: i64,
    pub TimeRewardMaxAmount: i64,
    pub EnterCostType: ParcelType,
    pub EnterCostId: i64,
    pub TicketCost: i64,
    pub DailyRewardResetTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OpenScenarioId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub characterSlotHideRank: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub MapSlotHideRank: i64,
    pub relativeOpponentRankStart: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub relativeOpponentRankEnd: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub modifiedStatType: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, StatType>>>,
    pub statMulFactor: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub statSumFactor: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub nPCName: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub NPCMainCharacterCount: i64,
    pub NPCSupportCharacterCount: i64,
    pub NPCCharacterSkillLevel: i64,
    pub TimeSpanInDaysForBattleHistory: i64,
    pub HiddenCharacterImagePath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DefenseVictoryRewardMaxCount: i64,
    pub TopRankerCountLimit: i64,
    pub AutoRefreshIntervalMilliSeconds: i64,
    pub EchelonSettingIntervalMilliSeconds: i64,
    pub SkipAllowedTimeMilliSeconds: i64,
    pub ShowSeasonChangeInfoStartTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ShowSeasonChangeInfoEndTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ShowSeasonId: i64,
    pub ArenaHistoryQueryLimitDays: i32,
}
impl<'a> Default for ConstArenaExcelArgs<'a> {
  #[inline]
  fn default() -> Self {
    ConstArenaExcelArgs {
      AttackCoolTime: 0,
      BattleDuration: 0,
      DefenseCoolTime: 0,
      TSSStartCoolTime: 0,
      EndAlarm: 0,
      TimeRewardMaxAmount: 0,
      EnterCostType: ParcelType::None,
      EnterCostId: 0,
      TicketCost: 0,
      DailyRewardResetTime: None,
      OpenScenarioId: None,
      characterSlotHideRank: None,
      MapSlotHideRank: 0,
      relativeOpponentRankStart: None,
      relativeOpponentRankEnd: None,
      modifiedStatType: None,
      statMulFactor: None,
      statSumFactor: None,
      nPCName: None,
      NPCMainCharacterCount: 0,
      NPCSupportCharacterCount: 0,
      NPCCharacterSkillLevel: 0,
      TimeSpanInDaysForBattleHistory: 0,
      HiddenCharacterImagePath: None,
      DefenseVictoryRewardMaxCount: 0,
      TopRankerCountLimit: 0,
      AutoRefreshIntervalMilliSeconds: 0,
      EchelonSettingIntervalMilliSeconds: 0,
      SkipAllowedTimeMilliSeconds: 0,
      ShowSeasonChangeInfoStartTime: None,
      ShowSeasonChangeInfoEndTime: None,
      ShowSeasonId: 0,
      ArenaHistoryQueryLimitDays: 0,
    }
  }
}

impl Serialize for ConstArenaExcel<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("ConstArenaExcel", 33)?;
      s.serialize_field("AttackCoolTime", &self.AttackCoolTime())?;
      s.serialize_field("BattleDuration", &self.BattleDuration())?;
      s.serialize_field("DefenseCoolTime", &self.DefenseCoolTime())?;
      s.serialize_field("TSSStartCoolTime", &self.TSSStartCoolTime())?;
      s.serialize_field("EndAlarm", &self.EndAlarm())?;
      s.serialize_field("TimeRewardMaxAmount", &self.TimeRewardMaxAmount())?;
      s.serialize_field("EnterCostType", &self.EnterCostType())?;
      s.serialize_field("EnterCostId", &self.EnterCostId())?;
      s.serialize_field("TicketCost", &self.TicketCost())?;
      if let Some(f) = self.DailyRewardResetTime() {
        s.serialize_field("DailyRewardResetTime", &f)?;
      } else {
        s.skip_field("DailyRewardResetTime")?;
      }
      if let Some(f) = self.OpenScenarioId() {
        s.serialize_field("OpenScenarioId", &f)?;
      } else {
        s.skip_field("OpenScenarioId")?;
      }
      if let Some(f) = self.characterSlotHideRank() {
        s.serialize_field("characterSlotHideRank", &f)?;
      } else {
        s.skip_field("characterSlotHideRank")?;
      }
      s.serialize_field("MapSlotHideRank", &self.MapSlotHideRank())?;
      if let Some(f) = self.relativeOpponentRankStart() {
        s.serialize_field("relativeOpponentRankStart", &f)?;
      } else {
        s.skip_field("relativeOpponentRankStart")?;
      }
      if let Some(f) = self.relativeOpponentRankEnd() {
        s.serialize_field("relativeOpponentRankEnd", &f)?;
      } else {
        s.skip_field("relativeOpponentRankEnd")?;
      }
      if let Some(f) = self.modifiedStatType() {
        s.serialize_field("modifiedStatType", &f)?;
      } else {
        s.skip_field("modifiedStatType")?;
      }
      if let Some(f) = self.statMulFactor() {
        s.serialize_field("statMulFactor", &f)?;
      } else {
        s.skip_field("statMulFactor")?;
      }
      if let Some(f) = self.statSumFactor() {
        s.serialize_field("statSumFactor", &f)?;
      } else {
        s.skip_field("statSumFactor")?;
      }
      if let Some(f) = self.nPCName() {
        s.serialize_field("nPCName", &f)?;
      } else {
        s.skip_field("nPCName")?;
      }
      s.serialize_field("NPCMainCharacterCount", &self.NPCMainCharacterCount())?;
      s.serialize_field("NPCSupportCharacterCount", &self.NPCSupportCharacterCount())?;
      s.serialize_field("NPCCharacterSkillLevel", &self.NPCCharacterSkillLevel())?;
      s.serialize_field("TimeSpanInDaysForBattleHistory", &self.TimeSpanInDaysForBattleHistory())?;
      if let Some(f) = self.HiddenCharacterImagePath() {
        s.serialize_field("HiddenCharacterImagePath", &f)?;
      } else {
        s.skip_field("HiddenCharacterImagePath")?;
      }
      s.serialize_field("DefenseVictoryRewardMaxCount", &self.DefenseVictoryRewardMaxCount())?;
      s.serialize_field("TopRankerCountLimit", &self.TopRankerCountLimit())?;
      s.serialize_field("AutoRefreshIntervalMilliSeconds", &self.AutoRefreshIntervalMilliSeconds())?;
      s.serialize_field("EchelonSettingIntervalMilliSeconds", &self.EchelonSettingIntervalMilliSeconds())?;
      s.serialize_field("SkipAllowedTimeMilliSeconds", &self.SkipAllowedTimeMilliSeconds())?;
      if let Some(f) = self.ShowSeasonChangeInfoStartTime() {
        s.serialize_field("ShowSeasonChangeInfoStartTime", &f)?;
      } else {
        s.skip_field("ShowSeasonChangeInfoStartTime")?;
      }
      if let Some(f) = self.ShowSeasonChangeInfoEndTime() {
        s.serialize_field("ShowSeasonChangeInfoEndTime", &f)?;
      } else {
        s.skip_field("ShowSeasonChangeInfoEndTime")?;
      }
      s.serialize_field("ShowSeasonId", &self.ShowSeasonId())?;
      s.serialize_field("ArenaHistoryQueryLimitDays", &self.ArenaHistoryQueryLimitDays())?;
    s.end()
  }
}

pub struct ConstArenaExcelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ConstArenaExcelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_AttackCoolTime(&mut self, AttackCoolTime: i64) {
    self.fbb_.push_slot::<i64>(ConstArenaExcel::VT_ATTACKCOOLTIME, AttackCoolTime, 0);
  }
  #[inline]
  pub fn add_BattleDuration(&mut self, BattleDuration: i64) {
    self.fbb_.push_slot::<i64>(ConstArenaExcel::VT_BATTLEDURATION, BattleDuration, 0);
  }
  #[inline]
  pub fn add_DefenseCoolTime(&mut self, DefenseCoolTime: i64) {
    self.fbb_.push_slot::<i64>(ConstArenaExcel::VT_DEFENSECOOLTIME, DefenseCoolTime, 0);
  }
  #[inline]
  pub fn add_TSSStartCoolTime(&mut self, TSSStartCoolTime: i64) {
    self.fbb_.push_slot::<i64>(ConstArenaExcel::VT_TSSSTARTCOOLTIME, TSSStartCoolTime, 0);
  }
  #[inline]
  pub fn add_EndAlarm(&mut self, EndAlarm: i64) {
    self.fbb_.push_slot::<i64>(ConstArenaExcel::VT_ENDALARM, EndAlarm, 0);
  }
  #[inline]
  pub fn add_TimeRewardMaxAmount(&mut self, TimeRewardMaxAmount: i64) {
    self.fbb_.push_slot::<i64>(ConstArenaExcel::VT_TIMEREWARDMAXAMOUNT, TimeRewardMaxAmount, 0);
  }
  #[inline]
  pub fn add_EnterCostType(&mut self, EnterCostType: ParcelType) {
    self.fbb_.push_slot::<ParcelType>(ConstArenaExcel::VT_ENTERCOSTTYPE, EnterCostType, ParcelType::None);
  }
  #[inline]
  pub fn add_EnterCostId(&mut self, EnterCostId: i64) {
    self.fbb_.push_slot::<i64>(ConstArenaExcel::VT_ENTERCOSTID, EnterCostId, 0);
  }
  #[inline]
  pub fn add_TicketCost(&mut self, TicketCost: i64) {
    self.fbb_.push_slot::<i64>(ConstArenaExcel::VT_TICKETCOST, TicketCost, 0);
  }
  #[inline]
  pub fn add_DailyRewardResetTime(&mut self, DailyRewardResetTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConstArenaExcel::VT_DAILYREWARDRESETTIME, DailyRewardResetTime);
  }
  #[inline]
  pub fn add_OpenScenarioId(&mut self, OpenScenarioId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConstArenaExcel::VT_OPENSCENARIOID, OpenScenarioId);
  }
  #[inline]
  pub fn add_characterSlotHideRank(&mut self, characterSlotHideRank: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConstArenaExcel::VT_CHARACTERSLOTHIDERANK, characterSlotHideRank);
  }
  #[inline]
  pub fn add_MapSlotHideRank(&mut self, MapSlotHideRank: i64) {
    self.fbb_.push_slot::<i64>(ConstArenaExcel::VT_MAPSLOTHIDERANK, MapSlotHideRank, 0);
  }
  #[inline]
  pub fn add_relativeOpponentRankStart(&mut self, relativeOpponentRankStart: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConstArenaExcel::VT_RELATIVEOPPONENTRANKSTART, relativeOpponentRankStart);
  }
  #[inline]
  pub fn add_relativeOpponentRankEnd(&mut self, relativeOpponentRankEnd: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConstArenaExcel::VT_RELATIVEOPPONENTRANKEND, relativeOpponentRankEnd);
  }
  #[inline]
  pub fn add_modifiedStatType(&mut self, modifiedStatType: flatbuffers::WIPOffset<flatbuffers::Vector<'b , StatType>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConstArenaExcel::VT_MODIFIEDSTATTYPE, modifiedStatType);
  }
  #[inline]
  pub fn add_statMulFactor(&mut self, statMulFactor: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConstArenaExcel::VT_STATMULFACTOR, statMulFactor);
  }
  #[inline]
  pub fn add_statSumFactor(&mut self, statSumFactor: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConstArenaExcel::VT_STATSUMFACTOR, statSumFactor);
  }
  #[inline]
  pub fn add_nPCName(&mut self, nPCName: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConstArenaExcel::VT_NPCNAME, nPCName);
  }
  #[inline]
  pub fn add_NPCMainCharacterCount(&mut self, NPCMainCharacterCount: i64) {
    self.fbb_.push_slot::<i64>(ConstArenaExcel::VT_NPCMAINCHARACTERCOUNT, NPCMainCharacterCount, 0);
  }
  #[inline]
  pub fn add_NPCSupportCharacterCount(&mut self, NPCSupportCharacterCount: i64) {
    self.fbb_.push_slot::<i64>(ConstArenaExcel::VT_NPCSUPPORTCHARACTERCOUNT, NPCSupportCharacterCount, 0);
  }
  #[inline]
  pub fn add_NPCCharacterSkillLevel(&mut self, NPCCharacterSkillLevel: i64) {
    self.fbb_.push_slot::<i64>(ConstArenaExcel::VT_NPCCHARACTERSKILLLEVEL, NPCCharacterSkillLevel, 0);
  }
  #[inline]
  pub fn add_TimeSpanInDaysForBattleHistory(&mut self, TimeSpanInDaysForBattleHistory: i64) {
    self.fbb_.push_slot::<i64>(ConstArenaExcel::VT_TIMESPANINDAYSFORBATTLEHISTORY, TimeSpanInDaysForBattleHistory, 0);
  }
  #[inline]
  pub fn add_HiddenCharacterImagePath(&mut self, HiddenCharacterImagePath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConstArenaExcel::VT_HIDDENCHARACTERIMAGEPATH, HiddenCharacterImagePath);
  }
  #[inline]
  pub fn add_DefenseVictoryRewardMaxCount(&mut self, DefenseVictoryRewardMaxCount: i64) {
    self.fbb_.push_slot::<i64>(ConstArenaExcel::VT_DEFENSEVICTORYREWARDMAXCOUNT, DefenseVictoryRewardMaxCount, 0);
  }
  #[inline]
  pub fn add_TopRankerCountLimit(&mut self, TopRankerCountLimit: i64) {
    self.fbb_.push_slot::<i64>(ConstArenaExcel::VT_TOPRANKERCOUNTLIMIT, TopRankerCountLimit, 0);
  }
  #[inline]
  pub fn add_AutoRefreshIntervalMilliSeconds(&mut self, AutoRefreshIntervalMilliSeconds: i64) {
    self.fbb_.push_slot::<i64>(ConstArenaExcel::VT_AUTOREFRESHINTERVALMILLISECONDS, AutoRefreshIntervalMilliSeconds, 0);
  }
  #[inline]
  pub fn add_EchelonSettingIntervalMilliSeconds(&mut self, EchelonSettingIntervalMilliSeconds: i64) {
    self.fbb_.push_slot::<i64>(ConstArenaExcel::VT_ECHELONSETTINGINTERVALMILLISECONDS, EchelonSettingIntervalMilliSeconds, 0);
  }
  #[inline]
  pub fn add_SkipAllowedTimeMilliSeconds(&mut self, SkipAllowedTimeMilliSeconds: i64) {
    self.fbb_.push_slot::<i64>(ConstArenaExcel::VT_SKIPALLOWEDTIMEMILLISECONDS, SkipAllowedTimeMilliSeconds, 0);
  }
  #[inline]
  pub fn add_ShowSeasonChangeInfoStartTime(&mut self, ShowSeasonChangeInfoStartTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConstArenaExcel::VT_SHOWSEASONCHANGEINFOSTARTTIME, ShowSeasonChangeInfoStartTime);
  }
  #[inline]
  pub fn add_ShowSeasonChangeInfoEndTime(&mut self, ShowSeasonChangeInfoEndTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConstArenaExcel::VT_SHOWSEASONCHANGEINFOENDTIME, ShowSeasonChangeInfoEndTime);
  }
  #[inline]
  pub fn add_ShowSeasonId(&mut self, ShowSeasonId: i64) {
    self.fbb_.push_slot::<i64>(ConstArenaExcel::VT_SHOWSEASONID, ShowSeasonId, 0);
  }
  #[inline]
  pub fn add_ArenaHistoryQueryLimitDays(&mut self, ArenaHistoryQueryLimitDays: i32) {
    self.fbb_.push_slot::<i32>(ConstArenaExcel::VT_ARENAHISTORYQUERYLIMITDAYS, ArenaHistoryQueryLimitDays, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ConstArenaExcelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ConstArenaExcelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ConstArenaExcel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ConstArenaExcel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ConstArenaExcel");
      ds.field("AttackCoolTime", &self.AttackCoolTime());
      ds.field("BattleDuration", &self.BattleDuration());
      ds.field("DefenseCoolTime", &self.DefenseCoolTime());
      ds.field("TSSStartCoolTime", &self.TSSStartCoolTime());
      ds.field("EndAlarm", &self.EndAlarm());
      ds.field("TimeRewardMaxAmount", &self.TimeRewardMaxAmount());
      ds.field("EnterCostType", &self.EnterCostType());
      ds.field("EnterCostId", &self.EnterCostId());
      ds.field("TicketCost", &self.TicketCost());
      ds.field("DailyRewardResetTime", &self.DailyRewardResetTime());
      ds.field("OpenScenarioId", &self.OpenScenarioId());
      ds.field("characterSlotHideRank", &self.characterSlotHideRank());
      ds.field("MapSlotHideRank", &self.MapSlotHideRank());
      ds.field("relativeOpponentRankStart", &self.relativeOpponentRankStart());
      ds.field("relativeOpponentRankEnd", &self.relativeOpponentRankEnd());
      ds.field("modifiedStatType", &self.modifiedStatType());
      ds.field("statMulFactor", &self.statMulFactor());
      ds.field("statSumFactor", &self.statSumFactor());
      ds.field("nPCName", &self.nPCName());
      ds.field("NPCMainCharacterCount", &self.NPCMainCharacterCount());
      ds.field("NPCSupportCharacterCount", &self.NPCSupportCharacterCount());
      ds.field("NPCCharacterSkillLevel", &self.NPCCharacterSkillLevel());
      ds.field("TimeSpanInDaysForBattleHistory", &self.TimeSpanInDaysForBattleHistory());
      ds.field("HiddenCharacterImagePath", &self.HiddenCharacterImagePath());
      ds.field("DefenseVictoryRewardMaxCount", &self.DefenseVictoryRewardMaxCount());
      ds.field("TopRankerCountLimit", &self.TopRankerCountLimit());
      ds.field("AutoRefreshIntervalMilliSeconds", &self.AutoRefreshIntervalMilliSeconds());
      ds.field("EchelonSettingIntervalMilliSeconds", &self.EchelonSettingIntervalMilliSeconds());
      ds.field("SkipAllowedTimeMilliSeconds", &self.SkipAllowedTimeMilliSeconds());
      ds.field("ShowSeasonChangeInfoStartTime", &self.ShowSeasonChangeInfoStartTime());
      ds.field("ShowSeasonChangeInfoEndTime", &self.ShowSeasonChangeInfoEndTime());
      ds.field("ShowSeasonId", &self.ShowSeasonId());
      ds.field("ArenaHistoryQueryLimitDays", &self.ArenaHistoryQueryLimitDays());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ConstArenaExcelT {
  pub AttackCoolTime: i64,
  pub BattleDuration: i64,
  pub DefenseCoolTime: i64,
  pub TSSStartCoolTime: i64,
  pub EndAlarm: i64,
  pub TimeRewardMaxAmount: i64,
  pub EnterCostType: ParcelType,
  pub EnterCostId: i64,
  pub TicketCost: i64,
  pub DailyRewardResetTime: Option<String>,
  pub OpenScenarioId: Option<String>,
  pub characterSlotHideRank: Option<Vec<i64>>,
  pub MapSlotHideRank: i64,
  pub relativeOpponentRankStart: Option<Vec<i64>>,
  pub relativeOpponentRankEnd: Option<Vec<i64>>,
  pub modifiedStatType: Option<Vec<StatType>>,
  pub statMulFactor: Option<Vec<i64>>,
  pub statSumFactor: Option<Vec<i64>>,
  pub nPCName: Option<Vec<String>>,
  pub NPCMainCharacterCount: i64,
  pub NPCSupportCharacterCount: i64,
  pub NPCCharacterSkillLevel: i64,
  pub TimeSpanInDaysForBattleHistory: i64,
  pub HiddenCharacterImagePath: Option<String>,
  pub DefenseVictoryRewardMaxCount: i64,
  pub TopRankerCountLimit: i64,
  pub AutoRefreshIntervalMilliSeconds: i64,
  pub EchelonSettingIntervalMilliSeconds: i64,
  pub SkipAllowedTimeMilliSeconds: i64,
  pub ShowSeasonChangeInfoStartTime: Option<String>,
  pub ShowSeasonChangeInfoEndTime: Option<String>,
  pub ShowSeasonId: i64,
  pub ArenaHistoryQueryLimitDays: i32,
}
impl Default for ConstArenaExcelT {
  fn default() -> Self {
    Self {
      AttackCoolTime: 0,
      BattleDuration: 0,
      DefenseCoolTime: 0,
      TSSStartCoolTime: 0,
      EndAlarm: 0,
      TimeRewardMaxAmount: 0,
      EnterCostType: ParcelType::None,
      EnterCostId: 0,
      TicketCost: 0,
      DailyRewardResetTime: None,
      OpenScenarioId: None,
      characterSlotHideRank: None,
      MapSlotHideRank: 0,
      relativeOpponentRankStart: None,
      relativeOpponentRankEnd: None,
      modifiedStatType: None,
      statMulFactor: None,
      statSumFactor: None,
      nPCName: None,
      NPCMainCharacterCount: 0,
      NPCSupportCharacterCount: 0,
      NPCCharacterSkillLevel: 0,
      TimeSpanInDaysForBattleHistory: 0,
      HiddenCharacterImagePath: None,
      DefenseVictoryRewardMaxCount: 0,
      TopRankerCountLimit: 0,
      AutoRefreshIntervalMilliSeconds: 0,
      EchelonSettingIntervalMilliSeconds: 0,
      SkipAllowedTimeMilliSeconds: 0,
      ShowSeasonChangeInfoStartTime: None,
      ShowSeasonChangeInfoEndTime: None,
      ShowSeasonId: 0,
      ArenaHistoryQueryLimitDays: 0,
    }
  }
}
impl ConstArenaExcelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ConstArenaExcel<'b>> {
    let AttackCoolTime = self.AttackCoolTime;
    let BattleDuration = self.BattleDuration;
    let DefenseCoolTime = self.DefenseCoolTime;
    let TSSStartCoolTime = self.TSSStartCoolTime;
    let EndAlarm = self.EndAlarm;
    let TimeRewardMaxAmount = self.TimeRewardMaxAmount;
    let EnterCostType = self.EnterCostType;
    let EnterCostId = self.EnterCostId;
    let TicketCost = self.TicketCost;
    let DailyRewardResetTime = self.DailyRewardResetTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OpenScenarioId = self.OpenScenarioId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let characterSlotHideRank = self.characterSlotHideRank.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let MapSlotHideRank = self.MapSlotHideRank;
    let relativeOpponentRankStart = self.relativeOpponentRankStart.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let relativeOpponentRankEnd = self.relativeOpponentRankEnd.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let modifiedStatType = self.modifiedStatType.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let statMulFactor = self.statMulFactor.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let statSumFactor = self.statSumFactor.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let nPCName = self.nPCName.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let NPCMainCharacterCount = self.NPCMainCharacterCount;
    let NPCSupportCharacterCount = self.NPCSupportCharacterCount;
    let NPCCharacterSkillLevel = self.NPCCharacterSkillLevel;
    let TimeSpanInDaysForBattleHistory = self.TimeSpanInDaysForBattleHistory;
    let HiddenCharacterImagePath = self.HiddenCharacterImagePath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DefenseVictoryRewardMaxCount = self.DefenseVictoryRewardMaxCount;
    let TopRankerCountLimit = self.TopRankerCountLimit;
    let AutoRefreshIntervalMilliSeconds = self.AutoRefreshIntervalMilliSeconds;
    let EchelonSettingIntervalMilliSeconds = self.EchelonSettingIntervalMilliSeconds;
    let SkipAllowedTimeMilliSeconds = self.SkipAllowedTimeMilliSeconds;
    let ShowSeasonChangeInfoStartTime = self.ShowSeasonChangeInfoStartTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ShowSeasonChangeInfoEndTime = self.ShowSeasonChangeInfoEndTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ShowSeasonId = self.ShowSeasonId;
    let ArenaHistoryQueryLimitDays = self.ArenaHistoryQueryLimitDays;
    ConstArenaExcel::create(_fbb, &ConstArenaExcelArgs{
      AttackCoolTime,
      BattleDuration,
      DefenseCoolTime,
      TSSStartCoolTime,
      EndAlarm,
      TimeRewardMaxAmount,
      EnterCostType,
      EnterCostId,
      TicketCost,
      DailyRewardResetTime,
      OpenScenarioId,
      characterSlotHideRank,
      MapSlotHideRank,
      relativeOpponentRankStart,
      relativeOpponentRankEnd,
      modifiedStatType,
      statMulFactor,
      statSumFactor,
      nPCName,
      NPCMainCharacterCount,
      NPCSupportCharacterCount,
      NPCCharacterSkillLevel,
      TimeSpanInDaysForBattleHistory,
      HiddenCharacterImagePath,
      DefenseVictoryRewardMaxCount,
      TopRankerCountLimit,
      AutoRefreshIntervalMilliSeconds,
      EchelonSettingIntervalMilliSeconds,
      SkipAllowedTimeMilliSeconds,
      ShowSeasonChangeInfoStartTime,
      ShowSeasonChangeInfoEndTime,
      ShowSeasonId,
      ArenaHistoryQueryLimitDays,
    })
  }
}
