// automatically generated by the FlatBuffers compiler, do not modify
// @generated
#![allow(unused_imports, dead_code)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum ConstStrategyExcelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ConstStrategyExcel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConstStrategyExcel<'a> {
  type Inner = ConstStrategyExcel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ConstStrategyExcel<'a> {
  pub const VT_HEXAMAPBOUNDARYOFFSET: flatbuffers::VOffsetT = 4;
  pub const VT_HEXAMAPSTARTCAMERAOFFSET: flatbuffers::VOffsetT = 6;
  pub const VT_CAMERAZOOMMAX: flatbuffers::VOffsetT = 8;
  pub const VT_CAMERAZOOMMIN: flatbuffers::VOffsetT = 10;
  pub const VT_CAMERAZOOMDEFAULT: flatbuffers::VOffsetT = 12;
  pub const VT_HEALCOSTTYPE: flatbuffers::VOffsetT = 14;
  pub const VT_HEALCOSTAMOUNT: flatbuffers::VOffsetT = 16;
  pub const VT_CANHEALHPRATE: flatbuffers::VOffsetT = 18;
  pub const VT_PLAYTIMELIMITINSECONDS: flatbuffers::VOffsetT = 20;
  pub const VT_ADVENTUREECHELONCOUNT: flatbuffers::VOffsetT = 22;
  pub const VT_RAIDECHELONCOUNT: flatbuffers::VOffsetT = 24;
  pub const VT_DEFAULTECHELONCOUNT: flatbuffers::VOffsetT = 26;
  pub const VT_EVENTCONTENTECHELONCOUNT: flatbuffers::VOffsetT = 28;
  pub const VT_TIMEATTACKDUNGEONECHELONCOUNT: flatbuffers::VOffsetT = 30;
  pub const VT_WORLDRAIDECHELONCOUNT: flatbuffers::VOffsetT = 32;
  pub const VT_TACTICSKIPCLEARTIMESECONDS: flatbuffers::VOffsetT = 34;
  pub const VT_TACTICSKIPFRAMEPERSECOND: flatbuffers::VOffsetT = 36;
  pub const VT_CONQUESTECHELONCOUNT: flatbuffers::VOffsetT = 38;
  pub const VT_STORYECHELONCOUNT: flatbuffers::VOffsetT = 40;
  pub const VT_MULTISWEEPPRESETCOUNT: flatbuffers::VOffsetT = 42;
  pub const VT_MULTISWEEPPRESETNAMEMAXLENGTH: flatbuffers::VOffsetT = 44;
  pub const VT_MULTISWEEPPRESETSELECTSTAGEMAXCOUNT: flatbuffers::VOffsetT = 46;
  pub const VT_MULTISWEEPPRESETMAXSWEEPCOUNT: flatbuffers::VOffsetT = 48;
  pub const VT_MULTISWEEPPRESETSELECTPARCELMAXCOUNT: flatbuffers::VOffsetT = 50;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ConstStrategyExcel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ConstStrategyExcelArgs<'args>
  ) -> flatbuffers::WIPOffset<ConstStrategyExcel<'bldr>> {
    let mut builder = ConstStrategyExcelBuilder::new(_fbb);
    let key = table_encryption_service::create_key(b"ConstStrategy");
      let x = args.PlayTimeLimitInSeconds;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_PlayTimeLimitInSeconds(x);
      let x = args.MultiSweepPresetSelectParcelMaxCount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_MultiSweepPresetSelectParcelMaxCount(x);
      let x = args.MultiSweepPresetMaxSweepCount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_MultiSweepPresetMaxSweepCount(x);
      let x = args.MultiSweepPresetSelectStageMaxCount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_MultiSweepPresetSelectStageMaxCount(x);
      let x = args.MultiSweepPresetNameMaxLength;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_MultiSweepPresetNameMaxLength(x);
      let x = args.MultiSweepPresetCount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_MultiSweepPresetCount(x);
      let x = args.StoryEchelonCount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_StoryEchelonCount(x);
      let x = args.ConquestEchelonCount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_ConquestEchelonCount(x);
      let x = args.TacticSkipFramePerSecond;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_TacticSkipFramePerSecond(x);
      let x = args.TacticSkipClearTimeSeconds;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_TacticSkipClearTimeSeconds(x);
      let x = args.WorldRaidEchelonCount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_WorldRaidEchelonCount(x);
      let x = args.TimeAttackDungeonEchelonCount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_TimeAttackDungeonEchelonCount(x);
      let x = args.EventContentEchelonCount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_EventContentEchelonCount(x);
      let x = args.DefaultEchelonCount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_DefaultEchelonCount(x);
      let x = args.RaidEchelonCount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_RaidEchelonCount(x);
      let x = args.AdventureEchelonCount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_AdventureEchelonCount(x);
      let x = args.CanHealHpRate;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_CanHealHpRate(x);
      if let Some(x) = args.healCostAmount {
        builder.add_healCostAmount(x);
      }
      let x = args.HealCostType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_HealCostType(x);
      let x = args.CameraZoomDefault;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_CameraZoomDefault(x);
      let x = args.CameraZoomMin;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_CameraZoomMin(x);
      let x = args.CameraZoomMax;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_CameraZoomMax(x);
      let x = args.HexaMapStartCameraOffset;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_HexaMapStartCameraOffset(x);
      let x = args.HexaMapBoundaryOffset;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_HexaMapBoundaryOffset(x);
    builder.finish()
  }

  pub fn unpack(&self) -> ConstStrategyExcelT {
    let key = table_encryption_service::create_key(b"ConstStrategy");
      let HexaMapBoundaryOffset = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.HexaMapBoundaryOffset(), &key)
      } else {
        self.HexaMapBoundaryOffset()
      };
      let HexaMapStartCameraOffset = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.HexaMapStartCameraOffset(), &key)
      } else {
        self.HexaMapStartCameraOffset()
      };
      let CameraZoomMax = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.CameraZoomMax(), &key)
      } else {
        self.CameraZoomMax()
      };
      let CameraZoomMin = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.CameraZoomMin(), &key)
      } else {
        self.CameraZoomMin()
      };
      let CameraZoomDefault = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.CameraZoomDefault(), &key)
      } else {
        self.CameraZoomDefault()
      };
      let HealCostType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.HealCostType(), &key)
      } else {
        self.HealCostType()
      };
    let healCostAmount = self.healCostAmount().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_long(*val, &key) } else { *val }).collect()
    });
      let CanHealHpRate = self.CanHealHpRate();
      let PlayTimeLimitInSeconds = self.PlayTimeLimitInSeconds();
      let AdventureEchelonCount = self.AdventureEchelonCount();
      let RaidEchelonCount = self.RaidEchelonCount();
      let DefaultEchelonCount = self.DefaultEchelonCount();
      let EventContentEchelonCount = self.EventContentEchelonCount();
      let TimeAttackDungeonEchelonCount = self.TimeAttackDungeonEchelonCount();
      let WorldRaidEchelonCount = self.WorldRaidEchelonCount();
      let TacticSkipClearTimeSeconds = self.TacticSkipClearTimeSeconds();
      let TacticSkipFramePerSecond = self.TacticSkipFramePerSecond();
      let ConquestEchelonCount = self.ConquestEchelonCount();
      let StoryEchelonCount = self.StoryEchelonCount();
      let MultiSweepPresetCount = self.MultiSweepPresetCount();
      let MultiSweepPresetNameMaxLength = self.MultiSweepPresetNameMaxLength();
      let MultiSweepPresetSelectStageMaxCount = self.MultiSweepPresetSelectStageMaxCount();
      let MultiSweepPresetMaxSweepCount = self.MultiSweepPresetMaxSweepCount();
      let MultiSweepPresetSelectParcelMaxCount = self.MultiSweepPresetSelectParcelMaxCount();
    ConstStrategyExcelT {
      HexaMapBoundaryOffset,
      HexaMapStartCameraOffset,
      CameraZoomMax,
      CameraZoomMin,
      CameraZoomDefault,
      HealCostType,
      healCostAmount,
      CanHealHpRate,
      PlayTimeLimitInSeconds,
      AdventureEchelonCount,
      RaidEchelonCount,
      DefaultEchelonCount,
      EventContentEchelonCount,
      TimeAttackDungeonEchelonCount,
      WorldRaidEchelonCount,
      TacticSkipClearTimeSeconds,
      TacticSkipFramePerSecond,
      ConquestEchelonCount,
      StoryEchelonCount,
      MultiSweepPresetCount,
      MultiSweepPresetNameMaxLength,
      MultiSweepPresetSelectStageMaxCount,
      MultiSweepPresetMaxSweepCount,
      MultiSweepPresetSelectParcelMaxCount,
    }
  }

  #[inline]
  pub fn HexaMapBoundaryOffset(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ConstStrategyExcel::VT_HEXAMAPBOUNDARYOFFSET, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn HexaMapStartCameraOffset(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ConstStrategyExcel::VT_HEXAMAPSTARTCAMERAOFFSET, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn CameraZoomMax(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ConstStrategyExcel::VT_CAMERAZOOMMAX, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn CameraZoomMin(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ConstStrategyExcel::VT_CAMERAZOOMMIN, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn CameraZoomDefault(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ConstStrategyExcel::VT_CAMERAZOOMDEFAULT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn HealCostType(&self) -> CurrencyTypes {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<CurrencyTypes>(ConstStrategyExcel::VT_HEALCOSTTYPE, Some(CurrencyTypes::Invalid)).unwrap()}
  }
  #[inline]
  pub fn healCostAmount(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(ConstStrategyExcel::VT_HEALCOSTAMOUNT, None)}
  }
  #[inline]
  pub fn CanHealHpRate(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstStrategyExcel::VT_CANHEALHPRATE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn PlayTimeLimitInSeconds(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstStrategyExcel::VT_PLAYTIMELIMITINSECONDS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn AdventureEchelonCount(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstStrategyExcel::VT_ADVENTUREECHELONCOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn RaidEchelonCount(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstStrategyExcel::VT_RAIDECHELONCOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn DefaultEchelonCount(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstStrategyExcel::VT_DEFAULTECHELONCOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EventContentEchelonCount(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstStrategyExcel::VT_EVENTCONTENTECHELONCOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn TimeAttackDungeonEchelonCount(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstStrategyExcel::VT_TIMEATTACKDUNGEONECHELONCOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn WorldRaidEchelonCount(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstStrategyExcel::VT_WORLDRAIDECHELONCOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn TacticSkipClearTimeSeconds(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstStrategyExcel::VT_TACTICSKIPCLEARTIMESECONDS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn TacticSkipFramePerSecond(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstStrategyExcel::VT_TACTICSKIPFRAMEPERSECOND, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ConquestEchelonCount(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstStrategyExcel::VT_CONQUESTECHELONCOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn StoryEchelonCount(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstStrategyExcel::VT_STORYECHELONCOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn MultiSweepPresetCount(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstStrategyExcel::VT_MULTISWEEPPRESETCOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn MultiSweepPresetNameMaxLength(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstStrategyExcel::VT_MULTISWEEPPRESETNAMEMAXLENGTH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn MultiSweepPresetSelectStageMaxCount(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstStrategyExcel::VT_MULTISWEEPPRESETSELECTSTAGEMAXCOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn MultiSweepPresetMaxSweepCount(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstStrategyExcel::VT_MULTISWEEPPRESETMAXSWEEPCOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn MultiSweepPresetSelectParcelMaxCount(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstStrategyExcel::VT_MULTISWEEPPRESETSELECTPARCELMAXCOUNT, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ConstStrategyExcel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("HexaMapBoundaryOffset", Self::VT_HEXAMAPBOUNDARYOFFSET, false)?
     .visit_field::<f32>("HexaMapStartCameraOffset", Self::VT_HEXAMAPSTARTCAMERAOFFSET, false)?
     .visit_field::<f32>("CameraZoomMax", Self::VT_CAMERAZOOMMAX, false)?
     .visit_field::<f32>("CameraZoomMin", Self::VT_CAMERAZOOMMIN, false)?
     .visit_field::<f32>("CameraZoomDefault", Self::VT_CAMERAZOOMDEFAULT, false)?
     .visit_field::<CurrencyTypes>("HealCostType", Self::VT_HEALCOSTTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("healCostAmount", Self::VT_HEALCOSTAMOUNT, false)?
     .visit_field::<i32>("CanHealHpRate", Self::VT_CANHEALHPRATE, false)?
     .visit_field::<i64>("PlayTimeLimitInSeconds", Self::VT_PLAYTIMELIMITINSECONDS, false)?
     .visit_field::<i32>("AdventureEchelonCount", Self::VT_ADVENTUREECHELONCOUNT, false)?
     .visit_field::<i32>("RaidEchelonCount", Self::VT_RAIDECHELONCOUNT, false)?
     .visit_field::<i32>("DefaultEchelonCount", Self::VT_DEFAULTECHELONCOUNT, false)?
     .visit_field::<i32>("EventContentEchelonCount", Self::VT_EVENTCONTENTECHELONCOUNT, false)?
     .visit_field::<i32>("TimeAttackDungeonEchelonCount", Self::VT_TIMEATTACKDUNGEONECHELONCOUNT, false)?
     .visit_field::<i32>("WorldRaidEchelonCount", Self::VT_WORLDRAIDECHELONCOUNT, false)?
     .visit_field::<i32>("TacticSkipClearTimeSeconds", Self::VT_TACTICSKIPCLEARTIMESECONDS, false)?
     .visit_field::<i32>("TacticSkipFramePerSecond", Self::VT_TACTICSKIPFRAMEPERSECOND, false)?
     .visit_field::<i32>("ConquestEchelonCount", Self::VT_CONQUESTECHELONCOUNT, false)?
     .visit_field::<i32>("StoryEchelonCount", Self::VT_STORYECHELONCOUNT, false)?
     .visit_field::<i32>("MultiSweepPresetCount", Self::VT_MULTISWEEPPRESETCOUNT, false)?
     .visit_field::<i32>("MultiSweepPresetNameMaxLength", Self::VT_MULTISWEEPPRESETNAMEMAXLENGTH, false)?
     .visit_field::<i32>("MultiSweepPresetSelectStageMaxCount", Self::VT_MULTISWEEPPRESETSELECTSTAGEMAXCOUNT, false)?
     .visit_field::<i32>("MultiSweepPresetMaxSweepCount", Self::VT_MULTISWEEPPRESETMAXSWEEPCOUNT, false)?
     .visit_field::<i32>("MultiSweepPresetSelectParcelMaxCount", Self::VT_MULTISWEEPPRESETSELECTPARCELMAXCOUNT, false)?
     .finish();
    Ok(())
  }
}
pub struct ConstStrategyExcelArgs<'a> {
    pub HexaMapBoundaryOffset: f32,
    pub HexaMapStartCameraOffset: f32,
    pub CameraZoomMax: f32,
    pub CameraZoomMin: f32,
    pub CameraZoomDefault: f32,
    pub HealCostType: CurrencyTypes,
    pub healCostAmount: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub CanHealHpRate: i32,
    pub PlayTimeLimitInSeconds: i64,
    pub AdventureEchelonCount: i32,
    pub RaidEchelonCount: i32,
    pub DefaultEchelonCount: i32,
    pub EventContentEchelonCount: i32,
    pub TimeAttackDungeonEchelonCount: i32,
    pub WorldRaidEchelonCount: i32,
    pub TacticSkipClearTimeSeconds: i32,
    pub TacticSkipFramePerSecond: i32,
    pub ConquestEchelonCount: i32,
    pub StoryEchelonCount: i32,
    pub MultiSweepPresetCount: i32,
    pub MultiSweepPresetNameMaxLength: i32,
    pub MultiSweepPresetSelectStageMaxCount: i32,
    pub MultiSweepPresetMaxSweepCount: i32,
    pub MultiSweepPresetSelectParcelMaxCount: i32,
}
impl<'a> Default for ConstStrategyExcelArgs<'a> {
  #[inline]
  fn default() -> Self {
    ConstStrategyExcelArgs {
      HexaMapBoundaryOffset: 0.0,
      HexaMapStartCameraOffset: 0.0,
      CameraZoomMax: 0.0,
      CameraZoomMin: 0.0,
      CameraZoomDefault: 0.0,
      HealCostType: CurrencyTypes::Invalid,
      healCostAmount: None,
      CanHealHpRate: 0,
      PlayTimeLimitInSeconds: 0,
      AdventureEchelonCount: 0,
      RaidEchelonCount: 0,
      DefaultEchelonCount: 0,
      EventContentEchelonCount: 0,
      TimeAttackDungeonEchelonCount: 0,
      WorldRaidEchelonCount: 0,
      TacticSkipClearTimeSeconds: 0,
      TacticSkipFramePerSecond: 0,
      ConquestEchelonCount: 0,
      StoryEchelonCount: 0,
      MultiSweepPresetCount: 0,
      MultiSweepPresetNameMaxLength: 0,
      MultiSweepPresetSelectStageMaxCount: 0,
      MultiSweepPresetMaxSweepCount: 0,
      MultiSweepPresetSelectParcelMaxCount: 0,
    }
  }
}

impl Serialize for ConstStrategyExcel<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("ConstStrategyExcel", 24)?;
      s.serialize_field("HexaMapBoundaryOffset", &self.HexaMapBoundaryOffset())?;
      s.serialize_field("HexaMapStartCameraOffset", &self.HexaMapStartCameraOffset())?;
      s.serialize_field("CameraZoomMax", &self.CameraZoomMax())?;
      s.serialize_field("CameraZoomMin", &self.CameraZoomMin())?;
      s.serialize_field("CameraZoomDefault", &self.CameraZoomDefault())?;
      s.serialize_field("HealCostType", &self.HealCostType())?;
      if let Some(f) = self.healCostAmount() {
        s.serialize_field("healCostAmount", &f)?;
      } else {
        s.skip_field("healCostAmount")?;
      }
      s.serialize_field("CanHealHpRate", &self.CanHealHpRate())?;
      s.serialize_field("PlayTimeLimitInSeconds", &self.PlayTimeLimitInSeconds())?;
      s.serialize_field("AdventureEchelonCount", &self.AdventureEchelonCount())?;
      s.serialize_field("RaidEchelonCount", &self.RaidEchelonCount())?;
      s.serialize_field("DefaultEchelonCount", &self.DefaultEchelonCount())?;
      s.serialize_field("EventContentEchelonCount", &self.EventContentEchelonCount())?;
      s.serialize_field("TimeAttackDungeonEchelonCount", &self.TimeAttackDungeonEchelonCount())?;
      s.serialize_field("WorldRaidEchelonCount", &self.WorldRaidEchelonCount())?;
      s.serialize_field("TacticSkipClearTimeSeconds", &self.TacticSkipClearTimeSeconds())?;
      s.serialize_field("TacticSkipFramePerSecond", &self.TacticSkipFramePerSecond())?;
      s.serialize_field("ConquestEchelonCount", &self.ConquestEchelonCount())?;
      s.serialize_field("StoryEchelonCount", &self.StoryEchelonCount())?;
      s.serialize_field("MultiSweepPresetCount", &self.MultiSweepPresetCount())?;
      s.serialize_field("MultiSweepPresetNameMaxLength", &self.MultiSweepPresetNameMaxLength())?;
      s.serialize_field("MultiSweepPresetSelectStageMaxCount", &self.MultiSweepPresetSelectStageMaxCount())?;
      s.serialize_field("MultiSweepPresetMaxSweepCount", &self.MultiSweepPresetMaxSweepCount())?;
      s.serialize_field("MultiSweepPresetSelectParcelMaxCount", &self.MultiSweepPresetSelectParcelMaxCount())?;
    s.end()
  }
}

pub struct ConstStrategyExcelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ConstStrategyExcelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_HexaMapBoundaryOffset(&mut self, HexaMapBoundaryOffset: f32) {
    self.fbb_.push_slot::<f32>(ConstStrategyExcel::VT_HEXAMAPBOUNDARYOFFSET, HexaMapBoundaryOffset, 0.0);
  }
  #[inline]
  pub fn add_HexaMapStartCameraOffset(&mut self, HexaMapStartCameraOffset: f32) {
    self.fbb_.push_slot::<f32>(ConstStrategyExcel::VT_HEXAMAPSTARTCAMERAOFFSET, HexaMapStartCameraOffset, 0.0);
  }
  #[inline]
  pub fn add_CameraZoomMax(&mut self, CameraZoomMax: f32) {
    self.fbb_.push_slot::<f32>(ConstStrategyExcel::VT_CAMERAZOOMMAX, CameraZoomMax, 0.0);
  }
  #[inline]
  pub fn add_CameraZoomMin(&mut self, CameraZoomMin: f32) {
    self.fbb_.push_slot::<f32>(ConstStrategyExcel::VT_CAMERAZOOMMIN, CameraZoomMin, 0.0);
  }
  #[inline]
  pub fn add_CameraZoomDefault(&mut self, CameraZoomDefault: f32) {
    self.fbb_.push_slot::<f32>(ConstStrategyExcel::VT_CAMERAZOOMDEFAULT, CameraZoomDefault, 0.0);
  }
  #[inline]
  pub fn add_HealCostType(&mut self, HealCostType: CurrencyTypes) {
    self.fbb_.push_slot::<CurrencyTypes>(ConstStrategyExcel::VT_HEALCOSTTYPE, HealCostType, CurrencyTypes::Invalid);
  }
  #[inline]
  pub fn add_healCostAmount(&mut self, healCostAmount: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConstStrategyExcel::VT_HEALCOSTAMOUNT, healCostAmount);
  }
  #[inline]
  pub fn add_CanHealHpRate(&mut self, CanHealHpRate: i32) {
    self.fbb_.push_slot::<i32>(ConstStrategyExcel::VT_CANHEALHPRATE, CanHealHpRate, 0);
  }
  #[inline]
  pub fn add_PlayTimeLimitInSeconds(&mut self, PlayTimeLimitInSeconds: i64) {
    self.fbb_.push_slot::<i64>(ConstStrategyExcel::VT_PLAYTIMELIMITINSECONDS, PlayTimeLimitInSeconds, 0);
  }
  #[inline]
  pub fn add_AdventureEchelonCount(&mut self, AdventureEchelonCount: i32) {
    self.fbb_.push_slot::<i32>(ConstStrategyExcel::VT_ADVENTUREECHELONCOUNT, AdventureEchelonCount, 0);
  }
  #[inline]
  pub fn add_RaidEchelonCount(&mut self, RaidEchelonCount: i32) {
    self.fbb_.push_slot::<i32>(ConstStrategyExcel::VT_RAIDECHELONCOUNT, RaidEchelonCount, 0);
  }
  #[inline]
  pub fn add_DefaultEchelonCount(&mut self, DefaultEchelonCount: i32) {
    self.fbb_.push_slot::<i32>(ConstStrategyExcel::VT_DEFAULTECHELONCOUNT, DefaultEchelonCount, 0);
  }
  #[inline]
  pub fn add_EventContentEchelonCount(&mut self, EventContentEchelonCount: i32) {
    self.fbb_.push_slot::<i32>(ConstStrategyExcel::VT_EVENTCONTENTECHELONCOUNT, EventContentEchelonCount, 0);
  }
  #[inline]
  pub fn add_TimeAttackDungeonEchelonCount(&mut self, TimeAttackDungeonEchelonCount: i32) {
    self.fbb_.push_slot::<i32>(ConstStrategyExcel::VT_TIMEATTACKDUNGEONECHELONCOUNT, TimeAttackDungeonEchelonCount, 0);
  }
  #[inline]
  pub fn add_WorldRaidEchelonCount(&mut self, WorldRaidEchelonCount: i32) {
    self.fbb_.push_slot::<i32>(ConstStrategyExcel::VT_WORLDRAIDECHELONCOUNT, WorldRaidEchelonCount, 0);
  }
  #[inline]
  pub fn add_TacticSkipClearTimeSeconds(&mut self, TacticSkipClearTimeSeconds: i32) {
    self.fbb_.push_slot::<i32>(ConstStrategyExcel::VT_TACTICSKIPCLEARTIMESECONDS, TacticSkipClearTimeSeconds, 0);
  }
  #[inline]
  pub fn add_TacticSkipFramePerSecond(&mut self, TacticSkipFramePerSecond: i32) {
    self.fbb_.push_slot::<i32>(ConstStrategyExcel::VT_TACTICSKIPFRAMEPERSECOND, TacticSkipFramePerSecond, 0);
  }
  #[inline]
  pub fn add_ConquestEchelonCount(&mut self, ConquestEchelonCount: i32) {
    self.fbb_.push_slot::<i32>(ConstStrategyExcel::VT_CONQUESTECHELONCOUNT, ConquestEchelonCount, 0);
  }
  #[inline]
  pub fn add_StoryEchelonCount(&mut self, StoryEchelonCount: i32) {
    self.fbb_.push_slot::<i32>(ConstStrategyExcel::VT_STORYECHELONCOUNT, StoryEchelonCount, 0);
  }
  #[inline]
  pub fn add_MultiSweepPresetCount(&mut self, MultiSweepPresetCount: i32) {
    self.fbb_.push_slot::<i32>(ConstStrategyExcel::VT_MULTISWEEPPRESETCOUNT, MultiSweepPresetCount, 0);
  }
  #[inline]
  pub fn add_MultiSweepPresetNameMaxLength(&mut self, MultiSweepPresetNameMaxLength: i32) {
    self.fbb_.push_slot::<i32>(ConstStrategyExcel::VT_MULTISWEEPPRESETNAMEMAXLENGTH, MultiSweepPresetNameMaxLength, 0);
  }
  #[inline]
  pub fn add_MultiSweepPresetSelectStageMaxCount(&mut self, MultiSweepPresetSelectStageMaxCount: i32) {
    self.fbb_.push_slot::<i32>(ConstStrategyExcel::VT_MULTISWEEPPRESETSELECTSTAGEMAXCOUNT, MultiSweepPresetSelectStageMaxCount, 0);
  }
  #[inline]
  pub fn add_MultiSweepPresetMaxSweepCount(&mut self, MultiSweepPresetMaxSweepCount: i32) {
    self.fbb_.push_slot::<i32>(ConstStrategyExcel::VT_MULTISWEEPPRESETMAXSWEEPCOUNT, MultiSweepPresetMaxSweepCount, 0);
  }
  #[inline]
  pub fn add_MultiSweepPresetSelectParcelMaxCount(&mut self, MultiSweepPresetSelectParcelMaxCount: i32) {
    self.fbb_.push_slot::<i32>(ConstStrategyExcel::VT_MULTISWEEPPRESETSELECTPARCELMAXCOUNT, MultiSweepPresetSelectParcelMaxCount, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ConstStrategyExcelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ConstStrategyExcelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ConstStrategyExcel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ConstStrategyExcel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ConstStrategyExcel");
      ds.field("HexaMapBoundaryOffset", &self.HexaMapBoundaryOffset());
      ds.field("HexaMapStartCameraOffset", &self.HexaMapStartCameraOffset());
      ds.field("CameraZoomMax", &self.CameraZoomMax());
      ds.field("CameraZoomMin", &self.CameraZoomMin());
      ds.field("CameraZoomDefault", &self.CameraZoomDefault());
      ds.field("HealCostType", &self.HealCostType());
      ds.field("healCostAmount", &self.healCostAmount());
      ds.field("CanHealHpRate", &self.CanHealHpRate());
      ds.field("PlayTimeLimitInSeconds", &self.PlayTimeLimitInSeconds());
      ds.field("AdventureEchelonCount", &self.AdventureEchelonCount());
      ds.field("RaidEchelonCount", &self.RaidEchelonCount());
      ds.field("DefaultEchelonCount", &self.DefaultEchelonCount());
      ds.field("EventContentEchelonCount", &self.EventContentEchelonCount());
      ds.field("TimeAttackDungeonEchelonCount", &self.TimeAttackDungeonEchelonCount());
      ds.field("WorldRaidEchelonCount", &self.WorldRaidEchelonCount());
      ds.field("TacticSkipClearTimeSeconds", &self.TacticSkipClearTimeSeconds());
      ds.field("TacticSkipFramePerSecond", &self.TacticSkipFramePerSecond());
      ds.field("ConquestEchelonCount", &self.ConquestEchelonCount());
      ds.field("StoryEchelonCount", &self.StoryEchelonCount());
      ds.field("MultiSweepPresetCount", &self.MultiSweepPresetCount());
      ds.field("MultiSweepPresetNameMaxLength", &self.MultiSweepPresetNameMaxLength());
      ds.field("MultiSweepPresetSelectStageMaxCount", &self.MultiSweepPresetSelectStageMaxCount());
      ds.field("MultiSweepPresetMaxSweepCount", &self.MultiSweepPresetMaxSweepCount());
      ds.field("MultiSweepPresetSelectParcelMaxCount", &self.MultiSweepPresetSelectParcelMaxCount());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ConstStrategyExcelT {
  pub HexaMapBoundaryOffset: f32,
  pub HexaMapStartCameraOffset: f32,
  pub CameraZoomMax: f32,
  pub CameraZoomMin: f32,
  pub CameraZoomDefault: f32,
  pub HealCostType: CurrencyTypes,
  pub healCostAmount: Option<Vec<i64>>,
  pub CanHealHpRate: i32,
  pub PlayTimeLimitInSeconds: i64,
  pub AdventureEchelonCount: i32,
  pub RaidEchelonCount: i32,
  pub DefaultEchelonCount: i32,
  pub EventContentEchelonCount: i32,
  pub TimeAttackDungeonEchelonCount: i32,
  pub WorldRaidEchelonCount: i32,
  pub TacticSkipClearTimeSeconds: i32,
  pub TacticSkipFramePerSecond: i32,
  pub ConquestEchelonCount: i32,
  pub StoryEchelonCount: i32,
  pub MultiSweepPresetCount: i32,
  pub MultiSweepPresetNameMaxLength: i32,
  pub MultiSweepPresetSelectStageMaxCount: i32,
  pub MultiSweepPresetMaxSweepCount: i32,
  pub MultiSweepPresetSelectParcelMaxCount: i32,
}
impl Default for ConstStrategyExcelT {
  fn default() -> Self {
    Self {
      HexaMapBoundaryOffset: 0.0,
      HexaMapStartCameraOffset: 0.0,
      CameraZoomMax: 0.0,
      CameraZoomMin: 0.0,
      CameraZoomDefault: 0.0,
      HealCostType: CurrencyTypes::Invalid,
      healCostAmount: None,
      CanHealHpRate: 0,
      PlayTimeLimitInSeconds: 0,
      AdventureEchelonCount: 0,
      RaidEchelonCount: 0,
      DefaultEchelonCount: 0,
      EventContentEchelonCount: 0,
      TimeAttackDungeonEchelonCount: 0,
      WorldRaidEchelonCount: 0,
      TacticSkipClearTimeSeconds: 0,
      TacticSkipFramePerSecond: 0,
      ConquestEchelonCount: 0,
      StoryEchelonCount: 0,
      MultiSweepPresetCount: 0,
      MultiSweepPresetNameMaxLength: 0,
      MultiSweepPresetSelectStageMaxCount: 0,
      MultiSweepPresetMaxSweepCount: 0,
      MultiSweepPresetSelectParcelMaxCount: 0,
    }
  }
}
impl ConstStrategyExcelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ConstStrategyExcel<'b>> {
    let HexaMapBoundaryOffset = self.HexaMapBoundaryOffset;
    let HexaMapStartCameraOffset = self.HexaMapStartCameraOffset;
    let CameraZoomMax = self.CameraZoomMax;
    let CameraZoomMin = self.CameraZoomMin;
    let CameraZoomDefault = self.CameraZoomDefault;
    let HealCostType = self.HealCostType;
    let healCostAmount = self.healCostAmount.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let CanHealHpRate = self.CanHealHpRate;
    let PlayTimeLimitInSeconds = self.PlayTimeLimitInSeconds;
    let AdventureEchelonCount = self.AdventureEchelonCount;
    let RaidEchelonCount = self.RaidEchelonCount;
    let DefaultEchelonCount = self.DefaultEchelonCount;
    let EventContentEchelonCount = self.EventContentEchelonCount;
    let TimeAttackDungeonEchelonCount = self.TimeAttackDungeonEchelonCount;
    let WorldRaidEchelonCount = self.WorldRaidEchelonCount;
    let TacticSkipClearTimeSeconds = self.TacticSkipClearTimeSeconds;
    let TacticSkipFramePerSecond = self.TacticSkipFramePerSecond;
    let ConquestEchelonCount = self.ConquestEchelonCount;
    let StoryEchelonCount = self.StoryEchelonCount;
    let MultiSweepPresetCount = self.MultiSweepPresetCount;
    let MultiSweepPresetNameMaxLength = self.MultiSweepPresetNameMaxLength;
    let MultiSweepPresetSelectStageMaxCount = self.MultiSweepPresetSelectStageMaxCount;
    let MultiSweepPresetMaxSweepCount = self.MultiSweepPresetMaxSweepCount;
    let MultiSweepPresetSelectParcelMaxCount = self.MultiSweepPresetSelectParcelMaxCount;
    ConstStrategyExcel::create(_fbb, &ConstStrategyExcelArgs{
      HexaMapBoundaryOffset,
      HexaMapStartCameraOffset,
      CameraZoomMax,
      CameraZoomMin,
      CameraZoomDefault,
      HealCostType,
      healCostAmount,
      CanHealHpRate,
      PlayTimeLimitInSeconds,
      AdventureEchelonCount,
      RaidEchelonCount,
      DefaultEchelonCount,
      EventContentEchelonCount,
      TimeAttackDungeonEchelonCount,
      WorldRaidEchelonCount,
      TacticSkipClearTimeSeconds,
      TacticSkipFramePerSecond,
      ConquestEchelonCount,
      StoryEchelonCount,
      MultiSweepPresetCount,
      MultiSweepPresetNameMaxLength,
      MultiSweepPresetSelectStageMaxCount,
      MultiSweepPresetMaxSweepCount,
      MultiSweepPresetSelectParcelMaxCount,
    })
  }
}
