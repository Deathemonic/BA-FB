// automatically generated by the FlatBuffers compiler, do not modify
// @generated
#![allow(unused_imports, dead_code)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum GroundExcelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GroundExcel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GroundExcel<'a> {
  type Inner = GroundExcel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GroundExcel<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_STAGEFILENAME: flatbuffers::VOffsetT = 6;
  pub const VT_GROUNDSCENENAME: flatbuffers::VOffsetT = 8;
  pub const VT_FORMATIONGROUPID: flatbuffers::VOffsetT = 10;
  pub const VT_STAGETOPOGRAPHY: flatbuffers::VOffsetT = 12;
  pub const VT_ENEMYBULLETTYPE: flatbuffers::VOffsetT = 14;
  pub const VT_ENEMYARMORTYPE: flatbuffers::VOffsetT = 16;
  pub const VT_LEVELNPC: flatbuffers::VOffsetT = 18;
  pub const VT_LEVELMINION: flatbuffers::VOffsetT = 20;
  pub const VT_LEVELELITE: flatbuffers::VOffsetT = 22;
  pub const VT_LEVELCHAMPION: flatbuffers::VOffsetT = 24;
  pub const VT_LEVELBOSS: flatbuffers::VOffsetT = 26;
  pub const VT_OBSTACLELEVEL: flatbuffers::VOffsetT = 28;
  pub const VT_GRADENPC: flatbuffers::VOffsetT = 30;
  pub const VT_GRADEMINION: flatbuffers::VOffsetT = 32;
  pub const VT_GRADEELITE: flatbuffers::VOffsetT = 34;
  pub const VT_GRADECHAMPION: flatbuffers::VOffsetT = 36;
  pub const VT_GRADEBOSS: flatbuffers::VOffsetT = 38;
  pub const VT_PLAYERSIGHTPOINTADD: flatbuffers::VOffsetT = 40;
  pub const VT_PLAYERSIGHTPOINTRATE: flatbuffers::VOffsetT = 42;
  pub const VT_PLAYERATTACKRANGEADD: flatbuffers::VOffsetT = 44;
  pub const VT_PLAYERATTACKRANGERATE: flatbuffers::VOffsetT = 46;
  pub const VT_ENEMYSIGHTPOINTADD: flatbuffers::VOffsetT = 48;
  pub const VT_ENEMYSIGHTPOINTRATE: flatbuffers::VOffsetT = 50;
  pub const VT_ENEMYATTACKRANGEADD: flatbuffers::VOffsetT = 52;
  pub const VT_ENEMYATTACKRANGERATE: flatbuffers::VOffsetT = 54;
  pub const VT_PLAYERSKILLRANGEADD: flatbuffers::VOffsetT = 56;
  pub const VT_PLAYERSKILLRANGERATE: flatbuffers::VOffsetT = 58;
  pub const VT_ENEMYSKILLRANGEADD: flatbuffers::VOffsetT = 60;
  pub const VT_ENEMYSKILLRANGERATE: flatbuffers::VOffsetT = 62;
  pub const VT_PLAYERMINIMUMPOSITIONGAPRATE: flatbuffers::VOffsetT = 64;
  pub const VT_ENEMYMINIMUMPOSITIONGAPRATE: flatbuffers::VOffsetT = 66;
  pub const VT_PLAYERSIGHTRANGEMAX: flatbuffers::VOffsetT = 68;
  pub const VT_ENEMYSIGHTRANGEMAX: flatbuffers::VOffsetT = 70;
  pub const VT_TSSAIRUNITHEIGHT: flatbuffers::VOffsetT = 72;
  pub const VT_ISPHASEBGM: flatbuffers::VOffsetT = 74;
  pub const VT_BGMID: flatbuffers::VOffsetT = 76;
  pub const VT_WARNINGUI: flatbuffers::VOffsetT = 78;
  pub const VT_TSSHATCHOPEN: flatbuffers::VOffsetT = 80;
  pub const VT_FORCEDTACTICSPEED: flatbuffers::VOffsetT = 82;
  pub const VT_FORCEDSKILLUSE: flatbuffers::VOffsetT = 84;
  pub const VT_SHOWNPCSKILLCUTIN: flatbuffers::VOffsetT = 86;
  pub const VT_IMMUNEHITBEFORETIMEOUTEND: flatbuffers::VOffsetT = 88;
  pub const VT_UIBATTLEHIDEFROMSCRATCH: flatbuffers::VOffsetT = 90;
  pub const VT_UIENEMYCOUNT: flatbuffers::VOffsetT = 92;
  pub const VT_BATTLEREADYTIMELINEPATH: flatbuffers::VOffsetT = 94;
  pub const VT_BEFOREVICTORYTIMELINEPATH: flatbuffers::VOffsetT = 96;
  pub const VT_SKIPBATTLEEND: flatbuffers::VOffsetT = 98;
  pub const VT_HIDENPCWHENBATTLEEND: flatbuffers::VOffsetT = 100;
  pub const VT_COVERPOINTOFF: flatbuffers::VOffsetT = 102;
  pub const VT_UIHPSCALE: flatbuffers::VOffsetT = 104;
  pub const VT_UIEMOJISCALE: flatbuffers::VOffsetT = 106;
  pub const VT_UISKILLMAINLOGSCALE: flatbuffers::VOffsetT = 108;
  pub const VT_EFFECTCOUNTLIMIT: flatbuffers::VOffsetT = 110;
  pub const VT_ALLYPASSIVESKILLID: flatbuffers::VOffsetT = 112;
  pub const VT_ALLYPASSIVESKILLLEVEL: flatbuffers::VOffsetT = 114;
  pub const VT_ENEMYPASSIVESKILLID: flatbuffers::VOffsetT = 116;
  pub const VT_ENEMYPASSIVESKILLLEVEL: flatbuffers::VOffsetT = 118;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GroundExcel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GroundExcelArgs<'args>
  ) -> flatbuffers::WIPOffset<GroundExcel<'bldr>> {
    let mut builder = GroundExcelBuilder::new(_fbb);
    let key = table_encryption_service::create_key(b"Ground");
      let x = args.BGMId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_BGMId(x);
      let x = args.TSSAirUnitHeight;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_TSSAirUnitHeight(x);
      let x = args.EnemyMinimumPositionGapRate;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_EnemyMinimumPositionGapRate(x);
      let x = args.PlayerMinimumPositionGapRate;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_PlayerMinimumPositionGapRate(x);
      let x = args.EnemySkillRangeRate;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_EnemySkillRangeRate(x);
      let x = args.EnemySkillRangeAdd;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_EnemySkillRangeAdd(x);
      let x = args.PlayerSkillRangeRate;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_PlayerSkillRangeRate(x);
      let x = args.PlayerSkillRangeAdd;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_PlayerSkillRangeAdd(x);
      let x = args.EnemyAttackRangeRate;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_EnemyAttackRangeRate(x);
      let x = args.EnemyAttackRangeAdd;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_EnemyAttackRangeAdd(x);
      let x = args.EnemySightPointRate;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_EnemySightPointRate(x);
      let x = args.EnemySightPointAdd;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_EnemySightPointAdd(x);
      let x = args.PlayerAttackRangeRate;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_PlayerAttackRangeRate(x);
      let x = args.PlayerAttackRangeAdd;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_PlayerAttackRangeAdd(x);
      let x = args.PlayerSightPointRate;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_PlayerSightPointRate(x);
      let x = args.PlayerSightPointAdd;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_PlayerSightPointAdd(x);
      let x = args.GradeBoss;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_GradeBoss(x);
      let x = args.GradeChampion;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_GradeChampion(x);
      let x = args.GradeElite;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_GradeElite(x);
      let x = args.GradeMinion;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_GradeMinion(x);
      let x = args.GradeNPC;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_GradeNPC(x);
      let x = args.ObstacleLevel;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_ObstacleLevel(x);
      let x = args.LevelBoss;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_LevelBoss(x);
      let x = args.LevelChampion;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_LevelChampion(x);
      let x = args.LevelElite;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_LevelElite(x);
      let x = args.LevelMinion;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_LevelMinion(x);
      let x = args.LevelNPC;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_LevelNPC(x);
      let x = args.FormationGroupId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_FormationGroupId(x);
      let x = args.Id;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_Id(x);
      if let Some(x) = args.EnemyPassiveSkillLevel {
        builder.add_EnemyPassiveSkillLevel(x);
      }
      if let Some(x) = args.EnemyPassiveSkillId {
        builder.add_EnemyPassiveSkillId(x);
      }
      if let Some(x) = args.AllyPassiveSkillLevel {
        builder.add_AllyPassiveSkillLevel(x);
      }
      if let Some(x) = args.AllyPassiveSkillId {
        builder.add_AllyPassiveSkillId(x);
      }
      let x = args.EffectCountLimit;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_EffectCountLimit(x);
      let x = args.UISkillMainLogScale;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_UISkillMainLogScale(x);
      let x = args.UIEmojiScale;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_UIEmojiScale(x);
      let x = args.UIHpScale;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_UIHpScale(x);
      if let Some(x) = args.BeforeVictoryTimelinePath {
        builder.add_BeforeVictoryTimelinePath(x);
      }
      if let Some(x) = args.BattleReadyTimelinePath {
        builder.add_BattleReadyTimelinePath(x);
      }
      let x = args.UIEnemyCount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_UIEnemyCount(x);
      let x = args.ShowNPCSkillCutIn;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_ShowNPCSkillCutIn(x);
      let x = args.ForcedSkillUse;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_ForcedSkillUse(x);
      let x = args.ForcedTacticSpeed;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_ForcedTacticSpeed(x);
      let x = args.EnemyArmorType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_EnemyArmorType(x);
      let x = args.EnemyBulletType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_EnemyBulletType(x);
      let x = args.StageTopography;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_StageTopography(x);
      if let Some(x) = args.GroundSceneName {
        builder.add_GroundSceneName(x);
      }
      if let Some(x) = args.StageFileName {
        builder.add_StageFileName(x);
      }
      builder.add_CoverPointOff(args.CoverPointOff);
      builder.add_HideNPCWhenBattleEnd(args.HideNPCWhenBattleEnd);
      builder.add_SkipBattleEnd(args.SkipBattleEnd);
      builder.add_UIBattleHideFromScratch(args.UIBattleHideFromScratch);
      builder.add_ImmuneHitBeforeTimeOutEnd(args.ImmuneHitBeforeTimeOutEnd);
      builder.add_TSSHatchOpen(args.TSSHatchOpen);
      builder.add_WarningUI(args.WarningUI);
      builder.add_IsPhaseBGM(args.IsPhaseBGM);
      builder.add_EnemySightRangeMax(args.EnemySightRangeMax);
      builder.add_PlayerSightRangeMax(args.PlayerSightRangeMax);
    builder.finish()
  }

  pub fn unpack(&self) -> GroundExcelT {
    let key = table_encryption_service::create_key(b"Ground");
      let Id = self.Id();
    let StageFileName = self.StageFileName().map(|x| {
      x.iter().map(|s| if table_encryption_service::use_encryption() { table_encryption_service::convert_string(s, &key).unwrap() } else { s.to_string() }).collect()
    });
    let GroundSceneName = self.GroundSceneName().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let FormationGroupId = self.FormationGroupId();
      let StageTopography = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.StageTopography(), &key)
      } else {
        self.StageTopography()
      };
      let EnemyBulletType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.EnemyBulletType(), &key)
      } else {
        self.EnemyBulletType()
      };
      let EnemyArmorType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.EnemyArmorType(), &key)
      } else {
        self.EnemyArmorType()
      };
      let LevelNPC = self.LevelNPC();
      let LevelMinion = self.LevelMinion();
      let LevelElite = self.LevelElite();
      let LevelChampion = self.LevelChampion();
      let LevelBoss = self.LevelBoss();
      let ObstacleLevel = self.ObstacleLevel();
      let GradeNPC = self.GradeNPC();
      let GradeMinion = self.GradeMinion();
      let GradeElite = self.GradeElite();
      let GradeChampion = self.GradeChampion();
      let GradeBoss = self.GradeBoss();
      let PlayerSightPointAdd = self.PlayerSightPointAdd();
      let PlayerSightPointRate = self.PlayerSightPointRate();
      let PlayerAttackRangeAdd = self.PlayerAttackRangeAdd();
      let PlayerAttackRangeRate = self.PlayerAttackRangeRate();
      let EnemySightPointAdd = self.EnemySightPointAdd();
      let EnemySightPointRate = self.EnemySightPointRate();
      let EnemyAttackRangeAdd = self.EnemyAttackRangeAdd();
      let EnemyAttackRangeRate = self.EnemyAttackRangeRate();
      let PlayerSkillRangeAdd = self.PlayerSkillRangeAdd();
      let PlayerSkillRangeRate = self.PlayerSkillRangeRate();
      let EnemySkillRangeAdd = self.EnemySkillRangeAdd();
      let EnemySkillRangeRate = self.EnemySkillRangeRate();
      let PlayerMinimumPositionGapRate = self.PlayerMinimumPositionGapRate();
      let EnemyMinimumPositionGapRate = self.EnemyMinimumPositionGapRate();
      let PlayerSightRangeMax = self.PlayerSightRangeMax();
      let EnemySightRangeMax = self.EnemySightRangeMax();
      let TSSAirUnitHeight = self.TSSAirUnitHeight();
      let IsPhaseBGM = self.IsPhaseBGM();
      let BGMId = self.BGMId();
      let WarningUI = self.WarningUI();
      let TSSHatchOpen = self.TSSHatchOpen();
      let ForcedTacticSpeed = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.ForcedTacticSpeed(), &key)
      } else {
        self.ForcedTacticSpeed()
      };
      let ForcedSkillUse = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.ForcedSkillUse(), &key)
      } else {
        self.ForcedSkillUse()
      };
      let ShowNPCSkillCutIn = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.ShowNPCSkillCutIn(), &key)
      } else {
        self.ShowNPCSkillCutIn()
      };
      let ImmuneHitBeforeTimeOutEnd = self.ImmuneHitBeforeTimeOutEnd();
      let UIBattleHideFromScratch = self.UIBattleHideFromScratch();
      let UIEnemyCount = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.UIEnemyCount(), &key)
      } else {
        self.UIEnemyCount()
      };
    let BattleReadyTimelinePath = self.BattleReadyTimelinePath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let BeforeVictoryTimelinePath = self.BeforeVictoryTimelinePath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let SkipBattleEnd = self.SkipBattleEnd();
      let HideNPCWhenBattleEnd = self.HideNPCWhenBattleEnd();
      let CoverPointOff = self.CoverPointOff();
      let UIHpScale = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.UIHpScale(), &key)
      } else {
        self.UIHpScale()
      };
      let UIEmojiScale = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.UIEmojiScale(), &key)
      } else {
        self.UIEmojiScale()
      };
      let UISkillMainLogScale = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.UISkillMainLogScale(), &key)
      } else {
        self.UISkillMainLogScale()
      };
      let EffectCountLimit = self.EffectCountLimit();
    let AllyPassiveSkillId = self.AllyPassiveSkillId().map(|x| {
      x.iter().map(|s| if table_encryption_service::use_encryption() { table_encryption_service::convert_string(s, &key).unwrap() } else { s.to_string() }).collect()
    });
    let AllyPassiveSkillLevel = self.AllyPassiveSkillLevel().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_int(*val, &key) } else { *val }).collect()
    });
    let EnemyPassiveSkillId = self.EnemyPassiveSkillId().map(|x| {
      x.iter().map(|s| if table_encryption_service::use_encryption() { table_encryption_service::convert_string(s, &key).unwrap() } else { s.to_string() }).collect()
    });
    let EnemyPassiveSkillLevel = self.EnemyPassiveSkillLevel().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_int(*val, &key) } else { *val }).collect()
    });
    GroundExcelT {
      Id,
      StageFileName,
      GroundSceneName,
      FormationGroupId,
      StageTopography,
      EnemyBulletType,
      EnemyArmorType,
      LevelNPC,
      LevelMinion,
      LevelElite,
      LevelChampion,
      LevelBoss,
      ObstacleLevel,
      GradeNPC,
      GradeMinion,
      GradeElite,
      GradeChampion,
      GradeBoss,
      PlayerSightPointAdd,
      PlayerSightPointRate,
      PlayerAttackRangeAdd,
      PlayerAttackRangeRate,
      EnemySightPointAdd,
      EnemySightPointRate,
      EnemyAttackRangeAdd,
      EnemyAttackRangeRate,
      PlayerSkillRangeAdd,
      PlayerSkillRangeRate,
      EnemySkillRangeAdd,
      EnemySkillRangeRate,
      PlayerMinimumPositionGapRate,
      EnemyMinimumPositionGapRate,
      PlayerSightRangeMax,
      EnemySightRangeMax,
      TSSAirUnitHeight,
      IsPhaseBGM,
      BGMId,
      WarningUI,
      TSSHatchOpen,
      ForcedTacticSpeed,
      ForcedSkillUse,
      ShowNPCSkillCutIn,
      ImmuneHitBeforeTimeOutEnd,
      UIBattleHideFromScratch,
      UIEnemyCount,
      BattleReadyTimelinePath,
      BeforeVictoryTimelinePath,
      SkipBattleEnd,
      HideNPCWhenBattleEnd,
      CoverPointOff,
      UIHpScale,
      UIEmojiScale,
      UISkillMainLogScale,
      EffectCountLimit,
      AllyPassiveSkillId,
      AllyPassiveSkillLevel,
      EnemyPassiveSkillId,
      EnemyPassiveSkillLevel,
    }
  }

  #[inline]
  pub fn Id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GroundExcel::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn StageFileName(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(GroundExcel::VT_STAGEFILENAME, None)}
  }
  #[inline]
  pub fn GroundSceneName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GroundExcel::VT_GROUNDSCENENAME, None)}
  }
  #[inline]
  pub fn FormationGroupId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GroundExcel::VT_FORMATIONGROUPID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn StageTopography(&self) -> StageTopography {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<StageTopography>(GroundExcel::VT_STAGETOPOGRAPHY, Some(StageTopography::Street)).unwrap()}
  }
  #[inline]
  pub fn EnemyBulletType(&self) -> BulletType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<BulletType>(GroundExcel::VT_ENEMYBULLETTYPE, Some(BulletType::Normal)).unwrap()}
  }
  #[inline]
  pub fn EnemyArmorType(&self) -> ArmorType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ArmorType>(GroundExcel::VT_ENEMYARMORTYPE, Some(ArmorType::LightArmor)).unwrap()}
  }
  #[inline]
  pub fn LevelNPC(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GroundExcel::VT_LEVELNPC, Some(0)).unwrap()}
  }
  #[inline]
  pub fn LevelMinion(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GroundExcel::VT_LEVELMINION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn LevelElite(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GroundExcel::VT_LEVELELITE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn LevelChampion(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GroundExcel::VT_LEVELCHAMPION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn LevelBoss(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GroundExcel::VT_LEVELBOSS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ObstacleLevel(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GroundExcel::VT_OBSTACLELEVEL, Some(0)).unwrap()}
  }
  #[inline]
  pub fn GradeNPC(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GroundExcel::VT_GRADENPC, Some(0)).unwrap()}
  }
  #[inline]
  pub fn GradeMinion(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GroundExcel::VT_GRADEMINION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn GradeElite(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GroundExcel::VT_GRADEELITE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn GradeChampion(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GroundExcel::VT_GRADECHAMPION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn GradeBoss(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GroundExcel::VT_GRADEBOSS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn PlayerSightPointAdd(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GroundExcel::VT_PLAYERSIGHTPOINTADD, Some(0)).unwrap()}
  }
  #[inline]
  pub fn PlayerSightPointRate(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GroundExcel::VT_PLAYERSIGHTPOINTRATE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn PlayerAttackRangeAdd(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GroundExcel::VT_PLAYERATTACKRANGEADD, Some(0)).unwrap()}
  }
  #[inline]
  pub fn PlayerAttackRangeRate(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GroundExcel::VT_PLAYERATTACKRANGERATE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EnemySightPointAdd(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GroundExcel::VT_ENEMYSIGHTPOINTADD, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EnemySightPointRate(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GroundExcel::VT_ENEMYSIGHTPOINTRATE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EnemyAttackRangeAdd(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GroundExcel::VT_ENEMYATTACKRANGEADD, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EnemyAttackRangeRate(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GroundExcel::VT_ENEMYATTACKRANGERATE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn PlayerSkillRangeAdd(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GroundExcel::VT_PLAYERSKILLRANGEADD, Some(0)).unwrap()}
  }
  #[inline]
  pub fn PlayerSkillRangeRate(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GroundExcel::VT_PLAYERSKILLRANGERATE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EnemySkillRangeAdd(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GroundExcel::VT_ENEMYSKILLRANGEADD, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EnemySkillRangeRate(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GroundExcel::VT_ENEMYSKILLRANGERATE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn PlayerMinimumPositionGapRate(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GroundExcel::VT_PLAYERMINIMUMPOSITIONGAPRATE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EnemyMinimumPositionGapRate(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GroundExcel::VT_ENEMYMINIMUMPOSITIONGAPRATE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn PlayerSightRangeMax(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GroundExcel::VT_PLAYERSIGHTRANGEMAX, Some(false)).unwrap()}
  }
  #[inline]
  pub fn EnemySightRangeMax(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GroundExcel::VT_ENEMYSIGHTRANGEMAX, Some(false)).unwrap()}
  }
  #[inline]
  pub fn TSSAirUnitHeight(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GroundExcel::VT_TSSAIRUNITHEIGHT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn IsPhaseBGM(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GroundExcel::VT_ISPHASEBGM, Some(false)).unwrap()}
  }
  #[inline]
  pub fn BGMId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(GroundExcel::VT_BGMID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn WarningUI(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GroundExcel::VT_WARNINGUI, Some(false)).unwrap()}
  }
  #[inline]
  pub fn TSSHatchOpen(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GroundExcel::VT_TSSHATCHOPEN, Some(false)).unwrap()}
  }
  #[inline]
  pub fn ForcedTacticSpeed(&self) -> TacticSpeed {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TacticSpeed>(GroundExcel::VT_FORCEDTACTICSPEED, Some(TacticSpeed::None)).unwrap()}
  }
  #[inline]
  pub fn ForcedSkillUse(&self) -> TacticSkillUse {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TacticSkillUse>(GroundExcel::VT_FORCEDSKILLUSE, Some(TacticSkillUse::None)).unwrap()}
  }
  #[inline]
  pub fn ShowNPCSkillCutIn(&self) -> ShowSkillCutIn {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ShowSkillCutIn>(GroundExcel::VT_SHOWNPCSKILLCUTIN, Some(ShowSkillCutIn::None)).unwrap()}
  }
  #[inline]
  pub fn ImmuneHitBeforeTimeOutEnd(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GroundExcel::VT_IMMUNEHITBEFORETIMEOUTEND, Some(false)).unwrap()}
  }
  #[inline]
  pub fn UIBattleHideFromScratch(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GroundExcel::VT_UIBATTLEHIDEFROMSCRATCH, Some(false)).unwrap()}
  }
  #[inline]
  pub fn UIEnemyCount(&self) -> UIEnemyCountType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<UIEnemyCountType>(GroundExcel::VT_UIENEMYCOUNT, Some(UIEnemyCountType::Normal)).unwrap()}
  }
  #[inline]
  pub fn BattleReadyTimelinePath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GroundExcel::VT_BATTLEREADYTIMELINEPATH, None)}
  }
  #[inline]
  pub fn BeforeVictoryTimelinePath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GroundExcel::VT_BEFOREVICTORYTIMELINEPATH, None)}
  }
  #[inline]
  pub fn SkipBattleEnd(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GroundExcel::VT_SKIPBATTLEEND, Some(false)).unwrap()}
  }
  #[inline]
  pub fn HideNPCWhenBattleEnd(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GroundExcel::VT_HIDENPCWHENBATTLEEND, Some(false)).unwrap()}
  }
  #[inline]
  pub fn CoverPointOff(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GroundExcel::VT_COVERPOINTOFF, Some(false)).unwrap()}
  }
  #[inline]
  pub fn UIHpScale(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(GroundExcel::VT_UIHPSCALE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn UIEmojiScale(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(GroundExcel::VT_UIEMOJISCALE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn UISkillMainLogScale(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(GroundExcel::VT_UISKILLMAINLOGSCALE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn EffectCountLimit(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(GroundExcel::VT_EFFECTCOUNTLIMIT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn AllyPassiveSkillId(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(GroundExcel::VT_ALLYPASSIVESKILLID, None)}
  }
  #[inline]
  pub fn AllyPassiveSkillLevel(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(GroundExcel::VT_ALLYPASSIVESKILLLEVEL, None)}
  }
  #[inline]
  pub fn EnemyPassiveSkillId(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(GroundExcel::VT_ENEMYPASSIVESKILLID, None)}
  }
  #[inline]
  pub fn EnemyPassiveSkillLevel(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(GroundExcel::VT_ENEMYPASSIVESKILLLEVEL, None)}
  }
}

impl flatbuffers::Verifiable for GroundExcel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("Id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("StageFileName", Self::VT_STAGEFILENAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("GroundSceneName", Self::VT_GROUNDSCENENAME, false)?
     .visit_field::<i64>("FormationGroupId", Self::VT_FORMATIONGROUPID, false)?
     .visit_field::<StageTopography>("StageTopography", Self::VT_STAGETOPOGRAPHY, false)?
     .visit_field::<BulletType>("EnemyBulletType", Self::VT_ENEMYBULLETTYPE, false)?
     .visit_field::<ArmorType>("EnemyArmorType", Self::VT_ENEMYARMORTYPE, false)?
     .visit_field::<i64>("LevelNPC", Self::VT_LEVELNPC, false)?
     .visit_field::<i64>("LevelMinion", Self::VT_LEVELMINION, false)?
     .visit_field::<i64>("LevelElite", Self::VT_LEVELELITE, false)?
     .visit_field::<i64>("LevelChampion", Self::VT_LEVELCHAMPION, false)?
     .visit_field::<i64>("LevelBoss", Self::VT_LEVELBOSS, false)?
     .visit_field::<i64>("ObstacleLevel", Self::VT_OBSTACLELEVEL, false)?
     .visit_field::<i64>("GradeNPC", Self::VT_GRADENPC, false)?
     .visit_field::<i64>("GradeMinion", Self::VT_GRADEMINION, false)?
     .visit_field::<i64>("GradeElite", Self::VT_GRADEELITE, false)?
     .visit_field::<i64>("GradeChampion", Self::VT_GRADECHAMPION, false)?
     .visit_field::<i64>("GradeBoss", Self::VT_GRADEBOSS, false)?
     .visit_field::<i64>("PlayerSightPointAdd", Self::VT_PLAYERSIGHTPOINTADD, false)?
     .visit_field::<i64>("PlayerSightPointRate", Self::VT_PLAYERSIGHTPOINTRATE, false)?
     .visit_field::<i64>("PlayerAttackRangeAdd", Self::VT_PLAYERATTACKRANGEADD, false)?
     .visit_field::<i64>("PlayerAttackRangeRate", Self::VT_PLAYERATTACKRANGERATE, false)?
     .visit_field::<i64>("EnemySightPointAdd", Self::VT_ENEMYSIGHTPOINTADD, false)?
     .visit_field::<i64>("EnemySightPointRate", Self::VT_ENEMYSIGHTPOINTRATE, false)?
     .visit_field::<i64>("EnemyAttackRangeAdd", Self::VT_ENEMYATTACKRANGEADD, false)?
     .visit_field::<i64>("EnemyAttackRangeRate", Self::VT_ENEMYATTACKRANGERATE, false)?
     .visit_field::<i64>("PlayerSkillRangeAdd", Self::VT_PLAYERSKILLRANGEADD, false)?
     .visit_field::<i64>("PlayerSkillRangeRate", Self::VT_PLAYERSKILLRANGERATE, false)?
     .visit_field::<i64>("EnemySkillRangeAdd", Self::VT_ENEMYSKILLRANGEADD, false)?
     .visit_field::<i64>("EnemySkillRangeRate", Self::VT_ENEMYSKILLRANGERATE, false)?
     .visit_field::<i64>("PlayerMinimumPositionGapRate", Self::VT_PLAYERMINIMUMPOSITIONGAPRATE, false)?
     .visit_field::<i64>("EnemyMinimumPositionGapRate", Self::VT_ENEMYMINIMUMPOSITIONGAPRATE, false)?
     .visit_field::<bool>("PlayerSightRangeMax", Self::VT_PLAYERSIGHTRANGEMAX, false)?
     .visit_field::<bool>("EnemySightRangeMax", Self::VT_ENEMYSIGHTRANGEMAX, false)?
     .visit_field::<i64>("TSSAirUnitHeight", Self::VT_TSSAIRUNITHEIGHT, false)?
     .visit_field::<bool>("IsPhaseBGM", Self::VT_ISPHASEBGM, false)?
     .visit_field::<i64>("BGMId", Self::VT_BGMID, false)?
     .visit_field::<bool>("WarningUI", Self::VT_WARNINGUI, false)?
     .visit_field::<bool>("TSSHatchOpen", Self::VT_TSSHATCHOPEN, false)?
     .visit_field::<TacticSpeed>("ForcedTacticSpeed", Self::VT_FORCEDTACTICSPEED, false)?
     .visit_field::<TacticSkillUse>("ForcedSkillUse", Self::VT_FORCEDSKILLUSE, false)?
     .visit_field::<ShowSkillCutIn>("ShowNPCSkillCutIn", Self::VT_SHOWNPCSKILLCUTIN, false)?
     .visit_field::<bool>("ImmuneHitBeforeTimeOutEnd", Self::VT_IMMUNEHITBEFORETIMEOUTEND, false)?
     .visit_field::<bool>("UIBattleHideFromScratch", Self::VT_UIBATTLEHIDEFROMSCRATCH, false)?
     .visit_field::<UIEnemyCountType>("UIEnemyCount", Self::VT_UIENEMYCOUNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("BattleReadyTimelinePath", Self::VT_BATTLEREADYTIMELINEPATH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("BeforeVictoryTimelinePath", Self::VT_BEFOREVICTORYTIMELINEPATH, false)?
     .visit_field::<bool>("SkipBattleEnd", Self::VT_SKIPBATTLEEND, false)?
     .visit_field::<bool>("HideNPCWhenBattleEnd", Self::VT_HIDENPCWHENBATTLEEND, false)?
     .visit_field::<bool>("CoverPointOff", Self::VT_COVERPOINTOFF, false)?
     .visit_field::<f32>("UIHpScale", Self::VT_UIHPSCALE, false)?
     .visit_field::<f32>("UIEmojiScale", Self::VT_UIEMOJISCALE, false)?
     .visit_field::<f32>("UISkillMainLogScale", Self::VT_UISKILLMAINLOGSCALE, false)?
     .visit_field::<i32>("EffectCountLimit", Self::VT_EFFECTCOUNTLIMIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("AllyPassiveSkillId", Self::VT_ALLYPASSIVESKILLID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("AllyPassiveSkillLevel", Self::VT_ALLYPASSIVESKILLLEVEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("EnemyPassiveSkillId", Self::VT_ENEMYPASSIVESKILLID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("EnemyPassiveSkillLevel", Self::VT_ENEMYPASSIVESKILLLEVEL, false)?
     .finish();
    Ok(())
  }
}
pub struct GroundExcelArgs<'a> {
    pub Id: i64,
    pub StageFileName: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub GroundSceneName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub FormationGroupId: i64,
    pub StageTopography: StageTopography,
    pub EnemyBulletType: BulletType,
    pub EnemyArmorType: ArmorType,
    pub LevelNPC: i64,
    pub LevelMinion: i64,
    pub LevelElite: i64,
    pub LevelChampion: i64,
    pub LevelBoss: i64,
    pub ObstacleLevel: i64,
    pub GradeNPC: i64,
    pub GradeMinion: i64,
    pub GradeElite: i64,
    pub GradeChampion: i64,
    pub GradeBoss: i64,
    pub PlayerSightPointAdd: i64,
    pub PlayerSightPointRate: i64,
    pub PlayerAttackRangeAdd: i64,
    pub PlayerAttackRangeRate: i64,
    pub EnemySightPointAdd: i64,
    pub EnemySightPointRate: i64,
    pub EnemyAttackRangeAdd: i64,
    pub EnemyAttackRangeRate: i64,
    pub PlayerSkillRangeAdd: i64,
    pub PlayerSkillRangeRate: i64,
    pub EnemySkillRangeAdd: i64,
    pub EnemySkillRangeRate: i64,
    pub PlayerMinimumPositionGapRate: i64,
    pub EnemyMinimumPositionGapRate: i64,
    pub PlayerSightRangeMax: bool,
    pub EnemySightRangeMax: bool,
    pub TSSAirUnitHeight: i64,
    pub IsPhaseBGM: bool,
    pub BGMId: i64,
    pub WarningUI: bool,
    pub TSSHatchOpen: bool,
    pub ForcedTacticSpeed: TacticSpeed,
    pub ForcedSkillUse: TacticSkillUse,
    pub ShowNPCSkillCutIn: ShowSkillCutIn,
    pub ImmuneHitBeforeTimeOutEnd: bool,
    pub UIBattleHideFromScratch: bool,
    pub UIEnemyCount: UIEnemyCountType,
    pub BattleReadyTimelinePath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub BeforeVictoryTimelinePath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SkipBattleEnd: bool,
    pub HideNPCWhenBattleEnd: bool,
    pub CoverPointOff: bool,
    pub UIHpScale: f32,
    pub UIEmojiScale: f32,
    pub UISkillMainLogScale: f32,
    pub EffectCountLimit: i32,
    pub AllyPassiveSkillId: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub AllyPassiveSkillLevel: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub EnemyPassiveSkillId: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub EnemyPassiveSkillLevel: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for GroundExcelArgs<'a> {
  #[inline]
  fn default() -> Self {
    GroundExcelArgs {
      Id: 0,
      StageFileName: None,
      GroundSceneName: None,
      FormationGroupId: 0,
      StageTopography: StageTopography::Street,
      EnemyBulletType: BulletType::Normal,
      EnemyArmorType: ArmorType::LightArmor,
      LevelNPC: 0,
      LevelMinion: 0,
      LevelElite: 0,
      LevelChampion: 0,
      LevelBoss: 0,
      ObstacleLevel: 0,
      GradeNPC: 0,
      GradeMinion: 0,
      GradeElite: 0,
      GradeChampion: 0,
      GradeBoss: 0,
      PlayerSightPointAdd: 0,
      PlayerSightPointRate: 0,
      PlayerAttackRangeAdd: 0,
      PlayerAttackRangeRate: 0,
      EnemySightPointAdd: 0,
      EnemySightPointRate: 0,
      EnemyAttackRangeAdd: 0,
      EnemyAttackRangeRate: 0,
      PlayerSkillRangeAdd: 0,
      PlayerSkillRangeRate: 0,
      EnemySkillRangeAdd: 0,
      EnemySkillRangeRate: 0,
      PlayerMinimumPositionGapRate: 0,
      EnemyMinimumPositionGapRate: 0,
      PlayerSightRangeMax: false,
      EnemySightRangeMax: false,
      TSSAirUnitHeight: 0,
      IsPhaseBGM: false,
      BGMId: 0,
      WarningUI: false,
      TSSHatchOpen: false,
      ForcedTacticSpeed: TacticSpeed::None,
      ForcedSkillUse: TacticSkillUse::None,
      ShowNPCSkillCutIn: ShowSkillCutIn::None,
      ImmuneHitBeforeTimeOutEnd: false,
      UIBattleHideFromScratch: false,
      UIEnemyCount: UIEnemyCountType::Normal,
      BattleReadyTimelinePath: None,
      BeforeVictoryTimelinePath: None,
      SkipBattleEnd: false,
      HideNPCWhenBattleEnd: false,
      CoverPointOff: false,
      UIHpScale: 0.0,
      UIEmojiScale: 0.0,
      UISkillMainLogScale: 0.0,
      EffectCountLimit: 0,
      AllyPassiveSkillId: None,
      AllyPassiveSkillLevel: None,
      EnemyPassiveSkillId: None,
      EnemyPassiveSkillLevel: None,
    }
  }
}

impl Serialize for GroundExcel<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("GroundExcel", 58)?;
      s.serialize_field("Id", &self.Id())?;
      if let Some(f) = self.StageFileName() {
        s.serialize_field("StageFileName", &f)?;
      } else {
        s.skip_field("StageFileName")?;
      }
      if let Some(f) = self.GroundSceneName() {
        s.serialize_field("GroundSceneName", &f)?;
      } else {
        s.skip_field("GroundSceneName")?;
      }
      s.serialize_field("FormationGroupId", &self.FormationGroupId())?;
      s.serialize_field("StageTopography", &self.StageTopography())?;
      s.serialize_field("EnemyBulletType", &self.EnemyBulletType())?;
      s.serialize_field("EnemyArmorType", &self.EnemyArmorType())?;
      s.serialize_field("LevelNPC", &self.LevelNPC())?;
      s.serialize_field("LevelMinion", &self.LevelMinion())?;
      s.serialize_field("LevelElite", &self.LevelElite())?;
      s.serialize_field("LevelChampion", &self.LevelChampion())?;
      s.serialize_field("LevelBoss", &self.LevelBoss())?;
      s.serialize_field("ObstacleLevel", &self.ObstacleLevel())?;
      s.serialize_field("GradeNPC", &self.GradeNPC())?;
      s.serialize_field("GradeMinion", &self.GradeMinion())?;
      s.serialize_field("GradeElite", &self.GradeElite())?;
      s.serialize_field("GradeChampion", &self.GradeChampion())?;
      s.serialize_field("GradeBoss", &self.GradeBoss())?;
      s.serialize_field("PlayerSightPointAdd", &self.PlayerSightPointAdd())?;
      s.serialize_field("PlayerSightPointRate", &self.PlayerSightPointRate())?;
      s.serialize_field("PlayerAttackRangeAdd", &self.PlayerAttackRangeAdd())?;
      s.serialize_field("PlayerAttackRangeRate", &self.PlayerAttackRangeRate())?;
      s.serialize_field("EnemySightPointAdd", &self.EnemySightPointAdd())?;
      s.serialize_field("EnemySightPointRate", &self.EnemySightPointRate())?;
      s.serialize_field("EnemyAttackRangeAdd", &self.EnemyAttackRangeAdd())?;
      s.serialize_field("EnemyAttackRangeRate", &self.EnemyAttackRangeRate())?;
      s.serialize_field("PlayerSkillRangeAdd", &self.PlayerSkillRangeAdd())?;
      s.serialize_field("PlayerSkillRangeRate", &self.PlayerSkillRangeRate())?;
      s.serialize_field("EnemySkillRangeAdd", &self.EnemySkillRangeAdd())?;
      s.serialize_field("EnemySkillRangeRate", &self.EnemySkillRangeRate())?;
      s.serialize_field("PlayerMinimumPositionGapRate", &self.PlayerMinimumPositionGapRate())?;
      s.serialize_field("EnemyMinimumPositionGapRate", &self.EnemyMinimumPositionGapRate())?;
      s.serialize_field("PlayerSightRangeMax", &self.PlayerSightRangeMax())?;
      s.serialize_field("EnemySightRangeMax", &self.EnemySightRangeMax())?;
      s.serialize_field("TSSAirUnitHeight", &self.TSSAirUnitHeight())?;
      s.serialize_field("IsPhaseBGM", &self.IsPhaseBGM())?;
      s.serialize_field("BGMId", &self.BGMId())?;
      s.serialize_field("WarningUI", &self.WarningUI())?;
      s.serialize_field("TSSHatchOpen", &self.TSSHatchOpen())?;
      s.serialize_field("ForcedTacticSpeed", &self.ForcedTacticSpeed())?;
      s.serialize_field("ForcedSkillUse", &self.ForcedSkillUse())?;
      s.serialize_field("ShowNPCSkillCutIn", &self.ShowNPCSkillCutIn())?;
      s.serialize_field("ImmuneHitBeforeTimeOutEnd", &self.ImmuneHitBeforeTimeOutEnd())?;
      s.serialize_field("UIBattleHideFromScratch", &self.UIBattleHideFromScratch())?;
      s.serialize_field("UIEnemyCount", &self.UIEnemyCount())?;
      if let Some(f) = self.BattleReadyTimelinePath() {
        s.serialize_field("BattleReadyTimelinePath", &f)?;
      } else {
        s.skip_field("BattleReadyTimelinePath")?;
      }
      if let Some(f) = self.BeforeVictoryTimelinePath() {
        s.serialize_field("BeforeVictoryTimelinePath", &f)?;
      } else {
        s.skip_field("BeforeVictoryTimelinePath")?;
      }
      s.serialize_field("SkipBattleEnd", &self.SkipBattleEnd())?;
      s.serialize_field("HideNPCWhenBattleEnd", &self.HideNPCWhenBattleEnd())?;
      s.serialize_field("CoverPointOff", &self.CoverPointOff())?;
      s.serialize_field("UIHpScale", &self.UIHpScale())?;
      s.serialize_field("UIEmojiScale", &self.UIEmojiScale())?;
      s.serialize_field("UISkillMainLogScale", &self.UISkillMainLogScale())?;
      s.serialize_field("EffectCountLimit", &self.EffectCountLimit())?;
      if let Some(f) = self.AllyPassiveSkillId() {
        s.serialize_field("AllyPassiveSkillId", &f)?;
      } else {
        s.skip_field("AllyPassiveSkillId")?;
      }
      if let Some(f) = self.AllyPassiveSkillLevel() {
        s.serialize_field("AllyPassiveSkillLevel", &f)?;
      } else {
        s.skip_field("AllyPassiveSkillLevel")?;
      }
      if let Some(f) = self.EnemyPassiveSkillId() {
        s.serialize_field("EnemyPassiveSkillId", &f)?;
      } else {
        s.skip_field("EnemyPassiveSkillId")?;
      }
      if let Some(f) = self.EnemyPassiveSkillLevel() {
        s.serialize_field("EnemyPassiveSkillLevel", &f)?;
      } else {
        s.skip_field("EnemyPassiveSkillLevel")?;
      }
    s.end()
  }
}

pub struct GroundExcelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GroundExcelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_Id(&mut self, Id: i64) {
    self.fbb_.push_slot::<i64>(GroundExcel::VT_ID, Id, 0);
  }
  #[inline]
  pub fn add_StageFileName(&mut self, StageFileName: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GroundExcel::VT_STAGEFILENAME, StageFileName);
  }
  #[inline]
  pub fn add_GroundSceneName(&mut self, GroundSceneName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GroundExcel::VT_GROUNDSCENENAME, GroundSceneName);
  }
  #[inline]
  pub fn add_FormationGroupId(&mut self, FormationGroupId: i64) {
    self.fbb_.push_slot::<i64>(GroundExcel::VT_FORMATIONGROUPID, FormationGroupId, 0);
  }
  #[inline]
  pub fn add_StageTopography(&mut self, StageTopography: StageTopography) {
    self.fbb_.push_slot::<StageTopography>(GroundExcel::VT_STAGETOPOGRAPHY, StageTopography, StageTopography::Street);
  }
  #[inline]
  pub fn add_EnemyBulletType(&mut self, EnemyBulletType: BulletType) {
    self.fbb_.push_slot::<BulletType>(GroundExcel::VT_ENEMYBULLETTYPE, EnemyBulletType, BulletType::Normal);
  }
  #[inline]
  pub fn add_EnemyArmorType(&mut self, EnemyArmorType: ArmorType) {
    self.fbb_.push_slot::<ArmorType>(GroundExcel::VT_ENEMYARMORTYPE, EnemyArmorType, ArmorType::LightArmor);
  }
  #[inline]
  pub fn add_LevelNPC(&mut self, LevelNPC: i64) {
    self.fbb_.push_slot::<i64>(GroundExcel::VT_LEVELNPC, LevelNPC, 0);
  }
  #[inline]
  pub fn add_LevelMinion(&mut self, LevelMinion: i64) {
    self.fbb_.push_slot::<i64>(GroundExcel::VT_LEVELMINION, LevelMinion, 0);
  }
  #[inline]
  pub fn add_LevelElite(&mut self, LevelElite: i64) {
    self.fbb_.push_slot::<i64>(GroundExcel::VT_LEVELELITE, LevelElite, 0);
  }
  #[inline]
  pub fn add_LevelChampion(&mut self, LevelChampion: i64) {
    self.fbb_.push_slot::<i64>(GroundExcel::VT_LEVELCHAMPION, LevelChampion, 0);
  }
  #[inline]
  pub fn add_LevelBoss(&mut self, LevelBoss: i64) {
    self.fbb_.push_slot::<i64>(GroundExcel::VT_LEVELBOSS, LevelBoss, 0);
  }
  #[inline]
  pub fn add_ObstacleLevel(&mut self, ObstacleLevel: i64) {
    self.fbb_.push_slot::<i64>(GroundExcel::VT_OBSTACLELEVEL, ObstacleLevel, 0);
  }
  #[inline]
  pub fn add_GradeNPC(&mut self, GradeNPC: i64) {
    self.fbb_.push_slot::<i64>(GroundExcel::VT_GRADENPC, GradeNPC, 0);
  }
  #[inline]
  pub fn add_GradeMinion(&mut self, GradeMinion: i64) {
    self.fbb_.push_slot::<i64>(GroundExcel::VT_GRADEMINION, GradeMinion, 0);
  }
  #[inline]
  pub fn add_GradeElite(&mut self, GradeElite: i64) {
    self.fbb_.push_slot::<i64>(GroundExcel::VT_GRADEELITE, GradeElite, 0);
  }
  #[inline]
  pub fn add_GradeChampion(&mut self, GradeChampion: i64) {
    self.fbb_.push_slot::<i64>(GroundExcel::VT_GRADECHAMPION, GradeChampion, 0);
  }
  #[inline]
  pub fn add_GradeBoss(&mut self, GradeBoss: i64) {
    self.fbb_.push_slot::<i64>(GroundExcel::VT_GRADEBOSS, GradeBoss, 0);
  }
  #[inline]
  pub fn add_PlayerSightPointAdd(&mut self, PlayerSightPointAdd: i64) {
    self.fbb_.push_slot::<i64>(GroundExcel::VT_PLAYERSIGHTPOINTADD, PlayerSightPointAdd, 0);
  }
  #[inline]
  pub fn add_PlayerSightPointRate(&mut self, PlayerSightPointRate: i64) {
    self.fbb_.push_slot::<i64>(GroundExcel::VT_PLAYERSIGHTPOINTRATE, PlayerSightPointRate, 0);
  }
  #[inline]
  pub fn add_PlayerAttackRangeAdd(&mut self, PlayerAttackRangeAdd: i64) {
    self.fbb_.push_slot::<i64>(GroundExcel::VT_PLAYERATTACKRANGEADD, PlayerAttackRangeAdd, 0);
  }
  #[inline]
  pub fn add_PlayerAttackRangeRate(&mut self, PlayerAttackRangeRate: i64) {
    self.fbb_.push_slot::<i64>(GroundExcel::VT_PLAYERATTACKRANGERATE, PlayerAttackRangeRate, 0);
  }
  #[inline]
  pub fn add_EnemySightPointAdd(&mut self, EnemySightPointAdd: i64) {
    self.fbb_.push_slot::<i64>(GroundExcel::VT_ENEMYSIGHTPOINTADD, EnemySightPointAdd, 0);
  }
  #[inline]
  pub fn add_EnemySightPointRate(&mut self, EnemySightPointRate: i64) {
    self.fbb_.push_slot::<i64>(GroundExcel::VT_ENEMYSIGHTPOINTRATE, EnemySightPointRate, 0);
  }
  #[inline]
  pub fn add_EnemyAttackRangeAdd(&mut self, EnemyAttackRangeAdd: i64) {
    self.fbb_.push_slot::<i64>(GroundExcel::VT_ENEMYATTACKRANGEADD, EnemyAttackRangeAdd, 0);
  }
  #[inline]
  pub fn add_EnemyAttackRangeRate(&mut self, EnemyAttackRangeRate: i64) {
    self.fbb_.push_slot::<i64>(GroundExcel::VT_ENEMYATTACKRANGERATE, EnemyAttackRangeRate, 0);
  }
  #[inline]
  pub fn add_PlayerSkillRangeAdd(&mut self, PlayerSkillRangeAdd: i64) {
    self.fbb_.push_slot::<i64>(GroundExcel::VT_PLAYERSKILLRANGEADD, PlayerSkillRangeAdd, 0);
  }
  #[inline]
  pub fn add_PlayerSkillRangeRate(&mut self, PlayerSkillRangeRate: i64) {
    self.fbb_.push_slot::<i64>(GroundExcel::VT_PLAYERSKILLRANGERATE, PlayerSkillRangeRate, 0);
  }
  #[inline]
  pub fn add_EnemySkillRangeAdd(&mut self, EnemySkillRangeAdd: i64) {
    self.fbb_.push_slot::<i64>(GroundExcel::VT_ENEMYSKILLRANGEADD, EnemySkillRangeAdd, 0);
  }
  #[inline]
  pub fn add_EnemySkillRangeRate(&mut self, EnemySkillRangeRate: i64) {
    self.fbb_.push_slot::<i64>(GroundExcel::VT_ENEMYSKILLRANGERATE, EnemySkillRangeRate, 0);
  }
  #[inline]
  pub fn add_PlayerMinimumPositionGapRate(&mut self, PlayerMinimumPositionGapRate: i64) {
    self.fbb_.push_slot::<i64>(GroundExcel::VT_PLAYERMINIMUMPOSITIONGAPRATE, PlayerMinimumPositionGapRate, 0);
  }
  #[inline]
  pub fn add_EnemyMinimumPositionGapRate(&mut self, EnemyMinimumPositionGapRate: i64) {
    self.fbb_.push_slot::<i64>(GroundExcel::VT_ENEMYMINIMUMPOSITIONGAPRATE, EnemyMinimumPositionGapRate, 0);
  }
  #[inline]
  pub fn add_PlayerSightRangeMax(&mut self, PlayerSightRangeMax: bool) {
    self.fbb_.push_slot::<bool>(GroundExcel::VT_PLAYERSIGHTRANGEMAX, PlayerSightRangeMax, false);
  }
  #[inline]
  pub fn add_EnemySightRangeMax(&mut self, EnemySightRangeMax: bool) {
    self.fbb_.push_slot::<bool>(GroundExcel::VT_ENEMYSIGHTRANGEMAX, EnemySightRangeMax, false);
  }
  #[inline]
  pub fn add_TSSAirUnitHeight(&mut self, TSSAirUnitHeight: i64) {
    self.fbb_.push_slot::<i64>(GroundExcel::VT_TSSAIRUNITHEIGHT, TSSAirUnitHeight, 0);
  }
  #[inline]
  pub fn add_IsPhaseBGM(&mut self, IsPhaseBGM: bool) {
    self.fbb_.push_slot::<bool>(GroundExcel::VT_ISPHASEBGM, IsPhaseBGM, false);
  }
  #[inline]
  pub fn add_BGMId(&mut self, BGMId: i64) {
    self.fbb_.push_slot::<i64>(GroundExcel::VT_BGMID, BGMId, 0);
  }
  #[inline]
  pub fn add_WarningUI(&mut self, WarningUI: bool) {
    self.fbb_.push_slot::<bool>(GroundExcel::VT_WARNINGUI, WarningUI, false);
  }
  #[inline]
  pub fn add_TSSHatchOpen(&mut self, TSSHatchOpen: bool) {
    self.fbb_.push_slot::<bool>(GroundExcel::VT_TSSHATCHOPEN, TSSHatchOpen, false);
  }
  #[inline]
  pub fn add_ForcedTacticSpeed(&mut self, ForcedTacticSpeed: TacticSpeed) {
    self.fbb_.push_slot::<TacticSpeed>(GroundExcel::VT_FORCEDTACTICSPEED, ForcedTacticSpeed, TacticSpeed::None);
  }
  #[inline]
  pub fn add_ForcedSkillUse(&mut self, ForcedSkillUse: TacticSkillUse) {
    self.fbb_.push_slot::<TacticSkillUse>(GroundExcel::VT_FORCEDSKILLUSE, ForcedSkillUse, TacticSkillUse::None);
  }
  #[inline]
  pub fn add_ShowNPCSkillCutIn(&mut self, ShowNPCSkillCutIn: ShowSkillCutIn) {
    self.fbb_.push_slot::<ShowSkillCutIn>(GroundExcel::VT_SHOWNPCSKILLCUTIN, ShowNPCSkillCutIn, ShowSkillCutIn::None);
  }
  #[inline]
  pub fn add_ImmuneHitBeforeTimeOutEnd(&mut self, ImmuneHitBeforeTimeOutEnd: bool) {
    self.fbb_.push_slot::<bool>(GroundExcel::VT_IMMUNEHITBEFORETIMEOUTEND, ImmuneHitBeforeTimeOutEnd, false);
  }
  #[inline]
  pub fn add_UIBattleHideFromScratch(&mut self, UIBattleHideFromScratch: bool) {
    self.fbb_.push_slot::<bool>(GroundExcel::VT_UIBATTLEHIDEFROMSCRATCH, UIBattleHideFromScratch, false);
  }
  #[inline]
  pub fn add_UIEnemyCount(&mut self, UIEnemyCount: UIEnemyCountType) {
    self.fbb_.push_slot::<UIEnemyCountType>(GroundExcel::VT_UIENEMYCOUNT, UIEnemyCount, UIEnemyCountType::Normal);
  }
  #[inline]
  pub fn add_BattleReadyTimelinePath(&mut self, BattleReadyTimelinePath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GroundExcel::VT_BATTLEREADYTIMELINEPATH, BattleReadyTimelinePath);
  }
  #[inline]
  pub fn add_BeforeVictoryTimelinePath(&mut self, BeforeVictoryTimelinePath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GroundExcel::VT_BEFOREVICTORYTIMELINEPATH, BeforeVictoryTimelinePath);
  }
  #[inline]
  pub fn add_SkipBattleEnd(&mut self, SkipBattleEnd: bool) {
    self.fbb_.push_slot::<bool>(GroundExcel::VT_SKIPBATTLEEND, SkipBattleEnd, false);
  }
  #[inline]
  pub fn add_HideNPCWhenBattleEnd(&mut self, HideNPCWhenBattleEnd: bool) {
    self.fbb_.push_slot::<bool>(GroundExcel::VT_HIDENPCWHENBATTLEEND, HideNPCWhenBattleEnd, false);
  }
  #[inline]
  pub fn add_CoverPointOff(&mut self, CoverPointOff: bool) {
    self.fbb_.push_slot::<bool>(GroundExcel::VT_COVERPOINTOFF, CoverPointOff, false);
  }
  #[inline]
  pub fn add_UIHpScale(&mut self, UIHpScale: f32) {
    self.fbb_.push_slot::<f32>(GroundExcel::VT_UIHPSCALE, UIHpScale, 0.0);
  }
  #[inline]
  pub fn add_UIEmojiScale(&mut self, UIEmojiScale: f32) {
    self.fbb_.push_slot::<f32>(GroundExcel::VT_UIEMOJISCALE, UIEmojiScale, 0.0);
  }
  #[inline]
  pub fn add_UISkillMainLogScale(&mut self, UISkillMainLogScale: f32) {
    self.fbb_.push_slot::<f32>(GroundExcel::VT_UISKILLMAINLOGSCALE, UISkillMainLogScale, 0.0);
  }
  #[inline]
  pub fn add_EffectCountLimit(&mut self, EffectCountLimit: i32) {
    self.fbb_.push_slot::<i32>(GroundExcel::VT_EFFECTCOUNTLIMIT, EffectCountLimit, 0);
  }
  #[inline]
  pub fn add_AllyPassiveSkillId(&mut self, AllyPassiveSkillId: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GroundExcel::VT_ALLYPASSIVESKILLID, AllyPassiveSkillId);
  }
  #[inline]
  pub fn add_AllyPassiveSkillLevel(&mut self, AllyPassiveSkillLevel: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GroundExcel::VT_ALLYPASSIVESKILLLEVEL, AllyPassiveSkillLevel);
  }
  #[inline]
  pub fn add_EnemyPassiveSkillId(&mut self, EnemyPassiveSkillId: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GroundExcel::VT_ENEMYPASSIVESKILLID, EnemyPassiveSkillId);
  }
  #[inline]
  pub fn add_EnemyPassiveSkillLevel(&mut self, EnemyPassiveSkillLevel: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GroundExcel::VT_ENEMYPASSIVESKILLLEVEL, EnemyPassiveSkillLevel);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GroundExcelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GroundExcelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GroundExcel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GroundExcel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GroundExcel");
      ds.field("Id", &self.Id());
      ds.field("StageFileName", &self.StageFileName());
      ds.field("GroundSceneName", &self.GroundSceneName());
      ds.field("FormationGroupId", &self.FormationGroupId());
      ds.field("StageTopography", &self.StageTopography());
      ds.field("EnemyBulletType", &self.EnemyBulletType());
      ds.field("EnemyArmorType", &self.EnemyArmorType());
      ds.field("LevelNPC", &self.LevelNPC());
      ds.field("LevelMinion", &self.LevelMinion());
      ds.field("LevelElite", &self.LevelElite());
      ds.field("LevelChampion", &self.LevelChampion());
      ds.field("LevelBoss", &self.LevelBoss());
      ds.field("ObstacleLevel", &self.ObstacleLevel());
      ds.field("GradeNPC", &self.GradeNPC());
      ds.field("GradeMinion", &self.GradeMinion());
      ds.field("GradeElite", &self.GradeElite());
      ds.field("GradeChampion", &self.GradeChampion());
      ds.field("GradeBoss", &self.GradeBoss());
      ds.field("PlayerSightPointAdd", &self.PlayerSightPointAdd());
      ds.field("PlayerSightPointRate", &self.PlayerSightPointRate());
      ds.field("PlayerAttackRangeAdd", &self.PlayerAttackRangeAdd());
      ds.field("PlayerAttackRangeRate", &self.PlayerAttackRangeRate());
      ds.field("EnemySightPointAdd", &self.EnemySightPointAdd());
      ds.field("EnemySightPointRate", &self.EnemySightPointRate());
      ds.field("EnemyAttackRangeAdd", &self.EnemyAttackRangeAdd());
      ds.field("EnemyAttackRangeRate", &self.EnemyAttackRangeRate());
      ds.field("PlayerSkillRangeAdd", &self.PlayerSkillRangeAdd());
      ds.field("PlayerSkillRangeRate", &self.PlayerSkillRangeRate());
      ds.field("EnemySkillRangeAdd", &self.EnemySkillRangeAdd());
      ds.field("EnemySkillRangeRate", &self.EnemySkillRangeRate());
      ds.field("PlayerMinimumPositionGapRate", &self.PlayerMinimumPositionGapRate());
      ds.field("EnemyMinimumPositionGapRate", &self.EnemyMinimumPositionGapRate());
      ds.field("PlayerSightRangeMax", &self.PlayerSightRangeMax());
      ds.field("EnemySightRangeMax", &self.EnemySightRangeMax());
      ds.field("TSSAirUnitHeight", &self.TSSAirUnitHeight());
      ds.field("IsPhaseBGM", &self.IsPhaseBGM());
      ds.field("BGMId", &self.BGMId());
      ds.field("WarningUI", &self.WarningUI());
      ds.field("TSSHatchOpen", &self.TSSHatchOpen());
      ds.field("ForcedTacticSpeed", &self.ForcedTacticSpeed());
      ds.field("ForcedSkillUse", &self.ForcedSkillUse());
      ds.field("ShowNPCSkillCutIn", &self.ShowNPCSkillCutIn());
      ds.field("ImmuneHitBeforeTimeOutEnd", &self.ImmuneHitBeforeTimeOutEnd());
      ds.field("UIBattleHideFromScratch", &self.UIBattleHideFromScratch());
      ds.field("UIEnemyCount", &self.UIEnemyCount());
      ds.field("BattleReadyTimelinePath", &self.BattleReadyTimelinePath());
      ds.field("BeforeVictoryTimelinePath", &self.BeforeVictoryTimelinePath());
      ds.field("SkipBattleEnd", &self.SkipBattleEnd());
      ds.field("HideNPCWhenBattleEnd", &self.HideNPCWhenBattleEnd());
      ds.field("CoverPointOff", &self.CoverPointOff());
      ds.field("UIHpScale", &self.UIHpScale());
      ds.field("UIEmojiScale", &self.UIEmojiScale());
      ds.field("UISkillMainLogScale", &self.UISkillMainLogScale());
      ds.field("EffectCountLimit", &self.EffectCountLimit());
      ds.field("AllyPassiveSkillId", &self.AllyPassiveSkillId());
      ds.field("AllyPassiveSkillLevel", &self.AllyPassiveSkillLevel());
      ds.field("EnemyPassiveSkillId", &self.EnemyPassiveSkillId());
      ds.field("EnemyPassiveSkillLevel", &self.EnemyPassiveSkillLevel());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GroundExcelT {
  pub Id: i64,
  pub StageFileName: Option<Vec<String>>,
  pub GroundSceneName: Option<String>,
  pub FormationGroupId: i64,
  pub StageTopography: StageTopography,
  pub EnemyBulletType: BulletType,
  pub EnemyArmorType: ArmorType,
  pub LevelNPC: i64,
  pub LevelMinion: i64,
  pub LevelElite: i64,
  pub LevelChampion: i64,
  pub LevelBoss: i64,
  pub ObstacleLevel: i64,
  pub GradeNPC: i64,
  pub GradeMinion: i64,
  pub GradeElite: i64,
  pub GradeChampion: i64,
  pub GradeBoss: i64,
  pub PlayerSightPointAdd: i64,
  pub PlayerSightPointRate: i64,
  pub PlayerAttackRangeAdd: i64,
  pub PlayerAttackRangeRate: i64,
  pub EnemySightPointAdd: i64,
  pub EnemySightPointRate: i64,
  pub EnemyAttackRangeAdd: i64,
  pub EnemyAttackRangeRate: i64,
  pub PlayerSkillRangeAdd: i64,
  pub PlayerSkillRangeRate: i64,
  pub EnemySkillRangeAdd: i64,
  pub EnemySkillRangeRate: i64,
  pub PlayerMinimumPositionGapRate: i64,
  pub EnemyMinimumPositionGapRate: i64,
  pub PlayerSightRangeMax: bool,
  pub EnemySightRangeMax: bool,
  pub TSSAirUnitHeight: i64,
  pub IsPhaseBGM: bool,
  pub BGMId: i64,
  pub WarningUI: bool,
  pub TSSHatchOpen: bool,
  pub ForcedTacticSpeed: TacticSpeed,
  pub ForcedSkillUse: TacticSkillUse,
  pub ShowNPCSkillCutIn: ShowSkillCutIn,
  pub ImmuneHitBeforeTimeOutEnd: bool,
  pub UIBattleHideFromScratch: bool,
  pub UIEnemyCount: UIEnemyCountType,
  pub BattleReadyTimelinePath: Option<String>,
  pub BeforeVictoryTimelinePath: Option<String>,
  pub SkipBattleEnd: bool,
  pub HideNPCWhenBattleEnd: bool,
  pub CoverPointOff: bool,
  pub UIHpScale: f32,
  pub UIEmojiScale: f32,
  pub UISkillMainLogScale: f32,
  pub EffectCountLimit: i32,
  pub AllyPassiveSkillId: Option<Vec<String>>,
  pub AllyPassiveSkillLevel: Option<Vec<i32>>,
  pub EnemyPassiveSkillId: Option<Vec<String>>,
  pub EnemyPassiveSkillLevel: Option<Vec<i32>>,
}
impl Default for GroundExcelT {
  fn default() -> Self {
    Self {
      Id: 0,
      StageFileName: None,
      GroundSceneName: None,
      FormationGroupId: 0,
      StageTopography: StageTopography::Street,
      EnemyBulletType: BulletType::Normal,
      EnemyArmorType: ArmorType::LightArmor,
      LevelNPC: 0,
      LevelMinion: 0,
      LevelElite: 0,
      LevelChampion: 0,
      LevelBoss: 0,
      ObstacleLevel: 0,
      GradeNPC: 0,
      GradeMinion: 0,
      GradeElite: 0,
      GradeChampion: 0,
      GradeBoss: 0,
      PlayerSightPointAdd: 0,
      PlayerSightPointRate: 0,
      PlayerAttackRangeAdd: 0,
      PlayerAttackRangeRate: 0,
      EnemySightPointAdd: 0,
      EnemySightPointRate: 0,
      EnemyAttackRangeAdd: 0,
      EnemyAttackRangeRate: 0,
      PlayerSkillRangeAdd: 0,
      PlayerSkillRangeRate: 0,
      EnemySkillRangeAdd: 0,
      EnemySkillRangeRate: 0,
      PlayerMinimumPositionGapRate: 0,
      EnemyMinimumPositionGapRate: 0,
      PlayerSightRangeMax: false,
      EnemySightRangeMax: false,
      TSSAirUnitHeight: 0,
      IsPhaseBGM: false,
      BGMId: 0,
      WarningUI: false,
      TSSHatchOpen: false,
      ForcedTacticSpeed: TacticSpeed::None,
      ForcedSkillUse: TacticSkillUse::None,
      ShowNPCSkillCutIn: ShowSkillCutIn::None,
      ImmuneHitBeforeTimeOutEnd: false,
      UIBattleHideFromScratch: false,
      UIEnemyCount: UIEnemyCountType::Normal,
      BattleReadyTimelinePath: None,
      BeforeVictoryTimelinePath: None,
      SkipBattleEnd: false,
      HideNPCWhenBattleEnd: false,
      CoverPointOff: false,
      UIHpScale: 0.0,
      UIEmojiScale: 0.0,
      UISkillMainLogScale: 0.0,
      EffectCountLimit: 0,
      AllyPassiveSkillId: None,
      AllyPassiveSkillLevel: None,
      EnemyPassiveSkillId: None,
      EnemyPassiveSkillLevel: None,
    }
  }
}
impl GroundExcelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<GroundExcel<'b>> {
    let Id = self.Id;
    let StageFileName = self.StageFileName.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let GroundSceneName = self.GroundSceneName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let FormationGroupId = self.FormationGroupId;
    let StageTopography = self.StageTopography;
    let EnemyBulletType = self.EnemyBulletType;
    let EnemyArmorType = self.EnemyArmorType;
    let LevelNPC = self.LevelNPC;
    let LevelMinion = self.LevelMinion;
    let LevelElite = self.LevelElite;
    let LevelChampion = self.LevelChampion;
    let LevelBoss = self.LevelBoss;
    let ObstacleLevel = self.ObstacleLevel;
    let GradeNPC = self.GradeNPC;
    let GradeMinion = self.GradeMinion;
    let GradeElite = self.GradeElite;
    let GradeChampion = self.GradeChampion;
    let GradeBoss = self.GradeBoss;
    let PlayerSightPointAdd = self.PlayerSightPointAdd;
    let PlayerSightPointRate = self.PlayerSightPointRate;
    let PlayerAttackRangeAdd = self.PlayerAttackRangeAdd;
    let PlayerAttackRangeRate = self.PlayerAttackRangeRate;
    let EnemySightPointAdd = self.EnemySightPointAdd;
    let EnemySightPointRate = self.EnemySightPointRate;
    let EnemyAttackRangeAdd = self.EnemyAttackRangeAdd;
    let EnemyAttackRangeRate = self.EnemyAttackRangeRate;
    let PlayerSkillRangeAdd = self.PlayerSkillRangeAdd;
    let PlayerSkillRangeRate = self.PlayerSkillRangeRate;
    let EnemySkillRangeAdd = self.EnemySkillRangeAdd;
    let EnemySkillRangeRate = self.EnemySkillRangeRate;
    let PlayerMinimumPositionGapRate = self.PlayerMinimumPositionGapRate;
    let EnemyMinimumPositionGapRate = self.EnemyMinimumPositionGapRate;
    let PlayerSightRangeMax = self.PlayerSightRangeMax;
    let EnemySightRangeMax = self.EnemySightRangeMax;
    let TSSAirUnitHeight = self.TSSAirUnitHeight;
    let IsPhaseBGM = self.IsPhaseBGM;
    let BGMId = self.BGMId;
    let WarningUI = self.WarningUI;
    let TSSHatchOpen = self.TSSHatchOpen;
    let ForcedTacticSpeed = self.ForcedTacticSpeed;
    let ForcedSkillUse = self.ForcedSkillUse;
    let ShowNPCSkillCutIn = self.ShowNPCSkillCutIn;
    let ImmuneHitBeforeTimeOutEnd = self.ImmuneHitBeforeTimeOutEnd;
    let UIBattleHideFromScratch = self.UIBattleHideFromScratch;
    let UIEnemyCount = self.UIEnemyCount;
    let BattleReadyTimelinePath = self.BattleReadyTimelinePath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let BeforeVictoryTimelinePath = self.BeforeVictoryTimelinePath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SkipBattleEnd = self.SkipBattleEnd;
    let HideNPCWhenBattleEnd = self.HideNPCWhenBattleEnd;
    let CoverPointOff = self.CoverPointOff;
    let UIHpScale = self.UIHpScale;
    let UIEmojiScale = self.UIEmojiScale;
    let UISkillMainLogScale = self.UISkillMainLogScale;
    let EffectCountLimit = self.EffectCountLimit;
    let AllyPassiveSkillId = self.AllyPassiveSkillId.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let AllyPassiveSkillLevel = self.AllyPassiveSkillLevel.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let EnemyPassiveSkillId = self.EnemyPassiveSkillId.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let EnemyPassiveSkillLevel = self.EnemyPassiveSkillLevel.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    GroundExcel::create(_fbb, &GroundExcelArgs{
      Id,
      StageFileName,
      GroundSceneName,
      FormationGroupId,
      StageTopography,
      EnemyBulletType,
      EnemyArmorType,
      LevelNPC,
      LevelMinion,
      LevelElite,
      LevelChampion,
      LevelBoss,
      ObstacleLevel,
      GradeNPC,
      GradeMinion,
      GradeElite,
      GradeChampion,
      GradeBoss,
      PlayerSightPointAdd,
      PlayerSightPointRate,
      PlayerAttackRangeAdd,
      PlayerAttackRangeRate,
      EnemySightPointAdd,
      EnemySightPointRate,
      EnemyAttackRangeAdd,
      EnemyAttackRangeRate,
      PlayerSkillRangeAdd,
      PlayerSkillRangeRate,
      EnemySkillRangeAdd,
      EnemySkillRangeRate,
      PlayerMinimumPositionGapRate,
      EnemyMinimumPositionGapRate,
      PlayerSightRangeMax,
      EnemySightRangeMax,
      TSSAirUnitHeight,
      IsPhaseBGM,
      BGMId,
      WarningUI,
      TSSHatchOpen,
      ForcedTacticSpeed,
      ForcedSkillUse,
      ShowNPCSkillCutIn,
      ImmuneHitBeforeTimeOutEnd,
      UIBattleHideFromScratch,
      UIEnemyCount,
      BattleReadyTimelinePath,
      BeforeVictoryTimelinePath,
      SkipBattleEnd,
      HideNPCWhenBattleEnd,
      CoverPointOff,
      UIHpScale,
      UIEmojiScale,
      UISkillMainLogScale,
      EffectCountLimit,
      AllyPassiveSkillId,
      AllyPassiveSkillLevel,
      EnemyPassiveSkillId,
      EnemyPassiveSkillLevel,
    })
  }
}
