// automatically generated by the FlatBuffers compiler, do not modify
// @generated
#![allow(unused_imports, dead_code)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum CafeRankExcelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CafeRankExcel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CafeRankExcel<'a> {
  type Inner = CafeRankExcel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CafeRankExcel<'a> {
  pub const VT_CAFEID: flatbuffers::VOffsetT = 4;
  pub const VT_RANK: flatbuffers::VOffsetT = 6;
  pub const VT_RECIPEID: flatbuffers::VOffsetT = 8;
  pub const VT_COMFORTMAX: flatbuffers::VOffsetT = 10;
  pub const VT_TAGCOUNTMAX: flatbuffers::VOffsetT = 12;
  pub const VT_CHARACTERVISITMIN: flatbuffers::VOffsetT = 14;
  pub const VT_CHARACTERVISITMAX: flatbuffers::VOffsetT = 16;
  pub const VT_CAFEVISITWEIGHTBASE: flatbuffers::VOffsetT = 18;
  pub const VT_CAFEVISITWEIGHTTAGBONUSSTEP: flatbuffers::VOffsetT = 20;
  pub const VT_CAFEVISITWEIGHTTAGBONUS: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CafeRankExcel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CafeRankExcelArgs<'args>
  ) -> flatbuffers::WIPOffset<CafeRankExcel<'bldr>> {
    let mut builder = CafeRankExcelBuilder::new(_fbb);
    let key = table_encryption_service::create_key(b"CafeRank");
      let x = args.TagCountMax;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_TagCountMax(x);
      let x = args.ComfortMax;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_ComfortMax(x);
      let x = args.RecipeId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_RecipeId(x);
      let x = args.Rank;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_Rank(x);
      let x = args.CafeId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_CafeId(x);
      if let Some(x) = args.CafeVisitWeightTagBonus {
        builder.add_CafeVisitWeightTagBonus(x);
      }
      if let Some(x) = args.CafeVisitWeightTagBonusStep {
        builder.add_CafeVisitWeightTagBonusStep(x);
      }
      let x = args.CafeVisitWeightBase;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_CafeVisitWeightBase(x);
      let x = args.CharacterVisitMax;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_CharacterVisitMax(x);
      let x = args.CharacterVisitMin;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_CharacterVisitMin(x);
    builder.finish()
  }

  pub fn unpack(&self) -> CafeRankExcelT {
    let key = table_encryption_service::create_key(b"CafeRank");
      let CafeId = self.CafeId();
      let Rank = self.Rank();
      let RecipeId = self.RecipeId();
      let ComfortMax = self.ComfortMax();
      let TagCountMax = self.TagCountMax();
      let CharacterVisitMin = self.CharacterVisitMin();
      let CharacterVisitMax = self.CharacterVisitMax();
      let CafeVisitWeightBase = self.CafeVisitWeightBase();
    let CafeVisitWeightTagBonusStep = self.CafeVisitWeightTagBonusStep().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_int(*val, &key) } else { *val }).collect()
    });
    let CafeVisitWeightTagBonus = self.CafeVisitWeightTagBonus().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_int(*val, &key) } else { *val }).collect()
    });
    CafeRankExcelT {
      CafeId,
      Rank,
      RecipeId,
      ComfortMax,
      TagCountMax,
      CharacterVisitMin,
      CharacterVisitMax,
      CafeVisitWeightBase,
      CafeVisitWeightTagBonusStep,
      CafeVisitWeightTagBonus,
    }
  }

  #[inline]
  pub fn CafeId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CafeRankExcel::VT_CAFEID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn Rank(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CafeRankExcel::VT_RANK, Some(0)).unwrap()}
  }
  #[inline]
  pub fn RecipeId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CafeRankExcel::VT_RECIPEID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ComfortMax(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CafeRankExcel::VT_COMFORTMAX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn TagCountMax(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CafeRankExcel::VT_TAGCOUNTMAX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CharacterVisitMin(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CafeRankExcel::VT_CHARACTERVISITMIN, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CharacterVisitMax(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CafeRankExcel::VT_CHARACTERVISITMAX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CafeVisitWeightBase(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CafeRankExcel::VT_CAFEVISITWEIGHTBASE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CafeVisitWeightTagBonusStep(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(CafeRankExcel::VT_CAFEVISITWEIGHTTAGBONUSSTEP, None)}
  }
  #[inline]
  pub fn CafeVisitWeightTagBonus(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(CafeRankExcel::VT_CAFEVISITWEIGHTTAGBONUS, None)}
  }
}

impl flatbuffers::Verifiable for CafeRankExcel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("CafeId", Self::VT_CAFEID, false)?
     .visit_field::<i64>("Rank", Self::VT_RANK, false)?
     .visit_field::<i64>("RecipeId", Self::VT_RECIPEID, false)?
     .visit_field::<i64>("ComfortMax", Self::VT_COMFORTMAX, false)?
     .visit_field::<i64>("TagCountMax", Self::VT_TAGCOUNTMAX, false)?
     .visit_field::<i32>("CharacterVisitMin", Self::VT_CHARACTERVISITMIN, false)?
     .visit_field::<i32>("CharacterVisitMax", Self::VT_CHARACTERVISITMAX, false)?
     .visit_field::<i32>("CafeVisitWeightBase", Self::VT_CAFEVISITWEIGHTBASE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("CafeVisitWeightTagBonusStep", Self::VT_CAFEVISITWEIGHTTAGBONUSSTEP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("CafeVisitWeightTagBonus", Self::VT_CAFEVISITWEIGHTTAGBONUS, false)?
     .finish();
    Ok(())
  }
}
pub struct CafeRankExcelArgs<'a> {
    pub CafeId: i64,
    pub Rank: i64,
    pub RecipeId: i64,
    pub ComfortMax: i64,
    pub TagCountMax: i64,
    pub CharacterVisitMin: i32,
    pub CharacterVisitMax: i32,
    pub CafeVisitWeightBase: i32,
    pub CafeVisitWeightTagBonusStep: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub CafeVisitWeightTagBonus: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for CafeRankExcelArgs<'a> {
  #[inline]
  fn default() -> Self {
    CafeRankExcelArgs {
      CafeId: 0,
      Rank: 0,
      RecipeId: 0,
      ComfortMax: 0,
      TagCountMax: 0,
      CharacterVisitMin: 0,
      CharacterVisitMax: 0,
      CafeVisitWeightBase: 0,
      CafeVisitWeightTagBonusStep: None,
      CafeVisitWeightTagBonus: None,
    }
  }
}

impl Serialize for CafeRankExcel<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("CafeRankExcel", 10)?;
      s.serialize_field("CafeId", &self.CafeId())?;
      s.serialize_field("Rank", &self.Rank())?;
      s.serialize_field("RecipeId", &self.RecipeId())?;
      s.serialize_field("ComfortMax", &self.ComfortMax())?;
      s.serialize_field("TagCountMax", &self.TagCountMax())?;
      s.serialize_field("CharacterVisitMin", &self.CharacterVisitMin())?;
      s.serialize_field("CharacterVisitMax", &self.CharacterVisitMax())?;
      s.serialize_field("CafeVisitWeightBase", &self.CafeVisitWeightBase())?;
      if let Some(f) = self.CafeVisitWeightTagBonusStep() {
        s.serialize_field("CafeVisitWeightTagBonusStep", &f)?;
      } else {
        s.skip_field("CafeVisitWeightTagBonusStep")?;
      }
      if let Some(f) = self.CafeVisitWeightTagBonus() {
        s.serialize_field("CafeVisitWeightTagBonus", &f)?;
      } else {
        s.skip_field("CafeVisitWeightTagBonus")?;
      }
    s.end()
  }
}

pub struct CafeRankExcelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CafeRankExcelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_CafeId(&mut self, CafeId: i64) {
    self.fbb_.push_slot::<i64>(CafeRankExcel::VT_CAFEID, CafeId, 0);
  }
  #[inline]
  pub fn add_Rank(&mut self, Rank: i64) {
    self.fbb_.push_slot::<i64>(CafeRankExcel::VT_RANK, Rank, 0);
  }
  #[inline]
  pub fn add_RecipeId(&mut self, RecipeId: i64) {
    self.fbb_.push_slot::<i64>(CafeRankExcel::VT_RECIPEID, RecipeId, 0);
  }
  #[inline]
  pub fn add_ComfortMax(&mut self, ComfortMax: i64) {
    self.fbb_.push_slot::<i64>(CafeRankExcel::VT_COMFORTMAX, ComfortMax, 0);
  }
  #[inline]
  pub fn add_TagCountMax(&mut self, TagCountMax: i64) {
    self.fbb_.push_slot::<i64>(CafeRankExcel::VT_TAGCOUNTMAX, TagCountMax, 0);
  }
  #[inline]
  pub fn add_CharacterVisitMin(&mut self, CharacterVisitMin: i32) {
    self.fbb_.push_slot::<i32>(CafeRankExcel::VT_CHARACTERVISITMIN, CharacterVisitMin, 0);
  }
  #[inline]
  pub fn add_CharacterVisitMax(&mut self, CharacterVisitMax: i32) {
    self.fbb_.push_slot::<i32>(CafeRankExcel::VT_CHARACTERVISITMAX, CharacterVisitMax, 0);
  }
  #[inline]
  pub fn add_CafeVisitWeightBase(&mut self, CafeVisitWeightBase: i32) {
    self.fbb_.push_slot::<i32>(CafeRankExcel::VT_CAFEVISITWEIGHTBASE, CafeVisitWeightBase, 0);
  }
  #[inline]
  pub fn add_CafeVisitWeightTagBonusStep(&mut self, CafeVisitWeightTagBonusStep: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CafeRankExcel::VT_CAFEVISITWEIGHTTAGBONUSSTEP, CafeVisitWeightTagBonusStep);
  }
  #[inline]
  pub fn add_CafeVisitWeightTagBonus(&mut self, CafeVisitWeightTagBonus: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CafeRankExcel::VT_CAFEVISITWEIGHTTAGBONUS, CafeVisitWeightTagBonus);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CafeRankExcelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CafeRankExcelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CafeRankExcel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CafeRankExcel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CafeRankExcel");
      ds.field("CafeId", &self.CafeId());
      ds.field("Rank", &self.Rank());
      ds.field("RecipeId", &self.RecipeId());
      ds.field("ComfortMax", &self.ComfortMax());
      ds.field("TagCountMax", &self.TagCountMax());
      ds.field("CharacterVisitMin", &self.CharacterVisitMin());
      ds.field("CharacterVisitMax", &self.CharacterVisitMax());
      ds.field("CafeVisitWeightBase", &self.CafeVisitWeightBase());
      ds.field("CafeVisitWeightTagBonusStep", &self.CafeVisitWeightTagBonusStep());
      ds.field("CafeVisitWeightTagBonus", &self.CafeVisitWeightTagBonus());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CafeRankExcelT {
  pub CafeId: i64,
  pub Rank: i64,
  pub RecipeId: i64,
  pub ComfortMax: i64,
  pub TagCountMax: i64,
  pub CharacterVisitMin: i32,
  pub CharacterVisitMax: i32,
  pub CafeVisitWeightBase: i32,
  pub CafeVisitWeightTagBonusStep: Option<Vec<i32>>,
  pub CafeVisitWeightTagBonus: Option<Vec<i32>>,
}
impl Default for CafeRankExcelT {
  fn default() -> Self {
    Self {
      CafeId: 0,
      Rank: 0,
      RecipeId: 0,
      ComfortMax: 0,
      TagCountMax: 0,
      CharacterVisitMin: 0,
      CharacterVisitMax: 0,
      CafeVisitWeightBase: 0,
      CafeVisitWeightTagBonusStep: None,
      CafeVisitWeightTagBonus: None,
    }
  }
}
impl CafeRankExcelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CafeRankExcel<'b>> {
    let CafeId = self.CafeId;
    let Rank = self.Rank;
    let RecipeId = self.RecipeId;
    let ComfortMax = self.ComfortMax;
    let TagCountMax = self.TagCountMax;
    let CharacterVisitMin = self.CharacterVisitMin;
    let CharacterVisitMax = self.CharacterVisitMax;
    let CafeVisitWeightBase = self.CafeVisitWeightBase;
    let CafeVisitWeightTagBonusStep = self.CafeVisitWeightTagBonusStep.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let CafeVisitWeightTagBonus = self.CafeVisitWeightTagBonus.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    CafeRankExcel::create(_fbb, &CafeRankExcelArgs{
      CafeId,
      Rank,
      RecipeId,
      ComfortMax,
      TagCountMax,
      CharacterVisitMin,
      CharacterVisitMax,
      CafeVisitWeightBase,
      CafeVisitWeightTagBonusStep,
      CafeVisitWeightTagBonus,
    })
  }
}
