// automatically generated by the FlatBuffers compiler, do not modify
// @generated
#![allow(unused_imports, dead_code)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum CameraExcelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CameraExcel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CameraExcel<'a> {
  type Inner = CameraExcel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CameraExcel<'a> {
  pub const VT_UNIQUEID: flatbuffers::VOffsetT = 4;
  pub const VT_MINDISTANCE: flatbuffers::VOffsetT = 6;
  pub const VT_MAXDISTANCE: flatbuffers::VOffsetT = 8;
  pub const VT_ROTATIONX: flatbuffers::VOffsetT = 10;
  pub const VT_ROTATIONY: flatbuffers::VOffsetT = 12;
  pub const VT_MOVEINSTANTLY: flatbuffers::VOffsetT = 14;
  pub const VT_MOVEINSTANTLYROTATIONSAVE: flatbuffers::VOffsetT = 16;
  pub const VT_LEFTMARGIN: flatbuffers::VOffsetT = 18;
  pub const VT_BOTTOMMARGIN: flatbuffers::VOffsetT = 20;
  pub const VT_IGNOREENEMIES: flatbuffers::VOffsetT = 22;
  pub const VT_USERAILPOINTCOMPENSATION: flatbuffers::VOffsetT = 24;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CameraExcel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CameraExcelArgs
  ) -> flatbuffers::WIPOffset<CameraExcel<'bldr>> {
    let mut builder = CameraExcelBuilder::new(_fbb);
    let key = table_encryption_service::create_key(b"Camera");
      let x = args.UniqueId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_UniqueId(x);
      let x = args.BottomMargin;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_BottomMargin(x);
      let x = args.LeftMargin;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_LeftMargin(x);
      let x = args.RotationY;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_RotationY(x);
      let x = args.RotationX;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_RotationX(x);
      let x = args.MaxDistance;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_MaxDistance(x);
      let x = args.MinDistance;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_MinDistance(x);
      builder.add_UseRailPointCompensation(args.UseRailPointCompensation);
      builder.add_IgnoreEnemies(args.IgnoreEnemies);
      builder.add_MoveInstantlyRotationSave(args.MoveInstantlyRotationSave);
      builder.add_MoveInstantly(args.MoveInstantly);
    builder.finish()
  }

  pub fn unpack(&self) -> CameraExcelT {
    let key = table_encryption_service::create_key(b"Camera");
      let UniqueId = self.UniqueId();
      let MinDistance = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.MinDistance(), &key)
      } else {
        self.MinDistance()
      };
      let MaxDistance = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.MaxDistance(), &key)
      } else {
        self.MaxDistance()
      };
      let RotationX = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.RotationX(), &key)
      } else {
        self.RotationX()
      };
      let RotationY = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.RotationY(), &key)
      } else {
        self.RotationY()
      };
      let MoveInstantly = self.MoveInstantly();
      let MoveInstantlyRotationSave = self.MoveInstantlyRotationSave();
      let LeftMargin = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.LeftMargin(), &key)
      } else {
        self.LeftMargin()
      };
      let BottomMargin = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.BottomMargin(), &key)
      } else {
        self.BottomMargin()
      };
      let IgnoreEnemies = self.IgnoreEnemies();
      let UseRailPointCompensation = self.UseRailPointCompensation();
    CameraExcelT {
      UniqueId,
      MinDistance,
      MaxDistance,
      RotationX,
      RotationY,
      MoveInstantly,
      MoveInstantlyRotationSave,
      LeftMargin,
      BottomMargin,
      IgnoreEnemies,
      UseRailPointCompensation,
    }
  }

  #[inline]
  pub fn UniqueId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CameraExcel::VT_UNIQUEID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn MinDistance(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(CameraExcel::VT_MINDISTANCE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn MaxDistance(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(CameraExcel::VT_MAXDISTANCE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn RotationX(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(CameraExcel::VT_ROTATIONX, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn RotationY(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(CameraExcel::VT_ROTATIONY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn MoveInstantly(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CameraExcel::VT_MOVEINSTANTLY, Some(false)).unwrap()}
  }
  #[inline]
  pub fn MoveInstantlyRotationSave(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CameraExcel::VT_MOVEINSTANTLYROTATIONSAVE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn LeftMargin(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(CameraExcel::VT_LEFTMARGIN, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn BottomMargin(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(CameraExcel::VT_BOTTOMMARGIN, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn IgnoreEnemies(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CameraExcel::VT_IGNOREENEMIES, Some(false)).unwrap()}
  }
  #[inline]
  pub fn UseRailPointCompensation(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CameraExcel::VT_USERAILPOINTCOMPENSATION, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for CameraExcel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("UniqueId", Self::VT_UNIQUEID, false)?
     .visit_field::<f32>("MinDistance", Self::VT_MINDISTANCE, false)?
     .visit_field::<f32>("MaxDistance", Self::VT_MAXDISTANCE, false)?
     .visit_field::<f32>("RotationX", Self::VT_ROTATIONX, false)?
     .visit_field::<f32>("RotationY", Self::VT_ROTATIONY, false)?
     .visit_field::<bool>("MoveInstantly", Self::VT_MOVEINSTANTLY, false)?
     .visit_field::<bool>("MoveInstantlyRotationSave", Self::VT_MOVEINSTANTLYROTATIONSAVE, false)?
     .visit_field::<f32>("LeftMargin", Self::VT_LEFTMARGIN, false)?
     .visit_field::<f32>("BottomMargin", Self::VT_BOTTOMMARGIN, false)?
     .visit_field::<bool>("IgnoreEnemies", Self::VT_IGNOREENEMIES, false)?
     .visit_field::<bool>("UseRailPointCompensation", Self::VT_USERAILPOINTCOMPENSATION, false)?
     .finish();
    Ok(())
  }
}
pub struct CameraExcelArgs {
    pub UniqueId: i64,
    pub MinDistance: f32,
    pub MaxDistance: f32,
    pub RotationX: f32,
    pub RotationY: f32,
    pub MoveInstantly: bool,
    pub MoveInstantlyRotationSave: bool,
    pub LeftMargin: f32,
    pub BottomMargin: f32,
    pub IgnoreEnemies: bool,
    pub UseRailPointCompensation: bool,
}
impl<'a> Default for CameraExcelArgs {
  #[inline]
  fn default() -> Self {
    CameraExcelArgs {
      UniqueId: 0,
      MinDistance: 0.0,
      MaxDistance: 0.0,
      RotationX: 0.0,
      RotationY: 0.0,
      MoveInstantly: false,
      MoveInstantlyRotationSave: false,
      LeftMargin: 0.0,
      BottomMargin: 0.0,
      IgnoreEnemies: false,
      UseRailPointCompensation: false,
    }
  }
}

impl Serialize for CameraExcel<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("CameraExcel", 11)?;
      s.serialize_field("UniqueId", &self.UniqueId())?;
      s.serialize_field("MinDistance", &self.MinDistance())?;
      s.serialize_field("MaxDistance", &self.MaxDistance())?;
      s.serialize_field("RotationX", &self.RotationX())?;
      s.serialize_field("RotationY", &self.RotationY())?;
      s.serialize_field("MoveInstantly", &self.MoveInstantly())?;
      s.serialize_field("MoveInstantlyRotationSave", &self.MoveInstantlyRotationSave())?;
      s.serialize_field("LeftMargin", &self.LeftMargin())?;
      s.serialize_field("BottomMargin", &self.BottomMargin())?;
      s.serialize_field("IgnoreEnemies", &self.IgnoreEnemies())?;
      s.serialize_field("UseRailPointCompensation", &self.UseRailPointCompensation())?;
    s.end()
  }
}

pub struct CameraExcelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CameraExcelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_UniqueId(&mut self, UniqueId: i64) {
    self.fbb_.push_slot::<i64>(CameraExcel::VT_UNIQUEID, UniqueId, 0);
  }
  #[inline]
  pub fn add_MinDistance(&mut self, MinDistance: f32) {
    self.fbb_.push_slot::<f32>(CameraExcel::VT_MINDISTANCE, MinDistance, 0.0);
  }
  #[inline]
  pub fn add_MaxDistance(&mut self, MaxDistance: f32) {
    self.fbb_.push_slot::<f32>(CameraExcel::VT_MAXDISTANCE, MaxDistance, 0.0);
  }
  #[inline]
  pub fn add_RotationX(&mut self, RotationX: f32) {
    self.fbb_.push_slot::<f32>(CameraExcel::VT_ROTATIONX, RotationX, 0.0);
  }
  #[inline]
  pub fn add_RotationY(&mut self, RotationY: f32) {
    self.fbb_.push_slot::<f32>(CameraExcel::VT_ROTATIONY, RotationY, 0.0);
  }
  #[inline]
  pub fn add_MoveInstantly(&mut self, MoveInstantly: bool) {
    self.fbb_.push_slot::<bool>(CameraExcel::VT_MOVEINSTANTLY, MoveInstantly, false);
  }
  #[inline]
  pub fn add_MoveInstantlyRotationSave(&mut self, MoveInstantlyRotationSave: bool) {
    self.fbb_.push_slot::<bool>(CameraExcel::VT_MOVEINSTANTLYROTATIONSAVE, MoveInstantlyRotationSave, false);
  }
  #[inline]
  pub fn add_LeftMargin(&mut self, LeftMargin: f32) {
    self.fbb_.push_slot::<f32>(CameraExcel::VT_LEFTMARGIN, LeftMargin, 0.0);
  }
  #[inline]
  pub fn add_BottomMargin(&mut self, BottomMargin: f32) {
    self.fbb_.push_slot::<f32>(CameraExcel::VT_BOTTOMMARGIN, BottomMargin, 0.0);
  }
  #[inline]
  pub fn add_IgnoreEnemies(&mut self, IgnoreEnemies: bool) {
    self.fbb_.push_slot::<bool>(CameraExcel::VT_IGNOREENEMIES, IgnoreEnemies, false);
  }
  #[inline]
  pub fn add_UseRailPointCompensation(&mut self, UseRailPointCompensation: bool) {
    self.fbb_.push_slot::<bool>(CameraExcel::VT_USERAILPOINTCOMPENSATION, UseRailPointCompensation, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CameraExcelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CameraExcelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CameraExcel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CameraExcel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CameraExcel");
      ds.field("UniqueId", &self.UniqueId());
      ds.field("MinDistance", &self.MinDistance());
      ds.field("MaxDistance", &self.MaxDistance());
      ds.field("RotationX", &self.RotationX());
      ds.field("RotationY", &self.RotationY());
      ds.field("MoveInstantly", &self.MoveInstantly());
      ds.field("MoveInstantlyRotationSave", &self.MoveInstantlyRotationSave());
      ds.field("LeftMargin", &self.LeftMargin());
      ds.field("BottomMargin", &self.BottomMargin());
      ds.field("IgnoreEnemies", &self.IgnoreEnemies());
      ds.field("UseRailPointCompensation", &self.UseRailPointCompensation());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CameraExcelT {
  pub UniqueId: i64,
  pub MinDistance: f32,
  pub MaxDistance: f32,
  pub RotationX: f32,
  pub RotationY: f32,
  pub MoveInstantly: bool,
  pub MoveInstantlyRotationSave: bool,
  pub LeftMargin: f32,
  pub BottomMargin: f32,
  pub IgnoreEnemies: bool,
  pub UseRailPointCompensation: bool,
}
impl Default for CameraExcelT {
  fn default() -> Self {
    Self {
      UniqueId: 0,
      MinDistance: 0.0,
      MaxDistance: 0.0,
      RotationX: 0.0,
      RotationY: 0.0,
      MoveInstantly: false,
      MoveInstantlyRotationSave: false,
      LeftMargin: 0.0,
      BottomMargin: 0.0,
      IgnoreEnemies: false,
      UseRailPointCompensation: false,
    }
  }
}
impl CameraExcelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CameraExcel<'b>> {
    let UniqueId = self.UniqueId;
    let MinDistance = self.MinDistance;
    let MaxDistance = self.MaxDistance;
    let RotationX = self.RotationX;
    let RotationY = self.RotationY;
    let MoveInstantly = self.MoveInstantly;
    let MoveInstantlyRotationSave = self.MoveInstantlyRotationSave;
    let LeftMargin = self.LeftMargin;
    let BottomMargin = self.BottomMargin;
    let IgnoreEnemies = self.IgnoreEnemies;
    let UseRailPointCompensation = self.UseRailPointCompensation;
    CameraExcel::create(_fbb, &CameraExcelArgs{
      UniqueId,
      MinDistance,
      MaxDistance,
      RotationX,
      RotationY,
      MoveInstantly,
      MoveInstantlyRotationSave,
      LeftMargin,
      BottomMargin,
      IgnoreEnemies,
      UseRailPointCompensation,
    })
  }
}
