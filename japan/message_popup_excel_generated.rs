// automatically generated by the FlatBuffers compiler, do not modify
// @generated
#![allow(unused_imports, dead_code)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum MessagePopupExcelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MessagePopupExcel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MessagePopupExcel<'a> {
  type Inner = MessagePopupExcel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MessagePopupExcel<'a> {
  pub const VT_STRINGID: flatbuffers::VOffsetT = 4;
  pub const VT_MESSAGEPOPUPLAYOUT: flatbuffers::VOffsetT = 6;
  pub const VT_ORDERTYPE: flatbuffers::VOffsetT = 8;
  pub const VT_IMAGE: flatbuffers::VOffsetT = 10;
  pub const VT_TITLETEXT: flatbuffers::VOffsetT = 12;
  pub const VT_SUBTITLETEXT: flatbuffers::VOffsetT = 14;
  pub const VT_MESSAGETEXT: flatbuffers::VOffsetT = 16;
  pub const VT_CONDITIONTEXT: flatbuffers::VOffsetT = 18;
  pub const VT_DISPLAYXBUTTON: flatbuffers::VOffsetT = 20;
  pub const VT_BUTTON: flatbuffers::VOffsetT = 22;
  pub const VT_BUTTONTEXT: flatbuffers::VOffsetT = 24;
  pub const VT_BUTTONCOMMAND: flatbuffers::VOffsetT = 26;
  pub const VT_BUTTONPARAMETER: flatbuffers::VOffsetT = 28;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MessagePopupExcel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MessagePopupExcelArgs<'args>
  ) -> flatbuffers::WIPOffset<MessagePopupExcel<'bldr>> {
    let mut builder = MessagePopupExcelBuilder::new(_fbb);
    let key = table_encryption_service::create_key(b"MessagePopup");
      if let Some(x) = args.ButtonParameter {
        builder.add_ButtonParameter(x);
      }
      if let Some(x) = args.ButtonCommand {
        builder.add_ButtonCommand(x);
      }
      if let Some(x) = args.ButtonText {
        builder.add_ButtonText(x);
      }
      if let Some(x) = args.Button {
        builder.add_Button(x);
      }
      if let Some(x) = args.ConditionText {
        builder.add_ConditionText(x);
      }
      let x = args.MessageText;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_uint(x, &key) } else { x };
      builder.add_MessageText(x);
      let x = args.SubTitleText;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_uint(x, &key) } else { x };
      builder.add_SubTitleText(x);
      let x = args.TitleText;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_uint(x, &key) } else { x };
      builder.add_TitleText(x);
      if let Some(x) = args.Image {
        builder.add_Image(x);
      }
      let x = args.OrderType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_OrderType(x);
      let x = args.MessagePopupLayout;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_MessagePopupLayout(x);
      let x = args.StringId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_uint(x, &key) } else { x };
      builder.add_StringId(x);
      builder.add_DisplayXButton(args.DisplayXButton);
    builder.finish()
  }

  pub fn unpack(&self) -> MessagePopupExcelT {
    let key = table_encryption_service::create_key(b"MessagePopup");
      let StringId = self.StringId();
      let MessagePopupLayout = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.MessagePopupLayout(), &key)
      } else {
        self.MessagePopupLayout()
      };
      let OrderType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.OrderType(), &key)
      } else {
        self.OrderType()
      };
    let Image = self.Image().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let TitleText = self.TitleText();
      let SubTitleText = self.SubTitleText();
      let MessageText = self.MessageText();
    let ConditionText = self.ConditionText().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_uint(*val, &key) } else { *val }).collect()
    });
      let DisplayXButton = self.DisplayXButton();
    let Button = self.Button().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(*val, &key) } else { *val }).collect()
    });
    let ButtonText = self.ButtonText().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_uint(*val, &key) } else { *val }).collect()
    });
    let ButtonCommand = self.ButtonCommand().map(|x| {
      x.iter().map(|s| if table_encryption_service::use_encryption() { table_encryption_service::convert_string(s, &key).unwrap() } else { s.to_string() }).collect()
    });
    let ButtonParameter = self.ButtonParameter().map(|x| {
      x.iter().map(|s| if table_encryption_service::use_encryption() { table_encryption_service::convert_string(s, &key).unwrap() } else { s.to_string() }).collect()
    });
    MessagePopupExcelT {
      StringId,
      MessagePopupLayout,
      OrderType,
      Image,
      TitleText,
      SubTitleText,
      MessageText,
      ConditionText,
      DisplayXButton,
      Button,
      ButtonText,
      ButtonCommand,
      ButtonParameter,
    }
  }

  #[inline]
  pub fn StringId(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(MessagePopupExcel::VT_STRINGID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn MessagePopupLayout(&self) -> MessagePopupLayout {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<MessagePopupLayout>(MessagePopupExcel::VT_MESSAGEPOPUPLAYOUT, Some(MessagePopupLayout::TextOnly)).unwrap()}
  }
  #[inline]
  pub fn OrderType(&self) -> MessagePopupImagePositionType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<MessagePopupImagePositionType>(MessagePopupExcel::VT_ORDERTYPE, Some(MessagePopupImagePositionType::ImageFirst)).unwrap()}
  }
  #[inline]
  pub fn Image(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MessagePopupExcel::VT_IMAGE, None)}
  }
  #[inline]
  pub fn TitleText(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(MessagePopupExcel::VT_TITLETEXT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn SubTitleText(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(MessagePopupExcel::VT_SUBTITLETEXT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn MessageText(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(MessagePopupExcel::VT_MESSAGETEXT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ConditionText(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(MessagePopupExcel::VT_CONDITIONTEXT, None)}
  }
  #[inline]
  pub fn DisplayXButton(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(MessagePopupExcel::VT_DISPLAYXBUTTON, Some(false)).unwrap()}
  }
  #[inline]
  pub fn Button(&self) -> Option<flatbuffers::Vector<'a, MessagePopupButtonType>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, MessagePopupButtonType>>>(MessagePopupExcel::VT_BUTTON, None)}
  }
  #[inline]
  pub fn ButtonText(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(MessagePopupExcel::VT_BUTTONTEXT, None)}
  }
  #[inline]
  pub fn ButtonCommand(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(MessagePopupExcel::VT_BUTTONCOMMAND, None)}
  }
  #[inline]
  pub fn ButtonParameter(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(MessagePopupExcel::VT_BUTTONPARAMETER, None)}
  }
}

impl flatbuffers::Verifiable for MessagePopupExcel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("StringId", Self::VT_STRINGID, false)?
     .visit_field::<MessagePopupLayout>("MessagePopupLayout", Self::VT_MESSAGEPOPUPLAYOUT, false)?
     .visit_field::<MessagePopupImagePositionType>("OrderType", Self::VT_ORDERTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("Image", Self::VT_IMAGE, false)?
     .visit_field::<u32>("TitleText", Self::VT_TITLETEXT, false)?
     .visit_field::<u32>("SubTitleText", Self::VT_SUBTITLETEXT, false)?
     .visit_field::<u32>("MessageText", Self::VT_MESSAGETEXT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("ConditionText", Self::VT_CONDITIONTEXT, false)?
     .visit_field::<bool>("DisplayXButton", Self::VT_DISPLAYXBUTTON, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, MessagePopupButtonType>>>("Button", Self::VT_BUTTON, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("ButtonText", Self::VT_BUTTONTEXT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("ButtonCommand", Self::VT_BUTTONCOMMAND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("ButtonParameter", Self::VT_BUTTONPARAMETER, false)?
     .finish();
    Ok(())
  }
}
pub struct MessagePopupExcelArgs<'a> {
    pub StringId: u32,
    pub MessagePopupLayout: MessagePopupLayout,
    pub OrderType: MessagePopupImagePositionType,
    pub Image: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TitleText: u32,
    pub SubTitleText: u32,
    pub MessageText: u32,
    pub ConditionText: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub DisplayXButton: bool,
    pub Button: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, MessagePopupButtonType>>>,
    pub ButtonText: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub ButtonCommand: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub ButtonParameter: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for MessagePopupExcelArgs<'a> {
  #[inline]
  fn default() -> Self {
    MessagePopupExcelArgs {
      StringId: 0,
      MessagePopupLayout: MessagePopupLayout::TextOnly,
      OrderType: MessagePopupImagePositionType::ImageFirst,
      Image: None,
      TitleText: 0,
      SubTitleText: 0,
      MessageText: 0,
      ConditionText: None,
      DisplayXButton: false,
      Button: None,
      ButtonText: None,
      ButtonCommand: None,
      ButtonParameter: None,
    }
  }
}

impl Serialize for MessagePopupExcel<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("MessagePopupExcel", 13)?;
      s.serialize_field("StringId", &self.StringId())?;
      s.serialize_field("MessagePopupLayout", &self.MessagePopupLayout())?;
      s.serialize_field("OrderType", &self.OrderType())?;
      if let Some(f) = self.Image() {
        s.serialize_field("Image", &f)?;
      } else {
        s.skip_field("Image")?;
      }
      s.serialize_field("TitleText", &self.TitleText())?;
      s.serialize_field("SubTitleText", &self.SubTitleText())?;
      s.serialize_field("MessageText", &self.MessageText())?;
      if let Some(f) = self.ConditionText() {
        s.serialize_field("ConditionText", &f)?;
      } else {
        s.skip_field("ConditionText")?;
      }
      s.serialize_field("DisplayXButton", &self.DisplayXButton())?;
      if let Some(f) = self.Button() {
        s.serialize_field("Button", &f)?;
      } else {
        s.skip_field("Button")?;
      }
      if let Some(f) = self.ButtonText() {
        s.serialize_field("ButtonText", &f)?;
      } else {
        s.skip_field("ButtonText")?;
      }
      if let Some(f) = self.ButtonCommand() {
        s.serialize_field("ButtonCommand", &f)?;
      } else {
        s.skip_field("ButtonCommand")?;
      }
      if let Some(f) = self.ButtonParameter() {
        s.serialize_field("ButtonParameter", &f)?;
      } else {
        s.skip_field("ButtonParameter")?;
      }
    s.end()
  }
}

pub struct MessagePopupExcelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MessagePopupExcelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_StringId(&mut self, StringId: u32) {
    self.fbb_.push_slot::<u32>(MessagePopupExcel::VT_STRINGID, StringId, 0);
  }
  #[inline]
  pub fn add_MessagePopupLayout(&mut self, MessagePopupLayout: MessagePopupLayout) {
    self.fbb_.push_slot::<MessagePopupLayout>(MessagePopupExcel::VT_MESSAGEPOPUPLAYOUT, MessagePopupLayout, MessagePopupLayout::TextOnly);
  }
  #[inline]
  pub fn add_OrderType(&mut self, OrderType: MessagePopupImagePositionType) {
    self.fbb_.push_slot::<MessagePopupImagePositionType>(MessagePopupExcel::VT_ORDERTYPE, OrderType, MessagePopupImagePositionType::ImageFirst);
  }
  #[inline]
  pub fn add_Image(&mut self, Image: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MessagePopupExcel::VT_IMAGE, Image);
  }
  #[inline]
  pub fn add_TitleText(&mut self, TitleText: u32) {
    self.fbb_.push_slot::<u32>(MessagePopupExcel::VT_TITLETEXT, TitleText, 0);
  }
  #[inline]
  pub fn add_SubTitleText(&mut self, SubTitleText: u32) {
    self.fbb_.push_slot::<u32>(MessagePopupExcel::VT_SUBTITLETEXT, SubTitleText, 0);
  }
  #[inline]
  pub fn add_MessageText(&mut self, MessageText: u32) {
    self.fbb_.push_slot::<u32>(MessagePopupExcel::VT_MESSAGETEXT, MessageText, 0);
  }
  #[inline]
  pub fn add_ConditionText(&mut self, ConditionText: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MessagePopupExcel::VT_CONDITIONTEXT, ConditionText);
  }
  #[inline]
  pub fn add_DisplayXButton(&mut self, DisplayXButton: bool) {
    self.fbb_.push_slot::<bool>(MessagePopupExcel::VT_DISPLAYXBUTTON, DisplayXButton, false);
  }
  #[inline]
  pub fn add_Button(&mut self, Button: flatbuffers::WIPOffset<flatbuffers::Vector<'b , MessagePopupButtonType>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MessagePopupExcel::VT_BUTTON, Button);
  }
  #[inline]
  pub fn add_ButtonText(&mut self, ButtonText: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MessagePopupExcel::VT_BUTTONTEXT, ButtonText);
  }
  #[inline]
  pub fn add_ButtonCommand(&mut self, ButtonCommand: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MessagePopupExcel::VT_BUTTONCOMMAND, ButtonCommand);
  }
  #[inline]
  pub fn add_ButtonParameter(&mut self, ButtonParameter: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MessagePopupExcel::VT_BUTTONPARAMETER, ButtonParameter);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MessagePopupExcelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MessagePopupExcelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MessagePopupExcel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MessagePopupExcel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MessagePopupExcel");
      ds.field("StringId", &self.StringId());
      ds.field("MessagePopupLayout", &self.MessagePopupLayout());
      ds.field("OrderType", &self.OrderType());
      ds.field("Image", &self.Image());
      ds.field("TitleText", &self.TitleText());
      ds.field("SubTitleText", &self.SubTitleText());
      ds.field("MessageText", &self.MessageText());
      ds.field("ConditionText", &self.ConditionText());
      ds.field("DisplayXButton", &self.DisplayXButton());
      ds.field("Button", &self.Button());
      ds.field("ButtonText", &self.ButtonText());
      ds.field("ButtonCommand", &self.ButtonCommand());
      ds.field("ButtonParameter", &self.ButtonParameter());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MessagePopupExcelT {
  pub StringId: u32,
  pub MessagePopupLayout: MessagePopupLayout,
  pub OrderType: MessagePopupImagePositionType,
  pub Image: Option<String>,
  pub TitleText: u32,
  pub SubTitleText: u32,
  pub MessageText: u32,
  pub ConditionText: Option<Vec<u32>>,
  pub DisplayXButton: bool,
  pub Button: Option<Vec<MessagePopupButtonType>>,
  pub ButtonText: Option<Vec<u32>>,
  pub ButtonCommand: Option<Vec<String>>,
  pub ButtonParameter: Option<Vec<String>>,
}
impl Default for MessagePopupExcelT {
  fn default() -> Self {
    Self {
      StringId: 0,
      MessagePopupLayout: MessagePopupLayout::TextOnly,
      OrderType: MessagePopupImagePositionType::ImageFirst,
      Image: None,
      TitleText: 0,
      SubTitleText: 0,
      MessageText: 0,
      ConditionText: None,
      DisplayXButton: false,
      Button: None,
      ButtonText: None,
      ButtonCommand: None,
      ButtonParameter: None,
    }
  }
}
impl MessagePopupExcelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<MessagePopupExcel<'b>> {
    let StringId = self.StringId;
    let MessagePopupLayout = self.MessagePopupLayout;
    let OrderType = self.OrderType;
    let Image = self.Image.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TitleText = self.TitleText;
    let SubTitleText = self.SubTitleText;
    let MessageText = self.MessageText;
    let ConditionText = self.ConditionText.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let DisplayXButton = self.DisplayXButton;
    let Button = self.Button.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let ButtonText = self.ButtonText.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let ButtonCommand = self.ButtonCommand.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let ButtonParameter = self.ButtonParameter.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    MessagePopupExcel::create(_fbb, &MessagePopupExcelArgs{
      StringId,
      MessagePopupLayout,
      OrderType,
      Image,
      TitleText,
      SubTitleText,
      MessageText,
      ConditionText,
      DisplayXButton,
      Button,
      ButtonText,
      ButtonCommand,
      ButtonParameter,
    })
  }
}
