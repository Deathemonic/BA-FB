// automatically generated by the FlatBuffers compiler, do not modify
// @generated
#![allow(unused_imports, dead_code)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum CharacterAIExcelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CharacterAIExcel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CharacterAIExcel<'a> {
  type Inner = CharacterAIExcel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CharacterAIExcel<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_ENGAGETYPE: flatbuffers::VOffsetT = 6;
  pub const VT_POSITIONING: flatbuffers::VOffsetT = 8;
  pub const VT_CHECKCANUSEAUTOSKILL: flatbuffers::VOffsetT = 10;
  pub const VT_DISTANCEREDUCERATIOOBSTACLEPATH: flatbuffers::VOffsetT = 12;
  pub const VT_DISTANCEREDUCEOBSTACLEPATH: flatbuffers::VOffsetT = 14;
  pub const VT_DISTANCEREDUCERATIOFORMATIONPATH: flatbuffers::VOffsetT = 16;
  pub const VT_DISTANCEREDUCEFORMATIONPATH: flatbuffers::VOffsetT = 18;
  pub const VT_MINIMUMPOSITIONGAP: flatbuffers::VOffsetT = 20;
  pub const VT_CANUSEOBSTACLEOFKNEELMOTION: flatbuffers::VOffsetT = 22;
  pub const VT_CANUSEOBSTACLEOFSTANDMOTION: flatbuffers::VOffsetT = 24;
  pub const VT_HASTARGETSWITCHINGMOTION: flatbuffers::VOffsetT = 26;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CharacterAIExcel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CharacterAIExcelArgs
  ) -> flatbuffers::WIPOffset<CharacterAIExcel<'bldr>> {
    let mut builder = CharacterAIExcelBuilder::new(_fbb);
    let key = table_encryption_service::create_key(b"CharacterAI");
      let x = args.MinimumPositionGap;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_MinimumPositionGap(x);
      let x = args.DistanceReduceFormationPath;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_DistanceReduceFormationPath(x);
      let x = args.DistanceReduceRatioFormationPath;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_DistanceReduceRatioFormationPath(x);
      let x = args.DistanceReduceObstaclePath;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_DistanceReduceObstaclePath(x);
      let x = args.DistanceReduceRatioObstaclePath;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_DistanceReduceRatioObstaclePath(x);
      let x = args.Id;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_Id(x);
      let x = args.Positioning;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_Positioning(x);
      let x = args.EngageType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_EngageType(x);
      builder.add_HasTargetSwitchingMotion(args.HasTargetSwitchingMotion);
      builder.add_CanUseObstacleOfStandMotion(args.CanUseObstacleOfStandMotion);
      builder.add_CanUseObstacleOfKneelMotion(args.CanUseObstacleOfKneelMotion);
      builder.add_CheckCanUseAutoSkill(args.CheckCanUseAutoSkill);
    builder.finish()
  }

  pub fn unpack(&self) -> CharacterAIExcelT {
    let key = table_encryption_service::create_key(b"CharacterAI");
      let Id = self.Id();
      let EngageType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.EngageType(), &key)
      } else {
        self.EngageType()
      };
      let Positioning = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.Positioning(), &key)
      } else {
        self.Positioning()
      };
      let CheckCanUseAutoSkill = self.CheckCanUseAutoSkill();
      let DistanceReduceRatioObstaclePath = self.DistanceReduceRatioObstaclePath();
      let DistanceReduceObstaclePath = self.DistanceReduceObstaclePath();
      let DistanceReduceRatioFormationPath = self.DistanceReduceRatioFormationPath();
      let DistanceReduceFormationPath = self.DistanceReduceFormationPath();
      let MinimumPositionGap = self.MinimumPositionGap();
      let CanUseObstacleOfKneelMotion = self.CanUseObstacleOfKneelMotion();
      let CanUseObstacleOfStandMotion = self.CanUseObstacleOfStandMotion();
      let HasTargetSwitchingMotion = self.HasTargetSwitchingMotion();
    CharacterAIExcelT {
      Id,
      EngageType,
      Positioning,
      CheckCanUseAutoSkill,
      DistanceReduceRatioObstaclePath,
      DistanceReduceObstaclePath,
      DistanceReduceRatioFormationPath,
      DistanceReduceFormationPath,
      MinimumPositionGap,
      CanUseObstacleOfKneelMotion,
      CanUseObstacleOfStandMotion,
      HasTargetSwitchingMotion,
    }
  }

  #[inline]
  pub fn Id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CharacterAIExcel::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EngageType(&self) -> EngageType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<EngageType>(CharacterAIExcel::VT_ENGAGETYPE, Some(EngageType::SearchAndMove)).unwrap()}
  }
  #[inline]
  pub fn Positioning(&self) -> PositioningType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<PositioningType>(CharacterAIExcel::VT_POSITIONING, Some(PositioningType::CloseToObstacle)).unwrap()}
  }
  #[inline]
  pub fn CheckCanUseAutoSkill(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CharacterAIExcel::VT_CHECKCANUSEAUTOSKILL, Some(false)).unwrap()}
  }
  #[inline]
  pub fn DistanceReduceRatioObstaclePath(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CharacterAIExcel::VT_DISTANCEREDUCERATIOOBSTACLEPATH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn DistanceReduceObstaclePath(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CharacterAIExcel::VT_DISTANCEREDUCEOBSTACLEPATH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn DistanceReduceRatioFormationPath(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CharacterAIExcel::VT_DISTANCEREDUCERATIOFORMATIONPATH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn DistanceReduceFormationPath(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CharacterAIExcel::VT_DISTANCEREDUCEFORMATIONPATH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn MinimumPositionGap(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CharacterAIExcel::VT_MINIMUMPOSITIONGAP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CanUseObstacleOfKneelMotion(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CharacterAIExcel::VT_CANUSEOBSTACLEOFKNEELMOTION, Some(false)).unwrap()}
  }
  #[inline]
  pub fn CanUseObstacleOfStandMotion(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CharacterAIExcel::VT_CANUSEOBSTACLEOFSTANDMOTION, Some(false)).unwrap()}
  }
  #[inline]
  pub fn HasTargetSwitchingMotion(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CharacterAIExcel::VT_HASTARGETSWITCHINGMOTION, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for CharacterAIExcel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("Id", Self::VT_ID, false)?
     .visit_field::<EngageType>("EngageType", Self::VT_ENGAGETYPE, false)?
     .visit_field::<PositioningType>("Positioning", Self::VT_POSITIONING, false)?
     .visit_field::<bool>("CheckCanUseAutoSkill", Self::VT_CHECKCANUSEAUTOSKILL, false)?
     .visit_field::<i64>("DistanceReduceRatioObstaclePath", Self::VT_DISTANCEREDUCERATIOOBSTACLEPATH, false)?
     .visit_field::<i64>("DistanceReduceObstaclePath", Self::VT_DISTANCEREDUCEOBSTACLEPATH, false)?
     .visit_field::<i64>("DistanceReduceRatioFormationPath", Self::VT_DISTANCEREDUCERATIOFORMATIONPATH, false)?
     .visit_field::<i64>("DistanceReduceFormationPath", Self::VT_DISTANCEREDUCEFORMATIONPATH, false)?
     .visit_field::<i64>("MinimumPositionGap", Self::VT_MINIMUMPOSITIONGAP, false)?
     .visit_field::<bool>("CanUseObstacleOfKneelMotion", Self::VT_CANUSEOBSTACLEOFKNEELMOTION, false)?
     .visit_field::<bool>("CanUseObstacleOfStandMotion", Self::VT_CANUSEOBSTACLEOFSTANDMOTION, false)?
     .visit_field::<bool>("HasTargetSwitchingMotion", Self::VT_HASTARGETSWITCHINGMOTION, false)?
     .finish();
    Ok(())
  }
}
pub struct CharacterAIExcelArgs {
    pub Id: i64,
    pub EngageType: EngageType,
    pub Positioning: PositioningType,
    pub CheckCanUseAutoSkill: bool,
    pub DistanceReduceRatioObstaclePath: i64,
    pub DistanceReduceObstaclePath: i64,
    pub DistanceReduceRatioFormationPath: i64,
    pub DistanceReduceFormationPath: i64,
    pub MinimumPositionGap: i64,
    pub CanUseObstacleOfKneelMotion: bool,
    pub CanUseObstacleOfStandMotion: bool,
    pub HasTargetSwitchingMotion: bool,
}
impl<'a> Default for CharacterAIExcelArgs {
  #[inline]
  fn default() -> Self {
    CharacterAIExcelArgs {
      Id: 0,
      EngageType: EngageType::SearchAndMove,
      Positioning: PositioningType::CloseToObstacle,
      CheckCanUseAutoSkill: false,
      DistanceReduceRatioObstaclePath: 0,
      DistanceReduceObstaclePath: 0,
      DistanceReduceRatioFormationPath: 0,
      DistanceReduceFormationPath: 0,
      MinimumPositionGap: 0,
      CanUseObstacleOfKneelMotion: false,
      CanUseObstacleOfStandMotion: false,
      HasTargetSwitchingMotion: false,
    }
  }
}

impl Serialize for CharacterAIExcel<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("CharacterAIExcel", 12)?;
      s.serialize_field("Id", &self.Id())?;
      s.serialize_field("EngageType", &self.EngageType())?;
      s.serialize_field("Positioning", &self.Positioning())?;
      s.serialize_field("CheckCanUseAutoSkill", &self.CheckCanUseAutoSkill())?;
      s.serialize_field("DistanceReduceRatioObstaclePath", &self.DistanceReduceRatioObstaclePath())?;
      s.serialize_field("DistanceReduceObstaclePath", &self.DistanceReduceObstaclePath())?;
      s.serialize_field("DistanceReduceRatioFormationPath", &self.DistanceReduceRatioFormationPath())?;
      s.serialize_field("DistanceReduceFormationPath", &self.DistanceReduceFormationPath())?;
      s.serialize_field("MinimumPositionGap", &self.MinimumPositionGap())?;
      s.serialize_field("CanUseObstacleOfKneelMotion", &self.CanUseObstacleOfKneelMotion())?;
      s.serialize_field("CanUseObstacleOfStandMotion", &self.CanUseObstacleOfStandMotion())?;
      s.serialize_field("HasTargetSwitchingMotion", &self.HasTargetSwitchingMotion())?;
    s.end()
  }
}

pub struct CharacterAIExcelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CharacterAIExcelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_Id(&mut self, Id: i64) {
    self.fbb_.push_slot::<i64>(CharacterAIExcel::VT_ID, Id, 0);
  }
  #[inline]
  pub fn add_EngageType(&mut self, EngageType: EngageType) {
    self.fbb_.push_slot::<EngageType>(CharacterAIExcel::VT_ENGAGETYPE, EngageType, EngageType::SearchAndMove);
  }
  #[inline]
  pub fn add_Positioning(&mut self, Positioning: PositioningType) {
    self.fbb_.push_slot::<PositioningType>(CharacterAIExcel::VT_POSITIONING, Positioning, PositioningType::CloseToObstacle);
  }
  #[inline]
  pub fn add_CheckCanUseAutoSkill(&mut self, CheckCanUseAutoSkill: bool) {
    self.fbb_.push_slot::<bool>(CharacterAIExcel::VT_CHECKCANUSEAUTOSKILL, CheckCanUseAutoSkill, false);
  }
  #[inline]
  pub fn add_DistanceReduceRatioObstaclePath(&mut self, DistanceReduceRatioObstaclePath: i64) {
    self.fbb_.push_slot::<i64>(CharacterAIExcel::VT_DISTANCEREDUCERATIOOBSTACLEPATH, DistanceReduceRatioObstaclePath, 0);
  }
  #[inline]
  pub fn add_DistanceReduceObstaclePath(&mut self, DistanceReduceObstaclePath: i64) {
    self.fbb_.push_slot::<i64>(CharacterAIExcel::VT_DISTANCEREDUCEOBSTACLEPATH, DistanceReduceObstaclePath, 0);
  }
  #[inline]
  pub fn add_DistanceReduceRatioFormationPath(&mut self, DistanceReduceRatioFormationPath: i64) {
    self.fbb_.push_slot::<i64>(CharacterAIExcel::VT_DISTANCEREDUCERATIOFORMATIONPATH, DistanceReduceRatioFormationPath, 0);
  }
  #[inline]
  pub fn add_DistanceReduceFormationPath(&mut self, DistanceReduceFormationPath: i64) {
    self.fbb_.push_slot::<i64>(CharacterAIExcel::VT_DISTANCEREDUCEFORMATIONPATH, DistanceReduceFormationPath, 0);
  }
  #[inline]
  pub fn add_MinimumPositionGap(&mut self, MinimumPositionGap: i64) {
    self.fbb_.push_slot::<i64>(CharacterAIExcel::VT_MINIMUMPOSITIONGAP, MinimumPositionGap, 0);
  }
  #[inline]
  pub fn add_CanUseObstacleOfKneelMotion(&mut self, CanUseObstacleOfKneelMotion: bool) {
    self.fbb_.push_slot::<bool>(CharacterAIExcel::VT_CANUSEOBSTACLEOFKNEELMOTION, CanUseObstacleOfKneelMotion, false);
  }
  #[inline]
  pub fn add_CanUseObstacleOfStandMotion(&mut self, CanUseObstacleOfStandMotion: bool) {
    self.fbb_.push_slot::<bool>(CharacterAIExcel::VT_CANUSEOBSTACLEOFSTANDMOTION, CanUseObstacleOfStandMotion, false);
  }
  #[inline]
  pub fn add_HasTargetSwitchingMotion(&mut self, HasTargetSwitchingMotion: bool) {
    self.fbb_.push_slot::<bool>(CharacterAIExcel::VT_HASTARGETSWITCHINGMOTION, HasTargetSwitchingMotion, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CharacterAIExcelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CharacterAIExcelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CharacterAIExcel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CharacterAIExcel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CharacterAIExcel");
      ds.field("Id", &self.Id());
      ds.field("EngageType", &self.EngageType());
      ds.field("Positioning", &self.Positioning());
      ds.field("CheckCanUseAutoSkill", &self.CheckCanUseAutoSkill());
      ds.field("DistanceReduceRatioObstaclePath", &self.DistanceReduceRatioObstaclePath());
      ds.field("DistanceReduceObstaclePath", &self.DistanceReduceObstaclePath());
      ds.field("DistanceReduceRatioFormationPath", &self.DistanceReduceRatioFormationPath());
      ds.field("DistanceReduceFormationPath", &self.DistanceReduceFormationPath());
      ds.field("MinimumPositionGap", &self.MinimumPositionGap());
      ds.field("CanUseObstacleOfKneelMotion", &self.CanUseObstacleOfKneelMotion());
      ds.field("CanUseObstacleOfStandMotion", &self.CanUseObstacleOfStandMotion());
      ds.field("HasTargetSwitchingMotion", &self.HasTargetSwitchingMotion());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CharacterAIExcelT {
  pub Id: i64,
  pub EngageType: EngageType,
  pub Positioning: PositioningType,
  pub CheckCanUseAutoSkill: bool,
  pub DistanceReduceRatioObstaclePath: i64,
  pub DistanceReduceObstaclePath: i64,
  pub DistanceReduceRatioFormationPath: i64,
  pub DistanceReduceFormationPath: i64,
  pub MinimumPositionGap: i64,
  pub CanUseObstacleOfKneelMotion: bool,
  pub CanUseObstacleOfStandMotion: bool,
  pub HasTargetSwitchingMotion: bool,
}
impl Default for CharacterAIExcelT {
  fn default() -> Self {
    Self {
      Id: 0,
      EngageType: EngageType::SearchAndMove,
      Positioning: PositioningType::CloseToObstacle,
      CheckCanUseAutoSkill: false,
      DistanceReduceRatioObstaclePath: 0,
      DistanceReduceObstaclePath: 0,
      DistanceReduceRatioFormationPath: 0,
      DistanceReduceFormationPath: 0,
      MinimumPositionGap: 0,
      CanUseObstacleOfKneelMotion: false,
      CanUseObstacleOfStandMotion: false,
      HasTargetSwitchingMotion: false,
    }
  }
}
impl CharacterAIExcelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CharacterAIExcel<'b>> {
    let Id = self.Id;
    let EngageType = self.EngageType;
    let Positioning = self.Positioning;
    let CheckCanUseAutoSkill = self.CheckCanUseAutoSkill;
    let DistanceReduceRatioObstaclePath = self.DistanceReduceRatioObstaclePath;
    let DistanceReduceObstaclePath = self.DistanceReduceObstaclePath;
    let DistanceReduceRatioFormationPath = self.DistanceReduceRatioFormationPath;
    let DistanceReduceFormationPath = self.DistanceReduceFormationPath;
    let MinimumPositionGap = self.MinimumPositionGap;
    let CanUseObstacleOfKneelMotion = self.CanUseObstacleOfKneelMotion;
    let CanUseObstacleOfStandMotion = self.CanUseObstacleOfStandMotion;
    let HasTargetSwitchingMotion = self.HasTargetSwitchingMotion;
    CharacterAIExcel::create(_fbb, &CharacterAIExcelArgs{
      Id,
      EngageType,
      Positioning,
      CheckCanUseAutoSkill,
      DistanceReduceRatioObstaclePath,
      DistanceReduceObstaclePath,
      DistanceReduceRatioFormationPath,
      DistanceReduceFormationPath,
      MinimumPositionGap,
      CanUseObstacleOfKneelMotion,
      CanUseObstacleOfStandMotion,
      HasTargetSwitchingMotion,
    })
  }
}
