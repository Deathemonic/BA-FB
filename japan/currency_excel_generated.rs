// automatically generated by the FlatBuffers compiler, do not modify
// @generated
#![allow(unused_imports, dead_code)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum CurrencyExcelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CurrencyExcel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CurrencyExcel<'a> {
  type Inner = CurrencyExcel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CurrencyExcel<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_LOCALIZEETCID: flatbuffers::VOffsetT = 6;
  pub const VT_CURRENCYTYPE: flatbuffers::VOffsetT = 8;
  pub const VT_CURRENCYNAME: flatbuffers::VOffsetT = 10;
  pub const VT_ICON: flatbuffers::VOffsetT = 12;
  pub const VT_RARITY: flatbuffers::VOffsetT = 14;
  pub const VT_AUTOCHARGEMSC: flatbuffers::VOffsetT = 16;
  pub const VT_AUTOCHARGEAMOUNT: flatbuffers::VOffsetT = 18;
  pub const VT_CURRENCYOVERCHARGETYPE: flatbuffers::VOffsetT = 20;
  pub const VT_CURRENCYADDITIONALCHARGETYPE: flatbuffers::VOffsetT = 22;
  pub const VT_CHARGELIMIT: flatbuffers::VOffsetT = 24;
  pub const VT_OVERCHARGELIMIT: flatbuffers::VOffsetT = 26;
  pub const VT_SPRITENAME: flatbuffers::VOffsetT = 28;
  pub const VT_DAILYREFILLTYPE: flatbuffers::VOffsetT = 30;
  pub const VT_DAILYREFILLAMOUNT: flatbuffers::VOffsetT = 32;
  pub const VT_DAILYREFILLTIME: flatbuffers::VOffsetT = 34;
  pub const VT_EXPIRATIONDATETIME: flatbuffers::VOffsetT = 36;
  pub const VT_EXPIRATIONNOTIFYDATEIN: flatbuffers::VOffsetT = 38;
  pub const VT_EXPIRYCHANGEPARCELTYPE: flatbuffers::VOffsetT = 40;
  pub const VT_EXPIRYCHANGEID: flatbuffers::VOffsetT = 42;
  pub const VT_EXPIRYCHANGEAMOUNT: flatbuffers::VOffsetT = 44;
  pub const VT_RESETTYPE: flatbuffers::VOffsetT = 46;
  pub const VT_RESETAMOUNT: flatbuffers::VOffsetT = 48;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CurrencyExcel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CurrencyExcelArgs<'args>
  ) -> flatbuffers::WIPOffset<CurrencyExcel<'bldr>> {
    let mut builder = CurrencyExcelBuilder::new(_fbb);
    let key = table_encryption_service::create_key(b"Currency");
      let x = args.ResetAmount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_ResetAmount(x);
      let x = args.ExpiryChangeAmount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_ExpiryChangeAmount(x);
      let x = args.ExpiryChangeId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_ExpiryChangeId(x);
      let x = args.DailyRefillAmount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_DailyRefillAmount(x);
      let x = args.OverChargeLimit;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_OverChargeLimit(x);
      let x = args.ChargeLimit;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_ChargeLimit(x);
      let x = args.ID;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_ID(x);
      let x = args.ResetType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_ResetType(x);
      let x = args.ExpiryChangeParcelType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_ExpiryChangeParcelType(x);
      let x = args.ExpirationNotifyDateIn;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_ExpirationNotifyDateIn(x);
      if let Some(x) = args.ExpirationDateTime {
        builder.add_ExpirationDateTime(x);
      }
      if let Some(x) = args.DailyRefillTime {
        builder.add_DailyRefillTime(x);
      }
      let x = args.DailyRefillType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_DailyRefillType(x);
      if let Some(x) = args.SpriteName {
        builder.add_SpriteName(x);
      }
      let x = args.CurrencyAdditionalChargeType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_CurrencyAdditionalChargeType(x);
      let x = args.CurrencyOverChargeType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_CurrencyOverChargeType(x);
      let x = args.AutoChargeAmount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_AutoChargeAmount(x);
      let x = args.AutoChargeMsc;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_AutoChargeMsc(x);
      let x = args.Rarity;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_Rarity(x);
      if let Some(x) = args.Icon {
        builder.add_Icon(x);
      }
      if let Some(x) = args.CurrencyName {
        builder.add_CurrencyName(x);
      }
      let x = args.CurrencyType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_CurrencyType(x);
      let x = args.LocalizeEtcId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_uint(x, &key) } else { x };
      builder.add_LocalizeEtcId(x);
    builder.finish()
  }

  pub fn unpack(&self) -> CurrencyExcelT {
    let key = table_encryption_service::create_key(b"Currency");
      let ID = self.ID();
      let LocalizeEtcId = self.LocalizeEtcId();
      let CurrencyType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.CurrencyType(), &key)
      } else {
        self.CurrencyType()
      };
    let CurrencyName = self.CurrencyName().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let Icon = self.Icon().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let Rarity = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.Rarity(), &key)
      } else {
        self.Rarity()
      };
      let AutoChargeMsc = self.AutoChargeMsc();
      let AutoChargeAmount = self.AutoChargeAmount();
      let CurrencyOverChargeType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.CurrencyOverChargeType(), &key)
      } else {
        self.CurrencyOverChargeType()
      };
      let CurrencyAdditionalChargeType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.CurrencyAdditionalChargeType(), &key)
      } else {
        self.CurrencyAdditionalChargeType()
      };
      let ChargeLimit = self.ChargeLimit();
      let OverChargeLimit = self.OverChargeLimit();
    let SpriteName = self.SpriteName().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let DailyRefillType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.DailyRefillType(), &key)
      } else {
        self.DailyRefillType()
      };
      let DailyRefillAmount = self.DailyRefillAmount();
    let DailyRefillTime = self.DailyRefillTime().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_long(*val, &key) } else { *val }).collect()
    });
    let ExpirationDateTime = self.ExpirationDateTime().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let ExpirationNotifyDateIn = self.ExpirationNotifyDateIn();
      let ExpiryChangeParcelType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.ExpiryChangeParcelType(), &key)
      } else {
        self.ExpiryChangeParcelType()
      };
      let ExpiryChangeId = self.ExpiryChangeId();
      let ExpiryChangeAmount = self.ExpiryChangeAmount();
      let ResetType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.ResetType(), &key)
      } else {
        self.ResetType()
      };
      let ResetAmount = self.ResetAmount();
    CurrencyExcelT {
      ID,
      LocalizeEtcId,
      CurrencyType,
      CurrencyName,
      Icon,
      Rarity,
      AutoChargeMsc,
      AutoChargeAmount,
      CurrencyOverChargeType,
      CurrencyAdditionalChargeType,
      ChargeLimit,
      OverChargeLimit,
      SpriteName,
      DailyRefillType,
      DailyRefillAmount,
      DailyRefillTime,
      ExpirationDateTime,
      ExpirationNotifyDateIn,
      ExpiryChangeParcelType,
      ExpiryChangeId,
      ExpiryChangeAmount,
      ResetType,
      ResetAmount,
    }
  }

  #[inline]
  pub fn ID(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CurrencyExcel::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn LocalizeEtcId(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(CurrencyExcel::VT_LOCALIZEETCID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CurrencyType(&self) -> CurrencyTypes {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<CurrencyTypes>(CurrencyExcel::VT_CURRENCYTYPE, Some(CurrencyTypes::Invalid)).unwrap()}
  }
  #[inline]
  pub fn CurrencyName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CurrencyExcel::VT_CURRENCYNAME, None)}
  }
  #[inline]
  pub fn Icon(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CurrencyExcel::VT_ICON, None)}
  }
  #[inline]
  pub fn Rarity(&self) -> Rarity {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Rarity>(CurrencyExcel::VT_RARITY, Some(Rarity::N)).unwrap()}
  }
  #[inline]
  pub fn AutoChargeMsc(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CurrencyExcel::VT_AUTOCHARGEMSC, Some(0)).unwrap()}
  }
  #[inline]
  pub fn AutoChargeAmount(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CurrencyExcel::VT_AUTOCHARGEAMOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CurrencyOverChargeType(&self) -> CurrencyOverChargeType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<CurrencyOverChargeType>(CurrencyExcel::VT_CURRENCYOVERCHARGETYPE, Some(CurrencyOverChargeType::CanNotCharge)).unwrap()}
  }
  #[inline]
  pub fn CurrencyAdditionalChargeType(&self) -> CurrencyAdditionalChargeType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<CurrencyAdditionalChargeType>(CurrencyExcel::VT_CURRENCYADDITIONALCHARGETYPE, Some(CurrencyAdditionalChargeType::EnableAutoChargeOverLimit)).unwrap()}
  }
  #[inline]
  pub fn ChargeLimit(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CurrencyExcel::VT_CHARGELIMIT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn OverChargeLimit(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CurrencyExcel::VT_OVERCHARGELIMIT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn SpriteName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CurrencyExcel::VT_SPRITENAME, None)}
  }
  #[inline]
  pub fn DailyRefillType(&self) -> DailyRefillType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DailyRefillType>(CurrencyExcel::VT_DAILYREFILLTYPE, Some(DailyRefillType::None)).unwrap()}
  }
  #[inline]
  pub fn DailyRefillAmount(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CurrencyExcel::VT_DAILYREFILLAMOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn DailyRefillTime(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(CurrencyExcel::VT_DAILYREFILLTIME, None)}
  }
  #[inline]
  pub fn ExpirationDateTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CurrencyExcel::VT_EXPIRATIONDATETIME, None)}
  }
  #[inline]
  pub fn ExpirationNotifyDateIn(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CurrencyExcel::VT_EXPIRATIONNOTIFYDATEIN, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ExpiryChangeParcelType(&self) -> ParcelType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ParcelType>(CurrencyExcel::VT_EXPIRYCHANGEPARCELTYPE, Some(ParcelType::None)).unwrap()}
  }
  #[inline]
  pub fn ExpiryChangeId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CurrencyExcel::VT_EXPIRYCHANGEID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ExpiryChangeAmount(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CurrencyExcel::VT_EXPIRYCHANGEAMOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ResetType(&self) -> PeriodType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<PeriodType>(CurrencyExcel::VT_RESETTYPE, Some(PeriodType::None)).unwrap()}
  }
  #[inline]
  pub fn ResetAmount(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CurrencyExcel::VT_RESETAMOUNT, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for CurrencyExcel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("ID", Self::VT_ID, false)?
     .visit_field::<u32>("LocalizeEtcId", Self::VT_LOCALIZEETCID, false)?
     .visit_field::<CurrencyTypes>("CurrencyType", Self::VT_CURRENCYTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CurrencyName", Self::VT_CURRENCYNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("Icon", Self::VT_ICON, false)?
     .visit_field::<Rarity>("Rarity", Self::VT_RARITY, false)?
     .visit_field::<i32>("AutoChargeMsc", Self::VT_AUTOCHARGEMSC, false)?
     .visit_field::<i32>("AutoChargeAmount", Self::VT_AUTOCHARGEAMOUNT, false)?
     .visit_field::<CurrencyOverChargeType>("CurrencyOverChargeType", Self::VT_CURRENCYOVERCHARGETYPE, false)?
     .visit_field::<CurrencyAdditionalChargeType>("CurrencyAdditionalChargeType", Self::VT_CURRENCYADDITIONALCHARGETYPE, false)?
     .visit_field::<i64>("ChargeLimit", Self::VT_CHARGELIMIT, false)?
     .visit_field::<i64>("OverChargeLimit", Self::VT_OVERCHARGELIMIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SpriteName", Self::VT_SPRITENAME, false)?
     .visit_field::<DailyRefillType>("DailyRefillType", Self::VT_DAILYREFILLTYPE, false)?
     .visit_field::<i64>("DailyRefillAmount", Self::VT_DAILYREFILLAMOUNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("DailyRefillTime", Self::VT_DAILYREFILLTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ExpirationDateTime", Self::VT_EXPIRATIONDATETIME, false)?
     .visit_field::<i32>("ExpirationNotifyDateIn", Self::VT_EXPIRATIONNOTIFYDATEIN, false)?
     .visit_field::<ParcelType>("ExpiryChangeParcelType", Self::VT_EXPIRYCHANGEPARCELTYPE, false)?
     .visit_field::<i64>("ExpiryChangeId", Self::VT_EXPIRYCHANGEID, false)?
     .visit_field::<i64>("ExpiryChangeAmount", Self::VT_EXPIRYCHANGEAMOUNT, false)?
     .visit_field::<PeriodType>("ResetType", Self::VT_RESETTYPE, false)?
     .visit_field::<i64>("ResetAmount", Self::VT_RESETAMOUNT, false)?
     .finish();
    Ok(())
  }
}
pub struct CurrencyExcelArgs<'a> {
    pub ID: i64,
    pub LocalizeEtcId: u32,
    pub CurrencyType: CurrencyTypes,
    pub CurrencyName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub Icon: Option<flatbuffers::WIPOffset<&'a str>>,
    pub Rarity: Rarity,
    pub AutoChargeMsc: i32,
    pub AutoChargeAmount: i32,
    pub CurrencyOverChargeType: CurrencyOverChargeType,
    pub CurrencyAdditionalChargeType: CurrencyAdditionalChargeType,
    pub ChargeLimit: i64,
    pub OverChargeLimit: i64,
    pub SpriteName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DailyRefillType: DailyRefillType,
    pub DailyRefillAmount: i64,
    pub DailyRefillTime: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub ExpirationDateTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ExpirationNotifyDateIn: i32,
    pub ExpiryChangeParcelType: ParcelType,
    pub ExpiryChangeId: i64,
    pub ExpiryChangeAmount: i64,
    pub ResetType: PeriodType,
    pub ResetAmount: i64,
}
impl<'a> Default for CurrencyExcelArgs<'a> {
  #[inline]
  fn default() -> Self {
    CurrencyExcelArgs {
      ID: 0,
      LocalizeEtcId: 0,
      CurrencyType: CurrencyTypes::Invalid,
      CurrencyName: None,
      Icon: None,
      Rarity: Rarity::N,
      AutoChargeMsc: 0,
      AutoChargeAmount: 0,
      CurrencyOverChargeType: CurrencyOverChargeType::CanNotCharge,
      CurrencyAdditionalChargeType: CurrencyAdditionalChargeType::EnableAutoChargeOverLimit,
      ChargeLimit: 0,
      OverChargeLimit: 0,
      SpriteName: None,
      DailyRefillType: DailyRefillType::None,
      DailyRefillAmount: 0,
      DailyRefillTime: None,
      ExpirationDateTime: None,
      ExpirationNotifyDateIn: 0,
      ExpiryChangeParcelType: ParcelType::None,
      ExpiryChangeId: 0,
      ExpiryChangeAmount: 0,
      ResetType: PeriodType::None,
      ResetAmount: 0,
    }
  }
}

impl Serialize for CurrencyExcel<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("CurrencyExcel", 23)?;
      s.serialize_field("ID", &self.ID())?;
      s.serialize_field("LocalizeEtcId", &self.LocalizeEtcId())?;
      s.serialize_field("CurrencyType", &self.CurrencyType())?;
      if let Some(f) = self.CurrencyName() {
        s.serialize_field("CurrencyName", &f)?;
      } else {
        s.skip_field("CurrencyName")?;
      }
      if let Some(f) = self.Icon() {
        s.serialize_field("Icon", &f)?;
      } else {
        s.skip_field("Icon")?;
      }
      s.serialize_field("Rarity", &self.Rarity())?;
      s.serialize_field("AutoChargeMsc", &self.AutoChargeMsc())?;
      s.serialize_field("AutoChargeAmount", &self.AutoChargeAmount())?;
      s.serialize_field("CurrencyOverChargeType", &self.CurrencyOverChargeType())?;
      s.serialize_field("CurrencyAdditionalChargeType", &self.CurrencyAdditionalChargeType())?;
      s.serialize_field("ChargeLimit", &self.ChargeLimit())?;
      s.serialize_field("OverChargeLimit", &self.OverChargeLimit())?;
      if let Some(f) = self.SpriteName() {
        s.serialize_field("SpriteName", &f)?;
      } else {
        s.skip_field("SpriteName")?;
      }
      s.serialize_field("DailyRefillType", &self.DailyRefillType())?;
      s.serialize_field("DailyRefillAmount", &self.DailyRefillAmount())?;
      if let Some(f) = self.DailyRefillTime() {
        s.serialize_field("DailyRefillTime", &f)?;
      } else {
        s.skip_field("DailyRefillTime")?;
      }
      if let Some(f) = self.ExpirationDateTime() {
        s.serialize_field("ExpirationDateTime", &f)?;
      } else {
        s.skip_field("ExpirationDateTime")?;
      }
      s.serialize_field("ExpirationNotifyDateIn", &self.ExpirationNotifyDateIn())?;
      s.serialize_field("ExpiryChangeParcelType", &self.ExpiryChangeParcelType())?;
      s.serialize_field("ExpiryChangeId", &self.ExpiryChangeId())?;
      s.serialize_field("ExpiryChangeAmount", &self.ExpiryChangeAmount())?;
      s.serialize_field("ResetType", &self.ResetType())?;
      s.serialize_field("ResetAmount", &self.ResetAmount())?;
    s.end()
  }
}

pub struct CurrencyExcelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CurrencyExcelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ID(&mut self, ID: i64) {
    self.fbb_.push_slot::<i64>(CurrencyExcel::VT_ID, ID, 0);
  }
  #[inline]
  pub fn add_LocalizeEtcId(&mut self, LocalizeEtcId: u32) {
    self.fbb_.push_slot::<u32>(CurrencyExcel::VT_LOCALIZEETCID, LocalizeEtcId, 0);
  }
  #[inline]
  pub fn add_CurrencyType(&mut self, CurrencyType: CurrencyTypes) {
    self.fbb_.push_slot::<CurrencyTypes>(CurrencyExcel::VT_CURRENCYTYPE, CurrencyType, CurrencyTypes::Invalid);
  }
  #[inline]
  pub fn add_CurrencyName(&mut self, CurrencyName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CurrencyExcel::VT_CURRENCYNAME, CurrencyName);
  }
  #[inline]
  pub fn add_Icon(&mut self, Icon: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CurrencyExcel::VT_ICON, Icon);
  }
  #[inline]
  pub fn add_Rarity(&mut self, Rarity: Rarity) {
    self.fbb_.push_slot::<Rarity>(CurrencyExcel::VT_RARITY, Rarity, Rarity::N);
  }
  #[inline]
  pub fn add_AutoChargeMsc(&mut self, AutoChargeMsc: i32) {
    self.fbb_.push_slot::<i32>(CurrencyExcel::VT_AUTOCHARGEMSC, AutoChargeMsc, 0);
  }
  #[inline]
  pub fn add_AutoChargeAmount(&mut self, AutoChargeAmount: i32) {
    self.fbb_.push_slot::<i32>(CurrencyExcel::VT_AUTOCHARGEAMOUNT, AutoChargeAmount, 0);
  }
  #[inline]
  pub fn add_CurrencyOverChargeType(&mut self, CurrencyOverChargeType: CurrencyOverChargeType) {
    self.fbb_.push_slot::<CurrencyOverChargeType>(CurrencyExcel::VT_CURRENCYOVERCHARGETYPE, CurrencyOverChargeType, CurrencyOverChargeType::CanNotCharge);
  }
  #[inline]
  pub fn add_CurrencyAdditionalChargeType(&mut self, CurrencyAdditionalChargeType: CurrencyAdditionalChargeType) {
    self.fbb_.push_slot::<CurrencyAdditionalChargeType>(CurrencyExcel::VT_CURRENCYADDITIONALCHARGETYPE, CurrencyAdditionalChargeType, CurrencyAdditionalChargeType::EnableAutoChargeOverLimit);
  }
  #[inline]
  pub fn add_ChargeLimit(&mut self, ChargeLimit: i64) {
    self.fbb_.push_slot::<i64>(CurrencyExcel::VT_CHARGELIMIT, ChargeLimit, 0);
  }
  #[inline]
  pub fn add_OverChargeLimit(&mut self, OverChargeLimit: i64) {
    self.fbb_.push_slot::<i64>(CurrencyExcel::VT_OVERCHARGELIMIT, OverChargeLimit, 0);
  }
  #[inline]
  pub fn add_SpriteName(&mut self, SpriteName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CurrencyExcel::VT_SPRITENAME, SpriteName);
  }
  #[inline]
  pub fn add_DailyRefillType(&mut self, DailyRefillType: DailyRefillType) {
    self.fbb_.push_slot::<DailyRefillType>(CurrencyExcel::VT_DAILYREFILLTYPE, DailyRefillType, DailyRefillType::None);
  }
  #[inline]
  pub fn add_DailyRefillAmount(&mut self, DailyRefillAmount: i64) {
    self.fbb_.push_slot::<i64>(CurrencyExcel::VT_DAILYREFILLAMOUNT, DailyRefillAmount, 0);
  }
  #[inline]
  pub fn add_DailyRefillTime(&mut self, DailyRefillTime: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CurrencyExcel::VT_DAILYREFILLTIME, DailyRefillTime);
  }
  #[inline]
  pub fn add_ExpirationDateTime(&mut self, ExpirationDateTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CurrencyExcel::VT_EXPIRATIONDATETIME, ExpirationDateTime);
  }
  #[inline]
  pub fn add_ExpirationNotifyDateIn(&mut self, ExpirationNotifyDateIn: i32) {
    self.fbb_.push_slot::<i32>(CurrencyExcel::VT_EXPIRATIONNOTIFYDATEIN, ExpirationNotifyDateIn, 0);
  }
  #[inline]
  pub fn add_ExpiryChangeParcelType(&mut self, ExpiryChangeParcelType: ParcelType) {
    self.fbb_.push_slot::<ParcelType>(CurrencyExcel::VT_EXPIRYCHANGEPARCELTYPE, ExpiryChangeParcelType, ParcelType::None);
  }
  #[inline]
  pub fn add_ExpiryChangeId(&mut self, ExpiryChangeId: i64) {
    self.fbb_.push_slot::<i64>(CurrencyExcel::VT_EXPIRYCHANGEID, ExpiryChangeId, 0);
  }
  #[inline]
  pub fn add_ExpiryChangeAmount(&mut self, ExpiryChangeAmount: i64) {
    self.fbb_.push_slot::<i64>(CurrencyExcel::VT_EXPIRYCHANGEAMOUNT, ExpiryChangeAmount, 0);
  }
  #[inline]
  pub fn add_ResetType(&mut self, ResetType: PeriodType) {
    self.fbb_.push_slot::<PeriodType>(CurrencyExcel::VT_RESETTYPE, ResetType, PeriodType::None);
  }
  #[inline]
  pub fn add_ResetAmount(&mut self, ResetAmount: i64) {
    self.fbb_.push_slot::<i64>(CurrencyExcel::VT_RESETAMOUNT, ResetAmount, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CurrencyExcelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CurrencyExcelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CurrencyExcel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CurrencyExcel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CurrencyExcel");
      ds.field("ID", &self.ID());
      ds.field("LocalizeEtcId", &self.LocalizeEtcId());
      ds.field("CurrencyType", &self.CurrencyType());
      ds.field("CurrencyName", &self.CurrencyName());
      ds.field("Icon", &self.Icon());
      ds.field("Rarity", &self.Rarity());
      ds.field("AutoChargeMsc", &self.AutoChargeMsc());
      ds.field("AutoChargeAmount", &self.AutoChargeAmount());
      ds.field("CurrencyOverChargeType", &self.CurrencyOverChargeType());
      ds.field("CurrencyAdditionalChargeType", &self.CurrencyAdditionalChargeType());
      ds.field("ChargeLimit", &self.ChargeLimit());
      ds.field("OverChargeLimit", &self.OverChargeLimit());
      ds.field("SpriteName", &self.SpriteName());
      ds.field("DailyRefillType", &self.DailyRefillType());
      ds.field("DailyRefillAmount", &self.DailyRefillAmount());
      ds.field("DailyRefillTime", &self.DailyRefillTime());
      ds.field("ExpirationDateTime", &self.ExpirationDateTime());
      ds.field("ExpirationNotifyDateIn", &self.ExpirationNotifyDateIn());
      ds.field("ExpiryChangeParcelType", &self.ExpiryChangeParcelType());
      ds.field("ExpiryChangeId", &self.ExpiryChangeId());
      ds.field("ExpiryChangeAmount", &self.ExpiryChangeAmount());
      ds.field("ResetType", &self.ResetType());
      ds.field("ResetAmount", &self.ResetAmount());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CurrencyExcelT {
  pub ID: i64,
  pub LocalizeEtcId: u32,
  pub CurrencyType: CurrencyTypes,
  pub CurrencyName: Option<String>,
  pub Icon: Option<String>,
  pub Rarity: Rarity,
  pub AutoChargeMsc: i32,
  pub AutoChargeAmount: i32,
  pub CurrencyOverChargeType: CurrencyOverChargeType,
  pub CurrencyAdditionalChargeType: CurrencyAdditionalChargeType,
  pub ChargeLimit: i64,
  pub OverChargeLimit: i64,
  pub SpriteName: Option<String>,
  pub DailyRefillType: DailyRefillType,
  pub DailyRefillAmount: i64,
  pub DailyRefillTime: Option<Vec<i64>>,
  pub ExpirationDateTime: Option<String>,
  pub ExpirationNotifyDateIn: i32,
  pub ExpiryChangeParcelType: ParcelType,
  pub ExpiryChangeId: i64,
  pub ExpiryChangeAmount: i64,
  pub ResetType: PeriodType,
  pub ResetAmount: i64,
}
impl Default for CurrencyExcelT {
  fn default() -> Self {
    Self {
      ID: 0,
      LocalizeEtcId: 0,
      CurrencyType: CurrencyTypes::Invalid,
      CurrencyName: None,
      Icon: None,
      Rarity: Rarity::N,
      AutoChargeMsc: 0,
      AutoChargeAmount: 0,
      CurrencyOverChargeType: CurrencyOverChargeType::CanNotCharge,
      CurrencyAdditionalChargeType: CurrencyAdditionalChargeType::EnableAutoChargeOverLimit,
      ChargeLimit: 0,
      OverChargeLimit: 0,
      SpriteName: None,
      DailyRefillType: DailyRefillType::None,
      DailyRefillAmount: 0,
      DailyRefillTime: None,
      ExpirationDateTime: None,
      ExpirationNotifyDateIn: 0,
      ExpiryChangeParcelType: ParcelType::None,
      ExpiryChangeId: 0,
      ExpiryChangeAmount: 0,
      ResetType: PeriodType::None,
      ResetAmount: 0,
    }
  }
}
impl CurrencyExcelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CurrencyExcel<'b>> {
    let ID = self.ID;
    let LocalizeEtcId = self.LocalizeEtcId;
    let CurrencyType = self.CurrencyType;
    let CurrencyName = self.CurrencyName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let Icon = self.Icon.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let Rarity = self.Rarity;
    let AutoChargeMsc = self.AutoChargeMsc;
    let AutoChargeAmount = self.AutoChargeAmount;
    let CurrencyOverChargeType = self.CurrencyOverChargeType;
    let CurrencyAdditionalChargeType = self.CurrencyAdditionalChargeType;
    let ChargeLimit = self.ChargeLimit;
    let OverChargeLimit = self.OverChargeLimit;
    let SpriteName = self.SpriteName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DailyRefillType = self.DailyRefillType;
    let DailyRefillAmount = self.DailyRefillAmount;
    let DailyRefillTime = self.DailyRefillTime.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let ExpirationDateTime = self.ExpirationDateTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ExpirationNotifyDateIn = self.ExpirationNotifyDateIn;
    let ExpiryChangeParcelType = self.ExpiryChangeParcelType;
    let ExpiryChangeId = self.ExpiryChangeId;
    let ExpiryChangeAmount = self.ExpiryChangeAmount;
    let ResetType = self.ResetType;
    let ResetAmount = self.ResetAmount;
    CurrencyExcel::create(_fbb, &CurrencyExcelArgs{
      ID,
      LocalizeEtcId,
      CurrencyType,
      CurrencyName,
      Icon,
      Rarity,
      AutoChargeMsc,
      AutoChargeAmount,
      CurrencyOverChargeType,
      CurrencyAdditionalChargeType,
      ChargeLimit,
      OverChargeLimit,
      SpriteName,
      DailyRefillType,
      DailyRefillAmount,
      DailyRefillTime,
      ExpirationDateTime,
      ExpirationNotifyDateIn,
      ExpiryChangeParcelType,
      ExpiryChangeId,
      ExpiryChangeAmount,
      ResetType,
      ResetAmount,
    })
  }
}
