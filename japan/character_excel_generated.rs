// automatically generated by the FlatBuffers compiler, do not modify
// @generated
#![allow(unused_imports, dead_code)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum CharacterExcelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CharacterExcel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CharacterExcel<'a> {
  type Inner = CharacterExcel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CharacterExcel<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_DEVNAME: flatbuffers::VOffsetT = 6;
  pub const VT_COSTUMEGROUPID: flatbuffers::VOffsetT = 8;
  pub const VT_ISPLAYABLE: flatbuffers::VOffsetT = 10;
  pub const VT_PRODUCTIONSTEP: flatbuffers::VOffsetT = 12;
  pub const VT_COLLECTIONVISIBLE: flatbuffers::VOffsetT = 14;
  pub const VT_RELEASEDATE: flatbuffers::VOffsetT = 16;
  pub const VT_COLLECTIONVISIBLESTARTDATE: flatbuffers::VOffsetT = 18;
  pub const VT_COLLECTIONVISIBLEENDDATE: flatbuffers::VOffsetT = 20;
  pub const VT_ISPLAYABLECHARACTER: flatbuffers::VOffsetT = 22;
  pub const VT_LOCALIZEETCID: flatbuffers::VOffsetT = 24;
  pub const VT_RARITY: flatbuffers::VOffsetT = 26;
  pub const VT_ISNPC: flatbuffers::VOffsetT = 28;
  pub const VT_TACTICENTITYTYPE: flatbuffers::VOffsetT = 30;
  pub const VT_CANSURVIVE: flatbuffers::VOffsetT = 32;
  pub const VT_ISDUMMY: flatbuffers::VOffsetT = 34;
  pub const VT_SUBPARTSCOUNT: flatbuffers::VOffsetT = 36;
  pub const VT_TACTICROLE: flatbuffers::VOffsetT = 38;
  pub const VT_WEAPONTYPE: flatbuffers::VOffsetT = 40;
  pub const VT_TACTICRANGE: flatbuffers::VOffsetT = 42;
  pub const VT_BULLETTYPE: flatbuffers::VOffsetT = 44;
  pub const VT_ARMORTYPE: flatbuffers::VOffsetT = 46;
  pub const VT_AIMIKTYPE: flatbuffers::VOffsetT = 48;
  pub const VT_SCHOOL: flatbuffers::VOffsetT = 50;
  pub const VT_CLUB: flatbuffers::VOffsetT = 52;
  pub const VT_DEFAULTSTARGRADE: flatbuffers::VOffsetT = 54;
  pub const VT_MAXSTARGRADE: flatbuffers::VOffsetT = 56;
  pub const VT_STATLEVELUPTYPE: flatbuffers::VOffsetT = 58;
  pub const VT_SQUADTYPE: flatbuffers::VOffsetT = 60;
  pub const VT_JUMPABLE: flatbuffers::VOffsetT = 62;
  pub const VT_PERSONALITYID: flatbuffers::VOffsetT = 64;
  pub const VT_CHARACTERAIID: flatbuffers::VOffsetT = 66;
  pub const VT_EXTERNALBTID: flatbuffers::VOffsetT = 68;
  pub const VT_MAINCOMBATSTYLEID: flatbuffers::VOffsetT = 70;
  pub const VT_COMBATSTYLEINDEX: flatbuffers::VOffsetT = 72;
  pub const VT_SCENARIOCHARACTER: flatbuffers::VOffsetT = 74;
  pub const VT_SPAWNTEMPLATEID: flatbuffers::VOffsetT = 76;
  pub const VT_FAVORLEVELUPTYPE: flatbuffers::VOffsetT = 78;
  pub const VT_EQUIPMENTSLOT: flatbuffers::VOffsetT = 80;
  pub const VT_WEAPONLOCALIZEID: flatbuffers::VOffsetT = 82;
  pub const VT_DISPLAYENEMYINFO: flatbuffers::VOffsetT = 84;
  pub const VT_BODYRADIUS: flatbuffers::VOffsetT = 86;
  pub const VT_RANDOMEFFECTRADIUS: flatbuffers::VOffsetT = 88;
  pub const VT_HPBARHIDE: flatbuffers::VOffsetT = 90;
  pub const VT_HPBARHEIGHT: flatbuffers::VOffsetT = 92;
  pub const VT_HIGHLIGHTFLOATERHEIGHT: flatbuffers::VOffsetT = 94;
  pub const VT_EMOJIOFFSETX: flatbuffers::VOffsetT = 96;
  pub const VT_EMOJIOFFSETY: flatbuffers::VOffsetT = 98;
  pub const VT_MOVESTARTFRAME: flatbuffers::VOffsetT = 100;
  pub const VT_MOVEENDFRAME: flatbuffers::VOffsetT = 102;
  pub const VT_JUMPMOTIONFRAME: flatbuffers::VOffsetT = 104;
  pub const VT_APPEARFRAME: flatbuffers::VOffsetT = 106;
  pub const VT_CANMOVE: flatbuffers::VOffsetT = 108;
  pub const VT_CANFIX: flatbuffers::VOffsetT = 110;
  pub const VT_CANCROWDCONTROL: flatbuffers::VOffsetT = 112;
  pub const VT_CANBATTLEITEMMOVE: flatbuffers::VOffsetT = 114;
  pub const VT_IGNOREOBSTACLE: flatbuffers::VOffsetT = 116;
  pub const VT_ISAIRUNIT: flatbuffers::VOffsetT = 118;
  pub const VT_AIRUNITHEIGHT: flatbuffers::VOffsetT = 120;
  pub const VT_TAGS: flatbuffers::VOffsetT = 122;
  pub const VT_SECRETSTONEITEMID: flatbuffers::VOffsetT = 124;
  pub const VT_SECRETSTONEITEMAMOUNT: flatbuffers::VOffsetT = 126;
  pub const VT_CHARACTERPIECEITEMID: flatbuffers::VOffsetT = 128;
  pub const VT_CHARACTERPIECEITEMAMOUNT: flatbuffers::VOffsetT = 130;
  pub const VT_COMBINERECIPEID: flatbuffers::VOffsetT = 132;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CharacterExcel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CharacterExcelArgs<'args>
  ) -> flatbuffers::WIPOffset<CharacterExcel<'bldr>> {
    let mut builder = CharacterExcelBuilder::new(_fbb);
    let key = table_encryption_service::create_key(b"Character");
      let x = args.CombineRecipeId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_CombineRecipeId(x);
      let x = args.CharacterPieceItemId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_CharacterPieceItemId(x);
      let x = args.SecretStoneItemId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_SecretStoneItemId(x);
      let x = args.AirUnitHeight;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_AirUnitHeight(x);
      let x = args.RandomEffectRadius;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_RandomEffectRadius(x);
      let x = args.bodyRadius;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_bodyRadius(x);
      let x = args.MainCombatStyleId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_MainCombatStyleId(x);
      let x = args.ExternalBTId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_ExternalBTId(x);
      let x = args.CharacterAIId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_CharacterAIId(x);
      let x = args.PersonalityId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_PersonalityId(x);
      let x = args.CostumeGroupId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_CostumeGroupId(x);
      let x = args.Id;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_Id(x);
      let x = args.CharacterPieceItemAmount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_CharacterPieceItemAmount(x);
      let x = args.SecretStoneItemAmount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_SecretStoneItemAmount(x);
      if let Some(x) = args.Tags {
        builder.add_Tags(x);
      }
      let x = args.AppearFrame;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_AppearFrame(x);
      let x = args.JumpMotionFrame;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_JumpMotionFrame(x);
      let x = args.MoveEndFrame;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_MoveEndFrame(x);
      let x = args.MoveStartFrame;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_MoveStartFrame(x);
      let x = args.EmojiOffsetY;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_EmojiOffsetY(x);
      let x = args.EmojiOffsetX;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_EmojiOffsetX(x);
      let x = args.HighlightFloaterHeight;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_HighlightFloaterHeight(x);
      let x = args.HpBarHeight;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_HpBarHeight(x);
      let x = args.WeaponLocalizeId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_uint(x, &key) } else { x };
      builder.add_WeaponLocalizeId(x);
      if let Some(x) = args.EquipmentSlot {
        builder.add_EquipmentSlot(x);
      }
      let x = args.FavorLevelupType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_FavorLevelupType(x);
      let x = args.SpawnTemplateId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_uint(x, &key) } else { x };
      builder.add_SpawnTemplateId(x);
      if let Some(x) = args.ScenarioCharacter {
        builder.add_ScenarioCharacter(x);
      }
      let x = args.CombatStyleIndex;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_CombatStyleIndex(x);
      let x = args.SquadType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_SquadType(x);
      let x = args.StatLevelUpType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_StatLevelUpType(x);
      let x = args.MaxStarGrade;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_MaxStarGrade(x);
      let x = args.DefaultStarGrade;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_DefaultStarGrade(x);
      let x = args.Club;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_Club(x);
      let x = args.School;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_School(x);
      let x = args.AimIKType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_AimIKType(x);
      let x = args.ArmorType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_ArmorType(x);
      let x = args.BulletType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_BulletType(x);
      let x = args.TacticRange;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_TacticRange(x);
      let x = args.WeaponType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_WeaponType(x);
      let x = args.TacticRole;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_TacticRole(x);
      let x = args.SubPartsCount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_SubPartsCount(x);
      let x = args.TacticEntityType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_TacticEntityType(x);
      let x = args.Rarity;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_Rarity(x);
      let x = args.LocalizeEtcId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_uint(x, &key) } else { x };
      builder.add_LocalizeEtcId(x);
      if let Some(x) = args.CollectionVisibleEndDate {
        builder.add_CollectionVisibleEndDate(x);
      }
      if let Some(x) = args.CollectionVisibleStartDate {
        builder.add_CollectionVisibleStartDate(x);
      }
      if let Some(x) = args.ReleaseDate {
        builder.add_ReleaseDate(x);
      }
      let x = args.ProductionStep;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_ProductionStep(x);
      if let Some(x) = args.DevName {
        builder.add_DevName(x);
      }
      builder.add_IsAirUnit(args.IsAirUnit);
      builder.add_IgnoreObstacle(args.IgnoreObstacle);
      builder.add_CanBattleItemMove(args.CanBattleItemMove);
      builder.add_CanCrowdControl(args.CanCrowdControl);
      builder.add_CanFix(args.CanFix);
      builder.add_CanMove(args.CanMove);
      builder.add_HPBarHide(args.HPBarHide);
      builder.add_DisplayEnemyInfo(args.DisplayEnemyInfo);
      builder.add_Jumpable(args.Jumpable);
      builder.add_IsDummy(args.IsDummy);
      builder.add_CanSurvive(args.CanSurvive);
      builder.add_IsNPC(args.IsNPC);
      builder.add_isPlayableCharacter(args.isPlayableCharacter);
      builder.add_CollectionVisible(args.CollectionVisible);
      builder.add_IsPlayable(args.IsPlayable);
    builder.finish()
  }

  pub fn unpack(&self) -> CharacterExcelT {
    let key = table_encryption_service::create_key(b"Character");
      let Id = self.Id();
    let DevName = self.DevName().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let CostumeGroupId = self.CostumeGroupId();
      let IsPlayable = self.IsPlayable();
      let ProductionStep = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.ProductionStep(), &key)
      } else {
        self.ProductionStep()
      };
      let CollectionVisible = self.CollectionVisible();
    let ReleaseDate = self.ReleaseDate().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let CollectionVisibleStartDate = self.CollectionVisibleStartDate().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let CollectionVisibleEndDate = self.CollectionVisibleEndDate().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let isPlayableCharacter = self.isPlayableCharacter();
      let LocalizeEtcId = self.LocalizeEtcId();
      let Rarity = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.Rarity(), &key)
      } else {
        self.Rarity()
      };
      let IsNPC = self.IsNPC();
      let TacticEntityType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.TacticEntityType(), &key)
      } else {
        self.TacticEntityType()
      };
      let CanSurvive = self.CanSurvive();
      let IsDummy = self.IsDummy();
      let SubPartsCount = self.SubPartsCount();
      let TacticRole = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.TacticRole(), &key)
      } else {
        self.TacticRole()
      };
      let WeaponType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.WeaponType(), &key)
      } else {
        self.WeaponType()
      };
      let TacticRange = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.TacticRange(), &key)
      } else {
        self.TacticRange()
      };
      let BulletType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.BulletType(), &key)
      } else {
        self.BulletType()
      };
      let ArmorType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.ArmorType(), &key)
      } else {
        self.ArmorType()
      };
      let AimIKType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.AimIKType(), &key)
      } else {
        self.AimIKType()
      };
      let School = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.School(), &key)
      } else {
        self.School()
      };
      let Club = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.Club(), &key)
      } else {
        self.Club()
      };
      let DefaultStarGrade = self.DefaultStarGrade();
      let MaxStarGrade = self.MaxStarGrade();
      let StatLevelUpType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.StatLevelUpType(), &key)
      } else {
        self.StatLevelUpType()
      };
      let SquadType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.SquadType(), &key)
      } else {
        self.SquadType()
      };
      let Jumpable = self.Jumpable();
      let PersonalityId = self.PersonalityId();
      let CharacterAIId = self.CharacterAIId();
      let ExternalBTId = self.ExternalBTId();
      let MainCombatStyleId = self.MainCombatStyleId();
      let CombatStyleIndex = self.CombatStyleIndex();
    let ScenarioCharacter = self.ScenarioCharacter().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let SpawnTemplateId = self.SpawnTemplateId();
      let FavorLevelupType = self.FavorLevelupType();
    let EquipmentSlot = self.EquipmentSlot().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(*val, &key) } else { *val }).collect()
    });
      let WeaponLocalizeId = self.WeaponLocalizeId();
      let DisplayEnemyInfo = self.DisplayEnemyInfo();
      let bodyRadius = self.bodyRadius();
      let RandomEffectRadius = self.RandomEffectRadius();
      let HPBarHide = self.HPBarHide();
      let HpBarHeight = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.HpBarHeight(), &key)
      } else {
        self.HpBarHeight()
      };
      let HighlightFloaterHeight = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.HighlightFloaterHeight(), &key)
      } else {
        self.HighlightFloaterHeight()
      };
      let EmojiOffsetX = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.EmojiOffsetX(), &key)
      } else {
        self.EmojiOffsetX()
      };
      let EmojiOffsetY = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.EmojiOffsetY(), &key)
      } else {
        self.EmojiOffsetY()
      };
      let MoveStartFrame = self.MoveStartFrame();
      let MoveEndFrame = self.MoveEndFrame();
      let JumpMotionFrame = self.JumpMotionFrame();
      let AppearFrame = self.AppearFrame();
      let CanMove = self.CanMove();
      let CanFix = self.CanFix();
      let CanCrowdControl = self.CanCrowdControl();
      let CanBattleItemMove = self.CanBattleItemMove();
      let IgnoreObstacle = self.IgnoreObstacle();
      let IsAirUnit = self.IsAirUnit();
      let AirUnitHeight = self.AirUnitHeight();
    let Tags = self.Tags().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(*val, &key) } else { *val }).collect()
    });
      let SecretStoneItemId = self.SecretStoneItemId();
      let SecretStoneItemAmount = self.SecretStoneItemAmount();
      let CharacterPieceItemId = self.CharacterPieceItemId();
      let CharacterPieceItemAmount = self.CharacterPieceItemAmount();
      let CombineRecipeId = self.CombineRecipeId();
    CharacterExcelT {
      Id,
      DevName,
      CostumeGroupId,
      IsPlayable,
      ProductionStep,
      CollectionVisible,
      ReleaseDate,
      CollectionVisibleStartDate,
      CollectionVisibleEndDate,
      isPlayableCharacter,
      LocalizeEtcId,
      Rarity,
      IsNPC,
      TacticEntityType,
      CanSurvive,
      IsDummy,
      SubPartsCount,
      TacticRole,
      WeaponType,
      TacticRange,
      BulletType,
      ArmorType,
      AimIKType,
      School,
      Club,
      DefaultStarGrade,
      MaxStarGrade,
      StatLevelUpType,
      SquadType,
      Jumpable,
      PersonalityId,
      CharacterAIId,
      ExternalBTId,
      MainCombatStyleId,
      CombatStyleIndex,
      ScenarioCharacter,
      SpawnTemplateId,
      FavorLevelupType,
      EquipmentSlot,
      WeaponLocalizeId,
      DisplayEnemyInfo,
      bodyRadius,
      RandomEffectRadius,
      HPBarHide,
      HpBarHeight,
      HighlightFloaterHeight,
      EmojiOffsetX,
      EmojiOffsetY,
      MoveStartFrame,
      MoveEndFrame,
      JumpMotionFrame,
      AppearFrame,
      CanMove,
      CanFix,
      CanCrowdControl,
      CanBattleItemMove,
      IgnoreObstacle,
      IsAirUnit,
      AirUnitHeight,
      Tags,
      SecretStoneItemId,
      SecretStoneItemAmount,
      CharacterPieceItemId,
      CharacterPieceItemAmount,
      CombineRecipeId,
    }
  }

  #[inline]
  pub fn Id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CharacterExcel::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn DevName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CharacterExcel::VT_DEVNAME, None)}
  }
  #[inline]
  pub fn CostumeGroupId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CharacterExcel::VT_COSTUMEGROUPID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn IsPlayable(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CharacterExcel::VT_ISPLAYABLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn ProductionStep(&self) -> ProductionStep {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ProductionStep>(CharacterExcel::VT_PRODUCTIONSTEP, Some(ProductionStep::ToDo)).unwrap()}
  }
  #[inline]
  pub fn CollectionVisible(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CharacterExcel::VT_COLLECTIONVISIBLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn ReleaseDate(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CharacterExcel::VT_RELEASEDATE, None)}
  }
  #[inline]
  pub fn CollectionVisibleStartDate(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CharacterExcel::VT_COLLECTIONVISIBLESTARTDATE, None)}
  }
  #[inline]
  pub fn CollectionVisibleEndDate(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CharacterExcel::VT_COLLECTIONVISIBLEENDDATE, None)}
  }
  #[inline]
  pub fn isPlayableCharacter(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CharacterExcel::VT_ISPLAYABLECHARACTER, Some(false)).unwrap()}
  }
  #[inline]
  pub fn LocalizeEtcId(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(CharacterExcel::VT_LOCALIZEETCID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn Rarity(&self) -> Rarity {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Rarity>(CharacterExcel::VT_RARITY, Some(Rarity::N)).unwrap()}
  }
  #[inline]
  pub fn IsNPC(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CharacterExcel::VT_ISNPC, Some(false)).unwrap()}
  }
  #[inline]
  pub fn TacticEntityType(&self) -> TacticEntityType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TacticEntityType>(CharacterExcel::VT_TACTICENTITYTYPE, Some(TacticEntityType::None)).unwrap()}
  }
  #[inline]
  pub fn CanSurvive(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CharacterExcel::VT_CANSURVIVE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn IsDummy(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CharacterExcel::VT_ISDUMMY, Some(false)).unwrap()}
  }
  #[inline]
  pub fn SubPartsCount(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CharacterExcel::VT_SUBPARTSCOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn TacticRole(&self) -> TacticRole {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TacticRole>(CharacterExcel::VT_TACTICROLE, Some(TacticRole::None)).unwrap()}
  }
  #[inline]
  pub fn WeaponType(&self) -> WeaponType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<WeaponType>(CharacterExcel::VT_WEAPONTYPE, Some(WeaponType::None)).unwrap()}
  }
  #[inline]
  pub fn TacticRange(&self) -> TacticRange {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TacticRange>(CharacterExcel::VT_TACTICRANGE, Some(TacticRange::Back)).unwrap()}
  }
  #[inline]
  pub fn BulletType(&self) -> BulletType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<BulletType>(CharacterExcel::VT_BULLETTYPE, Some(BulletType::Normal)).unwrap()}
  }
  #[inline]
  pub fn ArmorType(&self) -> ArmorType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ArmorType>(CharacterExcel::VT_ARMORTYPE, Some(ArmorType::LightArmor)).unwrap()}
  }
  #[inline]
  pub fn AimIKType(&self) -> AimIKType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<AimIKType>(CharacterExcel::VT_AIMIKTYPE, Some(AimIKType::None)).unwrap()}
  }
  #[inline]
  pub fn School(&self) -> School {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<School>(CharacterExcel::VT_SCHOOL, Some(School::None)).unwrap()}
  }
  #[inline]
  pub fn Club(&self) -> Club {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Club>(CharacterExcel::VT_CLUB, Some(Club::None)).unwrap()}
  }
  #[inline]
  pub fn DefaultStarGrade(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CharacterExcel::VT_DEFAULTSTARGRADE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn MaxStarGrade(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CharacterExcel::VT_MAXSTARGRADE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn StatLevelUpType(&self) -> StatLevelUpType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<StatLevelUpType>(CharacterExcel::VT_STATLEVELUPTYPE, Some(StatLevelUpType::Standard)).unwrap()}
  }
  #[inline]
  pub fn SquadType(&self) -> SquadType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SquadType>(CharacterExcel::VT_SQUADTYPE, Some(SquadType::None)).unwrap()}
  }
  #[inline]
  pub fn Jumpable(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CharacterExcel::VT_JUMPABLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn PersonalityId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CharacterExcel::VT_PERSONALITYID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CharacterAIId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CharacterExcel::VT_CHARACTERAIID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ExternalBTId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CharacterExcel::VT_EXTERNALBTID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn MainCombatStyleId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CharacterExcel::VT_MAINCOMBATSTYLEID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CombatStyleIndex(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CharacterExcel::VT_COMBATSTYLEINDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ScenarioCharacter(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CharacterExcel::VT_SCENARIOCHARACTER, None)}
  }
  #[inline]
  pub fn SpawnTemplateId(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(CharacterExcel::VT_SPAWNTEMPLATEID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn FavorLevelupType(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CharacterExcel::VT_FAVORLEVELUPTYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EquipmentSlot(&self) -> Option<flatbuffers::Vector<'a, EquipmentCategory>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, EquipmentCategory>>>(CharacterExcel::VT_EQUIPMENTSLOT, None)}
  }
  #[inline]
  pub fn WeaponLocalizeId(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(CharacterExcel::VT_WEAPONLOCALIZEID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn DisplayEnemyInfo(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CharacterExcel::VT_DISPLAYENEMYINFO, Some(false)).unwrap()}
  }
  #[inline]
  pub fn bodyRadius(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CharacterExcel::VT_BODYRADIUS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn RandomEffectRadius(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CharacterExcel::VT_RANDOMEFFECTRADIUS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn HPBarHide(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CharacterExcel::VT_HPBARHIDE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn HpBarHeight(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(CharacterExcel::VT_HPBARHEIGHT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn HighlightFloaterHeight(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(CharacterExcel::VT_HIGHLIGHTFLOATERHEIGHT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn EmojiOffsetX(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(CharacterExcel::VT_EMOJIOFFSETX, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn EmojiOffsetY(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(CharacterExcel::VT_EMOJIOFFSETY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn MoveStartFrame(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CharacterExcel::VT_MOVESTARTFRAME, Some(0)).unwrap()}
  }
  #[inline]
  pub fn MoveEndFrame(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CharacterExcel::VT_MOVEENDFRAME, Some(0)).unwrap()}
  }
  #[inline]
  pub fn JumpMotionFrame(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CharacterExcel::VT_JUMPMOTIONFRAME, Some(0)).unwrap()}
  }
  #[inline]
  pub fn AppearFrame(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CharacterExcel::VT_APPEARFRAME, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CanMove(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CharacterExcel::VT_CANMOVE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn CanFix(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CharacterExcel::VT_CANFIX, Some(false)).unwrap()}
  }
  #[inline]
  pub fn CanCrowdControl(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CharacterExcel::VT_CANCROWDCONTROL, Some(false)).unwrap()}
  }
  #[inline]
  pub fn CanBattleItemMove(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CharacterExcel::VT_CANBATTLEITEMMOVE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn IgnoreObstacle(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CharacterExcel::VT_IGNOREOBSTACLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn IsAirUnit(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CharacterExcel::VT_ISAIRUNIT, Some(false)).unwrap()}
  }
  #[inline]
  pub fn AirUnitHeight(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CharacterExcel::VT_AIRUNITHEIGHT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn Tags(&self) -> Option<flatbuffers::Vector<'a, Tag>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Tag>>>(CharacterExcel::VT_TAGS, None)}
  }
  #[inline]
  pub fn SecretStoneItemId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CharacterExcel::VT_SECRETSTONEITEMID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn SecretStoneItemAmount(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CharacterExcel::VT_SECRETSTONEITEMAMOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CharacterPieceItemId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CharacterExcel::VT_CHARACTERPIECEITEMID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CharacterPieceItemAmount(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CharacterExcel::VT_CHARACTERPIECEITEMAMOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CombineRecipeId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(CharacterExcel::VT_COMBINERECIPEID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for CharacterExcel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("Id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DevName", Self::VT_DEVNAME, false)?
     .visit_field::<i64>("CostumeGroupId", Self::VT_COSTUMEGROUPID, false)?
     .visit_field::<bool>("IsPlayable", Self::VT_ISPLAYABLE, false)?
     .visit_field::<ProductionStep>("ProductionStep", Self::VT_PRODUCTIONSTEP, false)?
     .visit_field::<bool>("CollectionVisible", Self::VT_COLLECTIONVISIBLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ReleaseDate", Self::VT_RELEASEDATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CollectionVisibleStartDate", Self::VT_COLLECTIONVISIBLESTARTDATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CollectionVisibleEndDate", Self::VT_COLLECTIONVISIBLEENDDATE, false)?
     .visit_field::<bool>("isPlayableCharacter", Self::VT_ISPLAYABLECHARACTER, false)?
     .visit_field::<u32>("LocalizeEtcId", Self::VT_LOCALIZEETCID, false)?
     .visit_field::<Rarity>("Rarity", Self::VT_RARITY, false)?
     .visit_field::<bool>("IsNPC", Self::VT_ISNPC, false)?
     .visit_field::<TacticEntityType>("TacticEntityType", Self::VT_TACTICENTITYTYPE, false)?
     .visit_field::<bool>("CanSurvive", Self::VT_CANSURVIVE, false)?
     .visit_field::<bool>("IsDummy", Self::VT_ISDUMMY, false)?
     .visit_field::<i32>("SubPartsCount", Self::VT_SUBPARTSCOUNT, false)?
     .visit_field::<TacticRole>("TacticRole", Self::VT_TACTICROLE, false)?
     .visit_field::<WeaponType>("WeaponType", Self::VT_WEAPONTYPE, false)?
     .visit_field::<TacticRange>("TacticRange", Self::VT_TACTICRANGE, false)?
     .visit_field::<BulletType>("BulletType", Self::VT_BULLETTYPE, false)?
     .visit_field::<ArmorType>("ArmorType", Self::VT_ARMORTYPE, false)?
     .visit_field::<AimIKType>("AimIKType", Self::VT_AIMIKTYPE, false)?
     .visit_field::<School>("School", Self::VT_SCHOOL, false)?
     .visit_field::<Club>("Club", Self::VT_CLUB, false)?
     .visit_field::<i32>("DefaultStarGrade", Self::VT_DEFAULTSTARGRADE, false)?
     .visit_field::<i32>("MaxStarGrade", Self::VT_MAXSTARGRADE, false)?
     .visit_field::<StatLevelUpType>("StatLevelUpType", Self::VT_STATLEVELUPTYPE, false)?
     .visit_field::<SquadType>("SquadType", Self::VT_SQUADTYPE, false)?
     .visit_field::<bool>("Jumpable", Self::VT_JUMPABLE, false)?
     .visit_field::<i64>("PersonalityId", Self::VT_PERSONALITYID, false)?
     .visit_field::<i64>("CharacterAIId", Self::VT_CHARACTERAIID, false)?
     .visit_field::<i64>("ExternalBTId", Self::VT_EXTERNALBTID, false)?
     .visit_field::<i64>("MainCombatStyleId", Self::VT_MAINCOMBATSTYLEID, false)?
     .visit_field::<i32>("CombatStyleIndex", Self::VT_COMBATSTYLEINDEX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ScenarioCharacter", Self::VT_SCENARIOCHARACTER, false)?
     .visit_field::<u32>("SpawnTemplateId", Self::VT_SPAWNTEMPLATEID, false)?
     .visit_field::<i32>("FavorLevelupType", Self::VT_FAVORLEVELUPTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, EquipmentCategory>>>("EquipmentSlot", Self::VT_EQUIPMENTSLOT, false)?
     .visit_field::<u32>("WeaponLocalizeId", Self::VT_WEAPONLOCALIZEID, false)?
     .visit_field::<bool>("DisplayEnemyInfo", Self::VT_DISPLAYENEMYINFO, false)?
     .visit_field::<i64>("bodyRadius", Self::VT_BODYRADIUS, false)?
     .visit_field::<i64>("RandomEffectRadius", Self::VT_RANDOMEFFECTRADIUS, false)?
     .visit_field::<bool>("HPBarHide", Self::VT_HPBARHIDE, false)?
     .visit_field::<f32>("HpBarHeight", Self::VT_HPBARHEIGHT, false)?
     .visit_field::<f32>("HighlightFloaterHeight", Self::VT_HIGHLIGHTFLOATERHEIGHT, false)?
     .visit_field::<f32>("EmojiOffsetX", Self::VT_EMOJIOFFSETX, false)?
     .visit_field::<f32>("EmojiOffsetY", Self::VT_EMOJIOFFSETY, false)?
     .visit_field::<i32>("MoveStartFrame", Self::VT_MOVESTARTFRAME, false)?
     .visit_field::<i32>("MoveEndFrame", Self::VT_MOVEENDFRAME, false)?
     .visit_field::<i32>("JumpMotionFrame", Self::VT_JUMPMOTIONFRAME, false)?
     .visit_field::<i32>("AppearFrame", Self::VT_APPEARFRAME, false)?
     .visit_field::<bool>("CanMove", Self::VT_CANMOVE, false)?
     .visit_field::<bool>("CanFix", Self::VT_CANFIX, false)?
     .visit_field::<bool>("CanCrowdControl", Self::VT_CANCROWDCONTROL, false)?
     .visit_field::<bool>("CanBattleItemMove", Self::VT_CANBATTLEITEMMOVE, false)?
     .visit_field::<bool>("IgnoreObstacle", Self::VT_IGNOREOBSTACLE, false)?
     .visit_field::<bool>("IsAirUnit", Self::VT_ISAIRUNIT, false)?
     .visit_field::<i64>("AirUnitHeight", Self::VT_AIRUNITHEIGHT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Tag>>>("Tags", Self::VT_TAGS, false)?
     .visit_field::<i64>("SecretStoneItemId", Self::VT_SECRETSTONEITEMID, false)?
     .visit_field::<i32>("SecretStoneItemAmount", Self::VT_SECRETSTONEITEMAMOUNT, false)?
     .visit_field::<i64>("CharacterPieceItemId", Self::VT_CHARACTERPIECEITEMID, false)?
     .visit_field::<i32>("CharacterPieceItemAmount", Self::VT_CHARACTERPIECEITEMAMOUNT, false)?
     .visit_field::<i64>("CombineRecipeId", Self::VT_COMBINERECIPEID, false)?
     .finish();
    Ok(())
  }
}
pub struct CharacterExcelArgs<'a> {
    pub Id: i64,
    pub DevName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CostumeGroupId: i64,
    pub IsPlayable: bool,
    pub ProductionStep: ProductionStep,
    pub CollectionVisible: bool,
    pub ReleaseDate: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CollectionVisibleStartDate: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CollectionVisibleEndDate: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isPlayableCharacter: bool,
    pub LocalizeEtcId: u32,
    pub Rarity: Rarity,
    pub IsNPC: bool,
    pub TacticEntityType: TacticEntityType,
    pub CanSurvive: bool,
    pub IsDummy: bool,
    pub SubPartsCount: i32,
    pub TacticRole: TacticRole,
    pub WeaponType: WeaponType,
    pub TacticRange: TacticRange,
    pub BulletType: BulletType,
    pub ArmorType: ArmorType,
    pub AimIKType: AimIKType,
    pub School: School,
    pub Club: Club,
    pub DefaultStarGrade: i32,
    pub MaxStarGrade: i32,
    pub StatLevelUpType: StatLevelUpType,
    pub SquadType: SquadType,
    pub Jumpable: bool,
    pub PersonalityId: i64,
    pub CharacterAIId: i64,
    pub ExternalBTId: i64,
    pub MainCombatStyleId: i64,
    pub CombatStyleIndex: i32,
    pub ScenarioCharacter: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SpawnTemplateId: u32,
    pub FavorLevelupType: i32,
    pub EquipmentSlot: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, EquipmentCategory>>>,
    pub WeaponLocalizeId: u32,
    pub DisplayEnemyInfo: bool,
    pub bodyRadius: i64,
    pub RandomEffectRadius: i64,
    pub HPBarHide: bool,
    pub HpBarHeight: f32,
    pub HighlightFloaterHeight: f32,
    pub EmojiOffsetX: f32,
    pub EmojiOffsetY: f32,
    pub MoveStartFrame: i32,
    pub MoveEndFrame: i32,
    pub JumpMotionFrame: i32,
    pub AppearFrame: i32,
    pub CanMove: bool,
    pub CanFix: bool,
    pub CanCrowdControl: bool,
    pub CanBattleItemMove: bool,
    pub IgnoreObstacle: bool,
    pub IsAirUnit: bool,
    pub AirUnitHeight: i64,
    pub Tags: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Tag>>>,
    pub SecretStoneItemId: i64,
    pub SecretStoneItemAmount: i32,
    pub CharacterPieceItemId: i64,
    pub CharacterPieceItemAmount: i32,
    pub CombineRecipeId: i64,
}
impl<'a> Default for CharacterExcelArgs<'a> {
  #[inline]
  fn default() -> Self {
    CharacterExcelArgs {
      Id: 0,
      DevName: None,
      CostumeGroupId: 0,
      IsPlayable: false,
      ProductionStep: ProductionStep::ToDo,
      CollectionVisible: false,
      ReleaseDate: None,
      CollectionVisibleStartDate: None,
      CollectionVisibleEndDate: None,
      isPlayableCharacter: false,
      LocalizeEtcId: 0,
      Rarity: Rarity::N,
      IsNPC: false,
      TacticEntityType: TacticEntityType::None,
      CanSurvive: false,
      IsDummy: false,
      SubPartsCount: 0,
      TacticRole: TacticRole::None,
      WeaponType: WeaponType::None,
      TacticRange: TacticRange::Back,
      BulletType: BulletType::Normal,
      ArmorType: ArmorType::LightArmor,
      AimIKType: AimIKType::None,
      School: School::None,
      Club: Club::None,
      DefaultStarGrade: 0,
      MaxStarGrade: 0,
      StatLevelUpType: StatLevelUpType::Standard,
      SquadType: SquadType::None,
      Jumpable: false,
      PersonalityId: 0,
      CharacterAIId: 0,
      ExternalBTId: 0,
      MainCombatStyleId: 0,
      CombatStyleIndex: 0,
      ScenarioCharacter: None,
      SpawnTemplateId: 0,
      FavorLevelupType: 0,
      EquipmentSlot: None,
      WeaponLocalizeId: 0,
      DisplayEnemyInfo: false,
      bodyRadius: 0,
      RandomEffectRadius: 0,
      HPBarHide: false,
      HpBarHeight: 0.0,
      HighlightFloaterHeight: 0.0,
      EmojiOffsetX: 0.0,
      EmojiOffsetY: 0.0,
      MoveStartFrame: 0,
      MoveEndFrame: 0,
      JumpMotionFrame: 0,
      AppearFrame: 0,
      CanMove: false,
      CanFix: false,
      CanCrowdControl: false,
      CanBattleItemMove: false,
      IgnoreObstacle: false,
      IsAirUnit: false,
      AirUnitHeight: 0,
      Tags: None,
      SecretStoneItemId: 0,
      SecretStoneItemAmount: 0,
      CharacterPieceItemId: 0,
      CharacterPieceItemAmount: 0,
      CombineRecipeId: 0,
    }
  }
}

impl Serialize for CharacterExcel<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("CharacterExcel", 65)?;
      s.serialize_field("Id", &self.Id())?;
      if let Some(f) = self.DevName() {
        s.serialize_field("DevName", &f)?;
      } else {
        s.skip_field("DevName")?;
      }
      s.serialize_field("CostumeGroupId", &self.CostumeGroupId())?;
      s.serialize_field("IsPlayable", &self.IsPlayable())?;
      s.serialize_field("ProductionStep", &self.ProductionStep())?;
      s.serialize_field("CollectionVisible", &self.CollectionVisible())?;
      if let Some(f) = self.ReleaseDate() {
        s.serialize_field("ReleaseDate", &f)?;
      } else {
        s.skip_field("ReleaseDate")?;
      }
      if let Some(f) = self.CollectionVisibleStartDate() {
        s.serialize_field("CollectionVisibleStartDate", &f)?;
      } else {
        s.skip_field("CollectionVisibleStartDate")?;
      }
      if let Some(f) = self.CollectionVisibleEndDate() {
        s.serialize_field("CollectionVisibleEndDate", &f)?;
      } else {
        s.skip_field("CollectionVisibleEndDate")?;
      }
      s.serialize_field("isPlayableCharacter", &self.isPlayableCharacter())?;
      s.serialize_field("LocalizeEtcId", &self.LocalizeEtcId())?;
      s.serialize_field("Rarity", &self.Rarity())?;
      s.serialize_field("IsNPC", &self.IsNPC())?;
      s.serialize_field("TacticEntityType", &self.TacticEntityType())?;
      s.serialize_field("CanSurvive", &self.CanSurvive())?;
      s.serialize_field("IsDummy", &self.IsDummy())?;
      s.serialize_field("SubPartsCount", &self.SubPartsCount())?;
      s.serialize_field("TacticRole", &self.TacticRole())?;
      s.serialize_field("WeaponType", &self.WeaponType())?;
      s.serialize_field("TacticRange", &self.TacticRange())?;
      s.serialize_field("BulletType", &self.BulletType())?;
      s.serialize_field("ArmorType", &self.ArmorType())?;
      s.serialize_field("AimIKType", &self.AimIKType())?;
      s.serialize_field("School", &self.School())?;
      s.serialize_field("Club", &self.Club())?;
      s.serialize_field("DefaultStarGrade", &self.DefaultStarGrade())?;
      s.serialize_field("MaxStarGrade", &self.MaxStarGrade())?;
      s.serialize_field("StatLevelUpType", &self.StatLevelUpType())?;
      s.serialize_field("SquadType", &self.SquadType())?;
      s.serialize_field("Jumpable", &self.Jumpable())?;
      s.serialize_field("PersonalityId", &self.PersonalityId())?;
      s.serialize_field("CharacterAIId", &self.CharacterAIId())?;
      s.serialize_field("ExternalBTId", &self.ExternalBTId())?;
      s.serialize_field("MainCombatStyleId", &self.MainCombatStyleId())?;
      s.serialize_field("CombatStyleIndex", &self.CombatStyleIndex())?;
      if let Some(f) = self.ScenarioCharacter() {
        s.serialize_field("ScenarioCharacter", &f)?;
      } else {
        s.skip_field("ScenarioCharacter")?;
      }
      s.serialize_field("SpawnTemplateId", &self.SpawnTemplateId())?;
      s.serialize_field("FavorLevelupType", &self.FavorLevelupType())?;
      if let Some(f) = self.EquipmentSlot() {
        s.serialize_field("EquipmentSlot", &f)?;
      } else {
        s.skip_field("EquipmentSlot")?;
      }
      s.serialize_field("WeaponLocalizeId", &self.WeaponLocalizeId())?;
      s.serialize_field("DisplayEnemyInfo", &self.DisplayEnemyInfo())?;
      s.serialize_field("bodyRadius", &self.bodyRadius())?;
      s.serialize_field("RandomEffectRadius", &self.RandomEffectRadius())?;
      s.serialize_field("HPBarHide", &self.HPBarHide())?;
      s.serialize_field("HpBarHeight", &self.HpBarHeight())?;
      s.serialize_field("HighlightFloaterHeight", &self.HighlightFloaterHeight())?;
      s.serialize_field("EmojiOffsetX", &self.EmojiOffsetX())?;
      s.serialize_field("EmojiOffsetY", &self.EmojiOffsetY())?;
      s.serialize_field("MoveStartFrame", &self.MoveStartFrame())?;
      s.serialize_field("MoveEndFrame", &self.MoveEndFrame())?;
      s.serialize_field("JumpMotionFrame", &self.JumpMotionFrame())?;
      s.serialize_field("AppearFrame", &self.AppearFrame())?;
      s.serialize_field("CanMove", &self.CanMove())?;
      s.serialize_field("CanFix", &self.CanFix())?;
      s.serialize_field("CanCrowdControl", &self.CanCrowdControl())?;
      s.serialize_field("CanBattleItemMove", &self.CanBattleItemMove())?;
      s.serialize_field("IgnoreObstacle", &self.IgnoreObstacle())?;
      s.serialize_field("IsAirUnit", &self.IsAirUnit())?;
      s.serialize_field("AirUnitHeight", &self.AirUnitHeight())?;
      if let Some(f) = self.Tags() {
        s.serialize_field("Tags", &f)?;
      } else {
        s.skip_field("Tags")?;
      }
      s.serialize_field("SecretStoneItemId", &self.SecretStoneItemId())?;
      s.serialize_field("SecretStoneItemAmount", &self.SecretStoneItemAmount())?;
      s.serialize_field("CharacterPieceItemId", &self.CharacterPieceItemId())?;
      s.serialize_field("CharacterPieceItemAmount", &self.CharacterPieceItemAmount())?;
      s.serialize_field("CombineRecipeId", &self.CombineRecipeId())?;
    s.end()
  }
}

pub struct CharacterExcelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CharacterExcelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_Id(&mut self, Id: i64) {
    self.fbb_.push_slot::<i64>(CharacterExcel::VT_ID, Id, 0);
  }
  #[inline]
  pub fn add_DevName(&mut self, DevName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CharacterExcel::VT_DEVNAME, DevName);
  }
  #[inline]
  pub fn add_CostumeGroupId(&mut self, CostumeGroupId: i64) {
    self.fbb_.push_slot::<i64>(CharacterExcel::VT_COSTUMEGROUPID, CostumeGroupId, 0);
  }
  #[inline]
  pub fn add_IsPlayable(&mut self, IsPlayable: bool) {
    self.fbb_.push_slot::<bool>(CharacterExcel::VT_ISPLAYABLE, IsPlayable, false);
  }
  #[inline]
  pub fn add_ProductionStep(&mut self, ProductionStep: ProductionStep) {
    self.fbb_.push_slot::<ProductionStep>(CharacterExcel::VT_PRODUCTIONSTEP, ProductionStep, ProductionStep::ToDo);
  }
  #[inline]
  pub fn add_CollectionVisible(&mut self, CollectionVisible: bool) {
    self.fbb_.push_slot::<bool>(CharacterExcel::VT_COLLECTIONVISIBLE, CollectionVisible, false);
  }
  #[inline]
  pub fn add_ReleaseDate(&mut self, ReleaseDate: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CharacterExcel::VT_RELEASEDATE, ReleaseDate);
  }
  #[inline]
  pub fn add_CollectionVisibleStartDate(&mut self, CollectionVisibleStartDate: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CharacterExcel::VT_COLLECTIONVISIBLESTARTDATE, CollectionVisibleStartDate);
  }
  #[inline]
  pub fn add_CollectionVisibleEndDate(&mut self, CollectionVisibleEndDate: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CharacterExcel::VT_COLLECTIONVISIBLEENDDATE, CollectionVisibleEndDate);
  }
  #[inline]
  pub fn add_isPlayableCharacter(&mut self, isPlayableCharacter: bool) {
    self.fbb_.push_slot::<bool>(CharacterExcel::VT_ISPLAYABLECHARACTER, isPlayableCharacter, false);
  }
  #[inline]
  pub fn add_LocalizeEtcId(&mut self, LocalizeEtcId: u32) {
    self.fbb_.push_slot::<u32>(CharacterExcel::VT_LOCALIZEETCID, LocalizeEtcId, 0);
  }
  #[inline]
  pub fn add_Rarity(&mut self, Rarity: Rarity) {
    self.fbb_.push_slot::<Rarity>(CharacterExcel::VT_RARITY, Rarity, Rarity::N);
  }
  #[inline]
  pub fn add_IsNPC(&mut self, IsNPC: bool) {
    self.fbb_.push_slot::<bool>(CharacterExcel::VT_ISNPC, IsNPC, false);
  }
  #[inline]
  pub fn add_TacticEntityType(&mut self, TacticEntityType: TacticEntityType) {
    self.fbb_.push_slot::<TacticEntityType>(CharacterExcel::VT_TACTICENTITYTYPE, TacticEntityType, TacticEntityType::None);
  }
  #[inline]
  pub fn add_CanSurvive(&mut self, CanSurvive: bool) {
    self.fbb_.push_slot::<bool>(CharacterExcel::VT_CANSURVIVE, CanSurvive, false);
  }
  #[inline]
  pub fn add_IsDummy(&mut self, IsDummy: bool) {
    self.fbb_.push_slot::<bool>(CharacterExcel::VT_ISDUMMY, IsDummy, false);
  }
  #[inline]
  pub fn add_SubPartsCount(&mut self, SubPartsCount: i32) {
    self.fbb_.push_slot::<i32>(CharacterExcel::VT_SUBPARTSCOUNT, SubPartsCount, 0);
  }
  #[inline]
  pub fn add_TacticRole(&mut self, TacticRole: TacticRole) {
    self.fbb_.push_slot::<TacticRole>(CharacterExcel::VT_TACTICROLE, TacticRole, TacticRole::None);
  }
  #[inline]
  pub fn add_WeaponType(&mut self, WeaponType: WeaponType) {
    self.fbb_.push_slot::<WeaponType>(CharacterExcel::VT_WEAPONTYPE, WeaponType, WeaponType::None);
  }
  #[inline]
  pub fn add_TacticRange(&mut self, TacticRange: TacticRange) {
    self.fbb_.push_slot::<TacticRange>(CharacterExcel::VT_TACTICRANGE, TacticRange, TacticRange::Back);
  }
  #[inline]
  pub fn add_BulletType(&mut self, BulletType: BulletType) {
    self.fbb_.push_slot::<BulletType>(CharacterExcel::VT_BULLETTYPE, BulletType, BulletType::Normal);
  }
  #[inline]
  pub fn add_ArmorType(&mut self, ArmorType: ArmorType) {
    self.fbb_.push_slot::<ArmorType>(CharacterExcel::VT_ARMORTYPE, ArmorType, ArmorType::LightArmor);
  }
  #[inline]
  pub fn add_AimIKType(&mut self, AimIKType: AimIKType) {
    self.fbb_.push_slot::<AimIKType>(CharacterExcel::VT_AIMIKTYPE, AimIKType, AimIKType::None);
  }
  #[inline]
  pub fn add_School(&mut self, School: School) {
    self.fbb_.push_slot::<School>(CharacterExcel::VT_SCHOOL, School, School::None);
  }
  #[inline]
  pub fn add_Club(&mut self, Club: Club) {
    self.fbb_.push_slot::<Club>(CharacterExcel::VT_CLUB, Club, Club::None);
  }
  #[inline]
  pub fn add_DefaultStarGrade(&mut self, DefaultStarGrade: i32) {
    self.fbb_.push_slot::<i32>(CharacterExcel::VT_DEFAULTSTARGRADE, DefaultStarGrade, 0);
  }
  #[inline]
  pub fn add_MaxStarGrade(&mut self, MaxStarGrade: i32) {
    self.fbb_.push_slot::<i32>(CharacterExcel::VT_MAXSTARGRADE, MaxStarGrade, 0);
  }
  #[inline]
  pub fn add_StatLevelUpType(&mut self, StatLevelUpType: StatLevelUpType) {
    self.fbb_.push_slot::<StatLevelUpType>(CharacterExcel::VT_STATLEVELUPTYPE, StatLevelUpType, StatLevelUpType::Standard);
  }
  #[inline]
  pub fn add_SquadType(&mut self, SquadType: SquadType) {
    self.fbb_.push_slot::<SquadType>(CharacterExcel::VT_SQUADTYPE, SquadType, SquadType::None);
  }
  #[inline]
  pub fn add_Jumpable(&mut self, Jumpable: bool) {
    self.fbb_.push_slot::<bool>(CharacterExcel::VT_JUMPABLE, Jumpable, false);
  }
  #[inline]
  pub fn add_PersonalityId(&mut self, PersonalityId: i64) {
    self.fbb_.push_slot::<i64>(CharacterExcel::VT_PERSONALITYID, PersonalityId, 0);
  }
  #[inline]
  pub fn add_CharacterAIId(&mut self, CharacterAIId: i64) {
    self.fbb_.push_slot::<i64>(CharacterExcel::VT_CHARACTERAIID, CharacterAIId, 0);
  }
  #[inline]
  pub fn add_ExternalBTId(&mut self, ExternalBTId: i64) {
    self.fbb_.push_slot::<i64>(CharacterExcel::VT_EXTERNALBTID, ExternalBTId, 0);
  }
  #[inline]
  pub fn add_MainCombatStyleId(&mut self, MainCombatStyleId: i64) {
    self.fbb_.push_slot::<i64>(CharacterExcel::VT_MAINCOMBATSTYLEID, MainCombatStyleId, 0);
  }
  #[inline]
  pub fn add_CombatStyleIndex(&mut self, CombatStyleIndex: i32) {
    self.fbb_.push_slot::<i32>(CharacterExcel::VT_COMBATSTYLEINDEX, CombatStyleIndex, 0);
  }
  #[inline]
  pub fn add_ScenarioCharacter(&mut self, ScenarioCharacter: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CharacterExcel::VT_SCENARIOCHARACTER, ScenarioCharacter);
  }
  #[inline]
  pub fn add_SpawnTemplateId(&mut self, SpawnTemplateId: u32) {
    self.fbb_.push_slot::<u32>(CharacterExcel::VT_SPAWNTEMPLATEID, SpawnTemplateId, 0);
  }
  #[inline]
  pub fn add_FavorLevelupType(&mut self, FavorLevelupType: i32) {
    self.fbb_.push_slot::<i32>(CharacterExcel::VT_FAVORLEVELUPTYPE, FavorLevelupType, 0);
  }
  #[inline]
  pub fn add_EquipmentSlot(&mut self, EquipmentSlot: flatbuffers::WIPOffset<flatbuffers::Vector<'b , EquipmentCategory>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CharacterExcel::VT_EQUIPMENTSLOT, EquipmentSlot);
  }
  #[inline]
  pub fn add_WeaponLocalizeId(&mut self, WeaponLocalizeId: u32) {
    self.fbb_.push_slot::<u32>(CharacterExcel::VT_WEAPONLOCALIZEID, WeaponLocalizeId, 0);
  }
  #[inline]
  pub fn add_DisplayEnemyInfo(&mut self, DisplayEnemyInfo: bool) {
    self.fbb_.push_slot::<bool>(CharacterExcel::VT_DISPLAYENEMYINFO, DisplayEnemyInfo, false);
  }
  #[inline]
  pub fn add_bodyRadius(&mut self, bodyRadius: i64) {
    self.fbb_.push_slot::<i64>(CharacterExcel::VT_BODYRADIUS, bodyRadius, 0);
  }
  #[inline]
  pub fn add_RandomEffectRadius(&mut self, RandomEffectRadius: i64) {
    self.fbb_.push_slot::<i64>(CharacterExcel::VT_RANDOMEFFECTRADIUS, RandomEffectRadius, 0);
  }
  #[inline]
  pub fn add_HPBarHide(&mut self, HPBarHide: bool) {
    self.fbb_.push_slot::<bool>(CharacterExcel::VT_HPBARHIDE, HPBarHide, false);
  }
  #[inline]
  pub fn add_HpBarHeight(&mut self, HpBarHeight: f32) {
    self.fbb_.push_slot::<f32>(CharacterExcel::VT_HPBARHEIGHT, HpBarHeight, 0.0);
  }
  #[inline]
  pub fn add_HighlightFloaterHeight(&mut self, HighlightFloaterHeight: f32) {
    self.fbb_.push_slot::<f32>(CharacterExcel::VT_HIGHLIGHTFLOATERHEIGHT, HighlightFloaterHeight, 0.0);
  }
  #[inline]
  pub fn add_EmojiOffsetX(&mut self, EmojiOffsetX: f32) {
    self.fbb_.push_slot::<f32>(CharacterExcel::VT_EMOJIOFFSETX, EmojiOffsetX, 0.0);
  }
  #[inline]
  pub fn add_EmojiOffsetY(&mut self, EmojiOffsetY: f32) {
    self.fbb_.push_slot::<f32>(CharacterExcel::VT_EMOJIOFFSETY, EmojiOffsetY, 0.0);
  }
  #[inline]
  pub fn add_MoveStartFrame(&mut self, MoveStartFrame: i32) {
    self.fbb_.push_slot::<i32>(CharacterExcel::VT_MOVESTARTFRAME, MoveStartFrame, 0);
  }
  #[inline]
  pub fn add_MoveEndFrame(&mut self, MoveEndFrame: i32) {
    self.fbb_.push_slot::<i32>(CharacterExcel::VT_MOVEENDFRAME, MoveEndFrame, 0);
  }
  #[inline]
  pub fn add_JumpMotionFrame(&mut self, JumpMotionFrame: i32) {
    self.fbb_.push_slot::<i32>(CharacterExcel::VT_JUMPMOTIONFRAME, JumpMotionFrame, 0);
  }
  #[inline]
  pub fn add_AppearFrame(&mut self, AppearFrame: i32) {
    self.fbb_.push_slot::<i32>(CharacterExcel::VT_APPEARFRAME, AppearFrame, 0);
  }
  #[inline]
  pub fn add_CanMove(&mut self, CanMove: bool) {
    self.fbb_.push_slot::<bool>(CharacterExcel::VT_CANMOVE, CanMove, false);
  }
  #[inline]
  pub fn add_CanFix(&mut self, CanFix: bool) {
    self.fbb_.push_slot::<bool>(CharacterExcel::VT_CANFIX, CanFix, false);
  }
  #[inline]
  pub fn add_CanCrowdControl(&mut self, CanCrowdControl: bool) {
    self.fbb_.push_slot::<bool>(CharacterExcel::VT_CANCROWDCONTROL, CanCrowdControl, false);
  }
  #[inline]
  pub fn add_CanBattleItemMove(&mut self, CanBattleItemMove: bool) {
    self.fbb_.push_slot::<bool>(CharacterExcel::VT_CANBATTLEITEMMOVE, CanBattleItemMove, false);
  }
  #[inline]
  pub fn add_IgnoreObstacle(&mut self, IgnoreObstacle: bool) {
    self.fbb_.push_slot::<bool>(CharacterExcel::VT_IGNOREOBSTACLE, IgnoreObstacle, false);
  }
  #[inline]
  pub fn add_IsAirUnit(&mut self, IsAirUnit: bool) {
    self.fbb_.push_slot::<bool>(CharacterExcel::VT_ISAIRUNIT, IsAirUnit, false);
  }
  #[inline]
  pub fn add_AirUnitHeight(&mut self, AirUnitHeight: i64) {
    self.fbb_.push_slot::<i64>(CharacterExcel::VT_AIRUNITHEIGHT, AirUnitHeight, 0);
  }
  #[inline]
  pub fn add_Tags(&mut self, Tags: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Tag>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CharacterExcel::VT_TAGS, Tags);
  }
  #[inline]
  pub fn add_SecretStoneItemId(&mut self, SecretStoneItemId: i64) {
    self.fbb_.push_slot::<i64>(CharacterExcel::VT_SECRETSTONEITEMID, SecretStoneItemId, 0);
  }
  #[inline]
  pub fn add_SecretStoneItemAmount(&mut self, SecretStoneItemAmount: i32) {
    self.fbb_.push_slot::<i32>(CharacterExcel::VT_SECRETSTONEITEMAMOUNT, SecretStoneItemAmount, 0);
  }
  #[inline]
  pub fn add_CharacterPieceItemId(&mut self, CharacterPieceItemId: i64) {
    self.fbb_.push_slot::<i64>(CharacterExcel::VT_CHARACTERPIECEITEMID, CharacterPieceItemId, 0);
  }
  #[inline]
  pub fn add_CharacterPieceItemAmount(&mut self, CharacterPieceItemAmount: i32) {
    self.fbb_.push_slot::<i32>(CharacterExcel::VT_CHARACTERPIECEITEMAMOUNT, CharacterPieceItemAmount, 0);
  }
  #[inline]
  pub fn add_CombineRecipeId(&mut self, CombineRecipeId: i64) {
    self.fbb_.push_slot::<i64>(CharacterExcel::VT_COMBINERECIPEID, CombineRecipeId, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CharacterExcelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CharacterExcelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CharacterExcel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CharacterExcel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CharacterExcel");
      ds.field("Id", &self.Id());
      ds.field("DevName", &self.DevName());
      ds.field("CostumeGroupId", &self.CostumeGroupId());
      ds.field("IsPlayable", &self.IsPlayable());
      ds.field("ProductionStep", &self.ProductionStep());
      ds.field("CollectionVisible", &self.CollectionVisible());
      ds.field("ReleaseDate", &self.ReleaseDate());
      ds.field("CollectionVisibleStartDate", &self.CollectionVisibleStartDate());
      ds.field("CollectionVisibleEndDate", &self.CollectionVisibleEndDate());
      ds.field("isPlayableCharacter", &self.isPlayableCharacter());
      ds.field("LocalizeEtcId", &self.LocalizeEtcId());
      ds.field("Rarity", &self.Rarity());
      ds.field("IsNPC", &self.IsNPC());
      ds.field("TacticEntityType", &self.TacticEntityType());
      ds.field("CanSurvive", &self.CanSurvive());
      ds.field("IsDummy", &self.IsDummy());
      ds.field("SubPartsCount", &self.SubPartsCount());
      ds.field("TacticRole", &self.TacticRole());
      ds.field("WeaponType", &self.WeaponType());
      ds.field("TacticRange", &self.TacticRange());
      ds.field("BulletType", &self.BulletType());
      ds.field("ArmorType", &self.ArmorType());
      ds.field("AimIKType", &self.AimIKType());
      ds.field("School", &self.School());
      ds.field("Club", &self.Club());
      ds.field("DefaultStarGrade", &self.DefaultStarGrade());
      ds.field("MaxStarGrade", &self.MaxStarGrade());
      ds.field("StatLevelUpType", &self.StatLevelUpType());
      ds.field("SquadType", &self.SquadType());
      ds.field("Jumpable", &self.Jumpable());
      ds.field("PersonalityId", &self.PersonalityId());
      ds.field("CharacterAIId", &self.CharacterAIId());
      ds.field("ExternalBTId", &self.ExternalBTId());
      ds.field("MainCombatStyleId", &self.MainCombatStyleId());
      ds.field("CombatStyleIndex", &self.CombatStyleIndex());
      ds.field("ScenarioCharacter", &self.ScenarioCharacter());
      ds.field("SpawnTemplateId", &self.SpawnTemplateId());
      ds.field("FavorLevelupType", &self.FavorLevelupType());
      ds.field("EquipmentSlot", &self.EquipmentSlot());
      ds.field("WeaponLocalizeId", &self.WeaponLocalizeId());
      ds.field("DisplayEnemyInfo", &self.DisplayEnemyInfo());
      ds.field("bodyRadius", &self.bodyRadius());
      ds.field("RandomEffectRadius", &self.RandomEffectRadius());
      ds.field("HPBarHide", &self.HPBarHide());
      ds.field("HpBarHeight", &self.HpBarHeight());
      ds.field("HighlightFloaterHeight", &self.HighlightFloaterHeight());
      ds.field("EmojiOffsetX", &self.EmojiOffsetX());
      ds.field("EmojiOffsetY", &self.EmojiOffsetY());
      ds.field("MoveStartFrame", &self.MoveStartFrame());
      ds.field("MoveEndFrame", &self.MoveEndFrame());
      ds.field("JumpMotionFrame", &self.JumpMotionFrame());
      ds.field("AppearFrame", &self.AppearFrame());
      ds.field("CanMove", &self.CanMove());
      ds.field("CanFix", &self.CanFix());
      ds.field("CanCrowdControl", &self.CanCrowdControl());
      ds.field("CanBattleItemMove", &self.CanBattleItemMove());
      ds.field("IgnoreObstacle", &self.IgnoreObstacle());
      ds.field("IsAirUnit", &self.IsAirUnit());
      ds.field("AirUnitHeight", &self.AirUnitHeight());
      ds.field("Tags", &self.Tags());
      ds.field("SecretStoneItemId", &self.SecretStoneItemId());
      ds.field("SecretStoneItemAmount", &self.SecretStoneItemAmount());
      ds.field("CharacterPieceItemId", &self.CharacterPieceItemId());
      ds.field("CharacterPieceItemAmount", &self.CharacterPieceItemAmount());
      ds.field("CombineRecipeId", &self.CombineRecipeId());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CharacterExcelT {
  pub Id: i64,
  pub DevName: Option<String>,
  pub CostumeGroupId: i64,
  pub IsPlayable: bool,
  pub ProductionStep: ProductionStep,
  pub CollectionVisible: bool,
  pub ReleaseDate: Option<String>,
  pub CollectionVisibleStartDate: Option<String>,
  pub CollectionVisibleEndDate: Option<String>,
  pub isPlayableCharacter: bool,
  pub LocalizeEtcId: u32,
  pub Rarity: Rarity,
  pub IsNPC: bool,
  pub TacticEntityType: TacticEntityType,
  pub CanSurvive: bool,
  pub IsDummy: bool,
  pub SubPartsCount: i32,
  pub TacticRole: TacticRole,
  pub WeaponType: WeaponType,
  pub TacticRange: TacticRange,
  pub BulletType: BulletType,
  pub ArmorType: ArmorType,
  pub AimIKType: AimIKType,
  pub School: School,
  pub Club: Club,
  pub DefaultStarGrade: i32,
  pub MaxStarGrade: i32,
  pub StatLevelUpType: StatLevelUpType,
  pub SquadType: SquadType,
  pub Jumpable: bool,
  pub PersonalityId: i64,
  pub CharacterAIId: i64,
  pub ExternalBTId: i64,
  pub MainCombatStyleId: i64,
  pub CombatStyleIndex: i32,
  pub ScenarioCharacter: Option<String>,
  pub SpawnTemplateId: u32,
  pub FavorLevelupType: i32,
  pub EquipmentSlot: Option<Vec<EquipmentCategory>>,
  pub WeaponLocalizeId: u32,
  pub DisplayEnemyInfo: bool,
  pub bodyRadius: i64,
  pub RandomEffectRadius: i64,
  pub HPBarHide: bool,
  pub HpBarHeight: f32,
  pub HighlightFloaterHeight: f32,
  pub EmojiOffsetX: f32,
  pub EmojiOffsetY: f32,
  pub MoveStartFrame: i32,
  pub MoveEndFrame: i32,
  pub JumpMotionFrame: i32,
  pub AppearFrame: i32,
  pub CanMove: bool,
  pub CanFix: bool,
  pub CanCrowdControl: bool,
  pub CanBattleItemMove: bool,
  pub IgnoreObstacle: bool,
  pub IsAirUnit: bool,
  pub AirUnitHeight: i64,
  pub Tags: Option<Vec<Tag>>,
  pub SecretStoneItemId: i64,
  pub SecretStoneItemAmount: i32,
  pub CharacterPieceItemId: i64,
  pub CharacterPieceItemAmount: i32,
  pub CombineRecipeId: i64,
}
impl Default for CharacterExcelT {
  fn default() -> Self {
    Self {
      Id: 0,
      DevName: None,
      CostumeGroupId: 0,
      IsPlayable: false,
      ProductionStep: ProductionStep::ToDo,
      CollectionVisible: false,
      ReleaseDate: None,
      CollectionVisibleStartDate: None,
      CollectionVisibleEndDate: None,
      isPlayableCharacter: false,
      LocalizeEtcId: 0,
      Rarity: Rarity::N,
      IsNPC: false,
      TacticEntityType: TacticEntityType::None,
      CanSurvive: false,
      IsDummy: false,
      SubPartsCount: 0,
      TacticRole: TacticRole::None,
      WeaponType: WeaponType::None,
      TacticRange: TacticRange::Back,
      BulletType: BulletType::Normal,
      ArmorType: ArmorType::LightArmor,
      AimIKType: AimIKType::None,
      School: School::None,
      Club: Club::None,
      DefaultStarGrade: 0,
      MaxStarGrade: 0,
      StatLevelUpType: StatLevelUpType::Standard,
      SquadType: SquadType::None,
      Jumpable: false,
      PersonalityId: 0,
      CharacterAIId: 0,
      ExternalBTId: 0,
      MainCombatStyleId: 0,
      CombatStyleIndex: 0,
      ScenarioCharacter: None,
      SpawnTemplateId: 0,
      FavorLevelupType: 0,
      EquipmentSlot: None,
      WeaponLocalizeId: 0,
      DisplayEnemyInfo: false,
      bodyRadius: 0,
      RandomEffectRadius: 0,
      HPBarHide: false,
      HpBarHeight: 0.0,
      HighlightFloaterHeight: 0.0,
      EmojiOffsetX: 0.0,
      EmojiOffsetY: 0.0,
      MoveStartFrame: 0,
      MoveEndFrame: 0,
      JumpMotionFrame: 0,
      AppearFrame: 0,
      CanMove: false,
      CanFix: false,
      CanCrowdControl: false,
      CanBattleItemMove: false,
      IgnoreObstacle: false,
      IsAirUnit: false,
      AirUnitHeight: 0,
      Tags: None,
      SecretStoneItemId: 0,
      SecretStoneItemAmount: 0,
      CharacterPieceItemId: 0,
      CharacterPieceItemAmount: 0,
      CombineRecipeId: 0,
    }
  }
}
impl CharacterExcelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CharacterExcel<'b>> {
    let Id = self.Id;
    let DevName = self.DevName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CostumeGroupId = self.CostumeGroupId;
    let IsPlayable = self.IsPlayable;
    let ProductionStep = self.ProductionStep;
    let CollectionVisible = self.CollectionVisible;
    let ReleaseDate = self.ReleaseDate.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CollectionVisibleStartDate = self.CollectionVisibleStartDate.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CollectionVisibleEndDate = self.CollectionVisibleEndDate.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let isPlayableCharacter = self.isPlayableCharacter;
    let LocalizeEtcId = self.LocalizeEtcId;
    let Rarity = self.Rarity;
    let IsNPC = self.IsNPC;
    let TacticEntityType = self.TacticEntityType;
    let CanSurvive = self.CanSurvive;
    let IsDummy = self.IsDummy;
    let SubPartsCount = self.SubPartsCount;
    let TacticRole = self.TacticRole;
    let WeaponType = self.WeaponType;
    let TacticRange = self.TacticRange;
    let BulletType = self.BulletType;
    let ArmorType = self.ArmorType;
    let AimIKType = self.AimIKType;
    let School = self.School;
    let Club = self.Club;
    let DefaultStarGrade = self.DefaultStarGrade;
    let MaxStarGrade = self.MaxStarGrade;
    let StatLevelUpType = self.StatLevelUpType;
    let SquadType = self.SquadType;
    let Jumpable = self.Jumpable;
    let PersonalityId = self.PersonalityId;
    let CharacterAIId = self.CharacterAIId;
    let ExternalBTId = self.ExternalBTId;
    let MainCombatStyleId = self.MainCombatStyleId;
    let CombatStyleIndex = self.CombatStyleIndex;
    let ScenarioCharacter = self.ScenarioCharacter.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SpawnTemplateId = self.SpawnTemplateId;
    let FavorLevelupType = self.FavorLevelupType;
    let EquipmentSlot = self.EquipmentSlot.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let WeaponLocalizeId = self.WeaponLocalizeId;
    let DisplayEnemyInfo = self.DisplayEnemyInfo;
    let bodyRadius = self.bodyRadius;
    let RandomEffectRadius = self.RandomEffectRadius;
    let HPBarHide = self.HPBarHide;
    let HpBarHeight = self.HpBarHeight;
    let HighlightFloaterHeight = self.HighlightFloaterHeight;
    let EmojiOffsetX = self.EmojiOffsetX;
    let EmojiOffsetY = self.EmojiOffsetY;
    let MoveStartFrame = self.MoveStartFrame;
    let MoveEndFrame = self.MoveEndFrame;
    let JumpMotionFrame = self.JumpMotionFrame;
    let AppearFrame = self.AppearFrame;
    let CanMove = self.CanMove;
    let CanFix = self.CanFix;
    let CanCrowdControl = self.CanCrowdControl;
    let CanBattleItemMove = self.CanBattleItemMove;
    let IgnoreObstacle = self.IgnoreObstacle;
    let IsAirUnit = self.IsAirUnit;
    let AirUnitHeight = self.AirUnitHeight;
    let Tags = self.Tags.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let SecretStoneItemId = self.SecretStoneItemId;
    let SecretStoneItemAmount = self.SecretStoneItemAmount;
    let CharacterPieceItemId = self.CharacterPieceItemId;
    let CharacterPieceItemAmount = self.CharacterPieceItemAmount;
    let CombineRecipeId = self.CombineRecipeId;
    CharacterExcel::create(_fbb, &CharacterExcelArgs{
      Id,
      DevName,
      CostumeGroupId,
      IsPlayable,
      ProductionStep,
      CollectionVisible,
      ReleaseDate,
      CollectionVisibleStartDate,
      CollectionVisibleEndDate,
      isPlayableCharacter,
      LocalizeEtcId,
      Rarity,
      IsNPC,
      TacticEntityType,
      CanSurvive,
      IsDummy,
      SubPartsCount,
      TacticRole,
      WeaponType,
      TacticRange,
      BulletType,
      ArmorType,
      AimIKType,
      School,
      Club,
      DefaultStarGrade,
      MaxStarGrade,
      StatLevelUpType,
      SquadType,
      Jumpable,
      PersonalityId,
      CharacterAIId,
      ExternalBTId,
      MainCombatStyleId,
      CombatStyleIndex,
      ScenarioCharacter,
      SpawnTemplateId,
      FavorLevelupType,
      EquipmentSlot,
      WeaponLocalizeId,
      DisplayEnemyInfo,
      bodyRadius,
      RandomEffectRadius,
      HPBarHide,
      HpBarHeight,
      HighlightFloaterHeight,
      EmojiOffsetX,
      EmojiOffsetY,
      MoveStartFrame,
      MoveEndFrame,
      JumpMotionFrame,
      AppearFrame,
      CanMove,
      CanFix,
      CanCrowdControl,
      CanBattleItemMove,
      IgnoreObstacle,
      IsAirUnit,
      AirUnitHeight,
      Tags,
      SecretStoneItemId,
      SecretStoneItemAmount,
      CharacterPieceItemId,
      CharacterPieceItemAmount,
      CombineRecipeId,
    })
  }
}
