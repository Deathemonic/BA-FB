// automatically generated by the FlatBuffers compiler, do not modify
// @generated
#![allow(unused_imports, dead_code)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum BattleExcelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BattleExcel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BattleExcel<'a> {
  type Inner = BattleExcel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BattleExcel<'a> {
  pub const VT_NONE: flatbuffers::VOffsetT = 4;
  pub const VT_SINGLE: flatbuffers::VOffsetT = 6;
  pub const VT_GUIDED: flatbuffers::VOffsetT = 8;
  pub const VT_BLUE: flatbuffers::VOffsetT = 10;
  pub const VT_COVERENTER: flatbuffers::VOffsetT = 12;
  pub const VT_NORMAL: flatbuffers::VOffsetT = 14;
  pub const VT_CRUSH: flatbuffers::VOffsetT = 16;
  pub const VT_ABLE: flatbuffers::VOffsetT = 18;
  pub const VT_ALLYSELF: flatbuffers::VOffsetT = 20;
  pub const VT_LIGHTARMOR: flatbuffers::VOffsetT = 22;
  pub const VT_WOOD: flatbuffers::VOffsetT = 24;
  pub const VT_ALL: flatbuffers::VOffsetT = 26;
  pub const VT_DISTANCE: flatbuffers::VOffsetT = 28;
  pub const VT_CLOSETOOBSTACLE: flatbuffers::VOffsetT = 30;
  pub const VT_STUDENTS: flatbuffers::VOffsetT = 32;
  pub const VT_SEQUENCE: flatbuffers::VOffsetT = 34;
  pub const VT_USENEXTEXSKILL: flatbuffers::VOffsetT = 36;
  pub const VT_STUDENT: flatbuffers::VOffsetT = 38;
  pub const VT_SEARCHANDMOVE: flatbuffers::VOffsetT = 40;
  pub const VT_POSITION: flatbuffers::VOffsetT = 42;
  pub const VT_STREET: flatbuffers::VOffsetT = 44;
  pub const VT_D: flatbuffers::VOffsetT = 46;
  pub const VT_MAIN: flatbuffers::VOffsetT = 48;
  pub const VT_REMAIN: flatbuffers::VOffsetT = 50;
  pub const VT_LOW: flatbuffers::VOffsetT = 52;
  pub const VT_RESIST: flatbuffers::VOffsetT = 54;
  pub const VT_ALLY: flatbuffers::VOffsetT = 56;
  pub const VT_MAIN: flatbuffers::VOffsetT = 58;
  pub const VT_TARGETTOCASTER: flatbuffers::VOffsetT = 60;
  pub const VT_DURATION: flatbuffers::VOffsetT = 62;
  pub const VT_PRESET: flatbuffers::VOffsetT = 64;
  pub const VT_FINALDAMAGE: flatbuffers::VOffsetT = 66;
  pub const VT_SPECIALTRANSSTAT: flatbuffers::VOffsetT = 68;
  pub const VT_TALK: flatbuffers::VOffsetT = 70;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BattleExcel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BattleExcelArgs<'args>
  ) -> flatbuffers::WIPOffset<BattleExcel<'bldr>> {
    let mut builder = BattleExcelBuilder::new(_fbb);
    let key = table_encryption_service::create_key(b"Battle");
      let x = args.Talk;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_Talk(x);
      let x = args.SpecialTransStat;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_SpecialTransStat(x);
      let x = args.FinalDamage;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_FinalDamage(x);
      let x = args.Preset;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_Preset(x);
      let x = args.Duration;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_Duration(x);
      let x = args.TargetToCaster;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_TargetToCaster(x);
      let x = args.Main;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_Main(x);
      let x = args.Ally;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_Ally(x);
      let x = args.Resist;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_Resist(x);
      let x = args.Low;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_Low(x);
      let x = args.Remain;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_Remain(x);
      let x = args.MAIN;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_MAIN(x);
      let x = args.D;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_D(x);
      let x = args.Street;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_Street(x);
      let x = args.Position;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_Position(x);
      let x = args.SearchAndMove;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_SearchAndMove(x);
      let x = args.Student;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_Student(x);
      let x = args.UseNextExSkill;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_UseNextExSkill(x);
      let x = args.Sequence;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_Sequence(x);
      let x = args.Students;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_Students(x);
      let x = args.CloseToObstacle;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_CloseToObstacle(x);
      let x = args.DISTANCE;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_DISTANCE(x);
      let x = args.All;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_All(x);
      let x = args.Wood;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_Wood(x);
      let x = args.LightArmor;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_LightArmor(x);
      let x = args.AllySelf;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_AllySelf(x);
      let x = args.Able;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_Able(x);
      let x = args.Crush;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_Crush(x);
      if let Some(x) = args.normal {
        builder.add_normal(x);
      }
      let x = args.CoverEnter;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_CoverEnter(x);
      let x = args.Blue;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_Blue(x);
      let x = args.Guided;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_Guided(x);
      let x = args.Single;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_Single(x);
      if let Some(x) = args.none {
        builder.add_none(x);
      }
    builder.finish()
  }

  pub fn unpack(&self) -> BattleExcelT {
    let key = table_encryption_service::create_key(b"Battle");
    let none = self.none().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(*val, &key) } else { *val }).collect()
    });
      let Single = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.Single(), &key)
      } else {
        self.Single()
      };
      let Guided = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.Guided(), &key)
      } else {
        self.Guided()
      };
      let Blue = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.Blue(), &key)
      } else {
        self.Blue()
      };
      let CoverEnter = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.CoverEnter(), &key)
      } else {
        self.CoverEnter()
      };
    let normal = self.normal().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(*val, &key) } else { *val }).collect()
    });
      let Crush = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.Crush(), &key)
      } else {
        self.Crush()
      };
      let Able = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.Able(), &key)
      } else {
        self.Able()
      };
      let AllySelf = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.AllySelf(), &key)
      } else {
        self.AllySelf()
      };
      let LightArmor = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.LightArmor(), &key)
      } else {
        self.LightArmor()
      };
      let Wood = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.Wood(), &key)
      } else {
        self.Wood()
      };
      let All = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.All(), &key)
      } else {
        self.All()
      };
      let DISTANCE = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.DISTANCE(), &key)
      } else {
        self.DISTANCE()
      };
      let CloseToObstacle = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.CloseToObstacle(), &key)
      } else {
        self.CloseToObstacle()
      };
      let Students = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.Students(), &key)
      } else {
        self.Students()
      };
      let Sequence = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.Sequence(), &key)
      } else {
        self.Sequence()
      };
      let UseNextExSkill = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.UseNextExSkill(), &key)
      } else {
        self.UseNextExSkill()
      };
      let Student = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.Student(), &key)
      } else {
        self.Student()
      };
      let SearchAndMove = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.SearchAndMove(), &key)
      } else {
        self.SearchAndMove()
      };
      let Position = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.Position(), &key)
      } else {
        self.Position()
      };
      let Street = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.Street(), &key)
      } else {
        self.Street()
      };
      let D = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.D(), &key)
      } else {
        self.D()
      };
      let MAIN = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.MAIN(), &key)
      } else {
        self.MAIN()
      };
      let Remain = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.Remain(), &key)
      } else {
        self.Remain()
      };
      let Low = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.Low(), &key)
      } else {
        self.Low()
      };
      let Resist = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.Resist(), &key)
      } else {
        self.Resist()
      };
      let Ally = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.Ally(), &key)
      } else {
        self.Ally()
      };
      let Main = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.Main(), &key)
      } else {
        self.Main()
      };
      let TargetToCaster = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.TargetToCaster(), &key)
      } else {
        self.TargetToCaster()
      };
      let Duration = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.Duration(), &key)
      } else {
        self.Duration()
      };
      let Preset = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.Preset(), &key)
      } else {
        self.Preset()
      };
      let FinalDamage = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.FinalDamage(), &key)
      } else {
        self.FinalDamage()
      };
      let SpecialTransStat = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.SpecialTransStat(), &key)
      } else {
        self.SpecialTransStat()
      };
      let Talk = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.Talk(), &key)
      } else {
        self.Talk()
      };
    BattleExcelT {
      none,
      Single,
      Guided,
      Blue,
      CoverEnter,
      normal,
      Crush,
      Able,
      AllySelf,
      LightArmor,
      Wood,
      All,
      DISTANCE,
      CloseToObstacle,
      Students,
      Sequence,
      UseNextExSkill,
      Student,
      SearchAndMove,
      Position,
      Street,
      D,
      MAIN,
      Remain,
      Low,
      Resist,
      Ally,
      Main,
      TargetToCaster,
      Duration,
      Preset,
      FinalDamage,
      SpecialTransStat,
      Talk,
    }
  }

  #[inline]
  pub fn none(&self) -> Option<flatbuffers::Vector<'a, UnitType>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, UnitType>>>(BattleExcel::VT_NONE, None)}
  }
  #[inline]
  pub fn Single(&self) -> AttackType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<AttackType>(BattleExcel::VT_SINGLE, Some(AttackType::Single)).unwrap()}
  }
  #[inline]
  pub fn Guided(&self) -> ProjectileType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ProjectileType>(BattleExcel::VT_GUIDED, Some(ProjectileType::Guided)).unwrap()}
  }
  #[inline]
  pub fn Blue(&self) -> DamageFontColor {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DamageFontColor>(BattleExcel::VT_BLUE, Some(DamageFontColor::Blue)).unwrap()}
  }
  #[inline]
  pub fn CoverEnter(&self) -> EmoticonEvent {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<EmoticonEvent>(BattleExcel::VT_COVERENTER, Some(EmoticonEvent::CoverEnter)).unwrap()}
  }
  #[inline]
  pub fn normal(&self) -> Option<flatbuffers::Vector<'a, BulletType>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, BulletType>>>(BattleExcel::VT_NORMAL, None)}
  }
  #[inline]
  pub fn Crush(&self) -> ActionType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ActionType>(BattleExcel::VT_CRUSH, Some(ActionType::Crush)).unwrap()}
  }
  #[inline]
  pub fn Able(&self) -> BuffOverlap {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<BuffOverlap>(BattleExcel::VT_ABLE, Some(BuffOverlap::Able)).unwrap()}
  }
  #[inline]
  pub fn AllySelf(&self) -> ReArrangeTargetType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ReArrangeTargetType>(BattleExcel::VT_ALLYSELF, Some(ReArrangeTargetType::AllySelf)).unwrap()}
  }
  #[inline]
  pub fn LightArmor(&self) -> ArmorType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ArmorType>(BattleExcel::VT_LIGHTARMOR, Some(ArmorType::LightArmor)).unwrap()}
  }
  #[inline]
  pub fn Wood(&self) -> EntityMaterialType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<EntityMaterialType>(BattleExcel::VT_WOOD, Some(EntityMaterialType::Wood)).unwrap()}
  }
  #[inline]
  pub fn All(&self) -> CoverMotionType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<CoverMotionType>(BattleExcel::VT_ALL, Some(CoverMotionType::All)).unwrap()}
  }
  #[inline]
  pub fn DISTANCE(&self) -> TargetSortBy {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TargetSortBy>(BattleExcel::VT_DISTANCE, Some(TargetSortBy::DISTANCE)).unwrap()}
  }
  #[inline]
  pub fn CloseToObstacle(&self) -> PositioningType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<PositioningType>(BattleExcel::VT_CLOSETOOBSTACLE, Some(PositioningType::CloseToObstacle)).unwrap()}
  }
  #[inline]
  pub fn Students(&self) -> FormationLine {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<FormationLine>(BattleExcel::VT_STUDENTS, Some(FormationLine::Students)).unwrap()}
  }
  #[inline]
  pub fn Sequence(&self) -> ExternalBTNodeType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ExternalBTNodeType>(BattleExcel::VT_SEQUENCE, Some(ExternalBTNodeType::Sequence)).unwrap()}
  }
  #[inline]
  pub fn UseNextExSkill(&self) -> ExternalBehavior {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ExternalBehavior>(BattleExcel::VT_USENEXTEXSKILL, Some(ExternalBehavior::UseNextExSkill)).unwrap()}
  }
  #[inline]
  pub fn Student(&self) -> TacticEntityType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TacticEntityType>(BattleExcel::VT_STUDENT, Some(TacticEntityType::None)).unwrap()}
  }
  #[inline]
  pub fn SearchAndMove(&self) -> EngageType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<EngageType>(BattleExcel::VT_SEARCHANDMOVE, Some(EngageType::SearchAndMove)).unwrap()}
  }
  #[inline]
  pub fn Position(&self) -> HitEffectPosition {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<HitEffectPosition>(BattleExcel::VT_POSITION, Some(HitEffectPosition::Position)).unwrap()}
  }
  #[inline]
  pub fn Street(&self) -> StageTopography {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<StageTopography>(BattleExcel::VT_STREET, Some(StageTopography::Street)).unwrap()}
  }
  #[inline]
  pub fn D(&self) -> TerrainAdaptationStat {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TerrainAdaptationStat>(BattleExcel::VT_D, Some(TerrainAdaptationStat::D)).unwrap()}
  }
  #[inline]
  pub fn MAIN(&self) -> ObstacleClass {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ObstacleClass>(BattleExcel::VT_MAIN, Some(ObstacleClass::MAIN)).unwrap()}
  }
  #[inline]
  pub fn Remain(&self) -> ObstacleDestroyType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ObstacleDestroyType>(BattleExcel::VT_REMAIN, Some(ObstacleDestroyType::Remain)).unwrap()}
  }
  #[inline]
  pub fn Low(&self) -> ObstacleHeightType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ObstacleHeightType>(BattleExcel::VT_LOW, Some(ObstacleHeightType::Low)).unwrap()}
  }
  #[inline]
  pub fn Resist(&self) -> DamageAttribute {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DamageAttribute>(BattleExcel::VT_RESIST, Some(DamageAttribute::Resist)).unwrap()}
  }
  #[inline]
  pub fn Ally(&self) -> SkillPriorityCheckTarget {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SkillPriorityCheckTarget>(BattleExcel::VT_ALLY, Some(SkillPriorityCheckTarget::Ally)).unwrap()}
  }
  #[inline]
  pub fn Main(&self) -> StageType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<StageType>(BattleExcel::VT_MAIN, Some(StageType::Main)).unwrap()}
  }
  #[inline]
  pub fn TargetToCaster(&self) -> KnockbackDirection {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<KnockbackDirection>(BattleExcel::VT_TARGETTOCASTER, Some(KnockbackDirection::TargetToCaster)).unwrap()}
  }
  #[inline]
  pub fn Duration(&self) -> EndCondition {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<EndCondition>(BattleExcel::VT_DURATION, Some(EndCondition::Duration)).unwrap()}
  }
  #[inline]
  pub fn Preset(&self) -> ArenaSimulatorServer {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ArenaSimulatorServer>(BattleExcel::VT_PRESET, Some(ArenaSimulatorServer::Preset)).unwrap()}
  }
  #[inline]
  pub fn FinalDamage(&self) -> BattleCalculationStat {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<BattleCalculationStat>(BattleExcel::VT_FINALDAMAGE, Some(BattleCalculationStat::FinalDamage)).unwrap()}
  }
  #[inline]
  pub fn SpecialTransStat(&self) -> StatTransType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<StatTransType>(BattleExcel::VT_SPECIALTRANSSTAT, Some(StatTransType::SpecialTransStat)).unwrap()}
  }
  #[inline]
  pub fn Talk(&self) -> BattleDialogType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<BattleDialogType>(BattleExcel::VT_TALK, Some(BattleDialogType::Talk)).unwrap()}
  }
}

impl flatbuffers::Verifiable for BattleExcel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, UnitType>>>("none", Self::VT_NONE, false)?
     .visit_field::<AttackType>("Single", Self::VT_SINGLE, false)?
     .visit_field::<ProjectileType>("Guided", Self::VT_GUIDED, false)?
     .visit_field::<DamageFontColor>("Blue", Self::VT_BLUE, false)?
     .visit_field::<EmoticonEvent>("CoverEnter", Self::VT_COVERENTER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, BulletType>>>("normal", Self::VT_NORMAL, false)?
     .visit_field::<ActionType>("Crush", Self::VT_CRUSH, false)?
     .visit_field::<BuffOverlap>("Able", Self::VT_ABLE, false)?
     .visit_field::<ReArrangeTargetType>("AllySelf", Self::VT_ALLYSELF, false)?
     .visit_field::<ArmorType>("LightArmor", Self::VT_LIGHTARMOR, false)?
     .visit_field::<EntityMaterialType>("Wood", Self::VT_WOOD, false)?
     .visit_field::<CoverMotionType>("All", Self::VT_ALL, false)?
     .visit_field::<TargetSortBy>("DISTANCE", Self::VT_DISTANCE, false)?
     .visit_field::<PositioningType>("CloseToObstacle", Self::VT_CLOSETOOBSTACLE, false)?
     .visit_field::<FormationLine>("Students", Self::VT_STUDENTS, false)?
     .visit_field::<ExternalBTNodeType>("Sequence", Self::VT_SEQUENCE, false)?
     .visit_field::<ExternalBehavior>("UseNextExSkill", Self::VT_USENEXTEXSKILL, false)?
     .visit_field::<TacticEntityType>("Student", Self::VT_STUDENT, false)?
     .visit_field::<EngageType>("SearchAndMove", Self::VT_SEARCHANDMOVE, false)?
     .visit_field::<HitEffectPosition>("Position", Self::VT_POSITION, false)?
     .visit_field::<StageTopography>("Street", Self::VT_STREET, false)?
     .visit_field::<TerrainAdaptationStat>("D", Self::VT_D, false)?
     .visit_field::<ObstacleClass>("MAIN", Self::VT_MAIN, false)?
     .visit_field::<ObstacleDestroyType>("Remain", Self::VT_REMAIN, false)?
     .visit_field::<ObstacleHeightType>("Low", Self::VT_LOW, false)?
     .visit_field::<DamageAttribute>("Resist", Self::VT_RESIST, false)?
     .visit_field::<SkillPriorityCheckTarget>("Ally", Self::VT_ALLY, false)?
     .visit_field::<StageType>("Main", Self::VT_MAIN, false)?
     .visit_field::<KnockbackDirection>("TargetToCaster", Self::VT_TARGETTOCASTER, false)?
     .visit_field::<EndCondition>("Duration", Self::VT_DURATION, false)?
     .visit_field::<ArenaSimulatorServer>("Preset", Self::VT_PRESET, false)?
     .visit_field::<BattleCalculationStat>("FinalDamage", Self::VT_FINALDAMAGE, false)?
     .visit_field::<StatTransType>("SpecialTransStat", Self::VT_SPECIALTRANSSTAT, false)?
     .visit_field::<BattleDialogType>("Talk", Self::VT_TALK, false)?
     .finish();
    Ok(())
  }
}
pub struct BattleExcelArgs<'a> {
    pub none: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, UnitType>>>,
    pub Single: AttackType,
    pub Guided: ProjectileType,
    pub Blue: DamageFontColor,
    pub CoverEnter: EmoticonEvent,
    pub normal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, BulletType>>>,
    pub Crush: ActionType,
    pub Able: BuffOverlap,
    pub AllySelf: ReArrangeTargetType,
    pub LightArmor: ArmorType,
    pub Wood: EntityMaterialType,
    pub All: CoverMotionType,
    pub DISTANCE: TargetSortBy,
    pub CloseToObstacle: PositioningType,
    pub Students: FormationLine,
    pub Sequence: ExternalBTNodeType,
    pub UseNextExSkill: ExternalBehavior,
    pub Student: TacticEntityType,
    pub SearchAndMove: EngageType,
    pub Position: HitEffectPosition,
    pub Street: StageTopography,
    pub D: TerrainAdaptationStat,
    pub MAIN: ObstacleClass,
    pub Remain: ObstacleDestroyType,
    pub Low: ObstacleHeightType,
    pub Resist: DamageAttribute,
    pub Ally: SkillPriorityCheckTarget,
    pub Main: StageType,
    pub TargetToCaster: KnockbackDirection,
    pub Duration: EndCondition,
    pub Preset: ArenaSimulatorServer,
    pub FinalDamage: BattleCalculationStat,
    pub SpecialTransStat: StatTransType,
    pub Talk: BattleDialogType,
}
impl<'a> Default for BattleExcelArgs<'a> {
  #[inline]
  fn default() -> Self {
    BattleExcelArgs {
      none: None,
      Single: AttackType::Single,
      Guided: ProjectileType::Guided,
      Blue: DamageFontColor::Blue,
      CoverEnter: EmoticonEvent::CoverEnter,
      normal: None,
      Crush: ActionType::Crush,
      Able: BuffOverlap::Able,
      AllySelf: ReArrangeTargetType::AllySelf,
      LightArmor: ArmorType::LightArmor,
      Wood: EntityMaterialType::Wood,
      All: CoverMotionType::All,
      DISTANCE: TargetSortBy::DISTANCE,
      CloseToObstacle: PositioningType::CloseToObstacle,
      Students: FormationLine::Students,
      Sequence: ExternalBTNodeType::Sequence,
      UseNextExSkill: ExternalBehavior::UseNextExSkill,
      Student: TacticEntityType::None,
      SearchAndMove: EngageType::SearchAndMove,
      Position: HitEffectPosition::Position,
      Street: StageTopography::Street,
      D: TerrainAdaptationStat::D,
      MAIN: ObstacleClass::MAIN,
      Remain: ObstacleDestroyType::Remain,
      Low: ObstacleHeightType::Low,
      Resist: DamageAttribute::Resist,
      Ally: SkillPriorityCheckTarget::Ally,
      Main: StageType::Main,
      TargetToCaster: KnockbackDirection::TargetToCaster,
      Duration: EndCondition::Duration,
      Preset: ArenaSimulatorServer::Preset,
      FinalDamage: BattleCalculationStat::FinalDamage,
      SpecialTransStat: StatTransType::SpecialTransStat,
      Talk: BattleDialogType::Talk,
    }
  }
}

impl Serialize for BattleExcel<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("BattleExcel", 34)?;
      if let Some(f) = self.none() {
        s.serialize_field("none", &f)?;
      } else {
        s.skip_field("none")?;
      }
      s.serialize_field("Single", &self.Single())?;
      s.serialize_field("Guided", &self.Guided())?;
      s.serialize_field("Blue", &self.Blue())?;
      s.serialize_field("CoverEnter", &self.CoverEnter())?;
      if let Some(f) = self.normal() {
        s.serialize_field("normal", &f)?;
      } else {
        s.skip_field("normal")?;
      }
      s.serialize_field("Crush", &self.Crush())?;
      s.serialize_field("Able", &self.Able())?;
      s.serialize_field("AllySelf", &self.AllySelf())?;
      s.serialize_field("LightArmor", &self.LightArmor())?;
      s.serialize_field("Wood", &self.Wood())?;
      s.serialize_field("All", &self.All())?;
      s.serialize_field("DISTANCE", &self.DISTANCE())?;
      s.serialize_field("CloseToObstacle", &self.CloseToObstacle())?;
      s.serialize_field("Students", &self.Students())?;
      s.serialize_field("Sequence", &self.Sequence())?;
      s.serialize_field("UseNextExSkill", &self.UseNextExSkill())?;
      s.serialize_field("Student", &self.Student())?;
      s.serialize_field("SearchAndMove", &self.SearchAndMove())?;
      s.serialize_field("Position", &self.Position())?;
      s.serialize_field("Street", &self.Street())?;
      s.serialize_field("D", &self.D())?;
      s.serialize_field("MAIN", &self.MAIN())?;
      s.serialize_field("Remain", &self.Remain())?;
      s.serialize_field("Low", &self.Low())?;
      s.serialize_field("Resist", &self.Resist())?;
      s.serialize_field("Ally", &self.Ally())?;
      s.serialize_field("Main", &self.Main())?;
      s.serialize_field("TargetToCaster", &self.TargetToCaster())?;
      s.serialize_field("Duration", &self.Duration())?;
      s.serialize_field("Preset", &self.Preset())?;
      s.serialize_field("FinalDamage", &self.FinalDamage())?;
      s.serialize_field("SpecialTransStat", &self.SpecialTransStat())?;
      s.serialize_field("Talk", &self.Talk())?;
    s.end()
  }
}

pub struct BattleExcelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BattleExcelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_none(&mut self, none: flatbuffers::WIPOffset<flatbuffers::Vector<'b , UnitType>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BattleExcel::VT_NONE, none);
  }
  #[inline]
  pub fn add_Single(&mut self, Single: AttackType) {
    self.fbb_.push_slot::<AttackType>(BattleExcel::VT_SINGLE, Single, AttackType::Single);
  }
  #[inline]
  pub fn add_Guided(&mut self, Guided: ProjectileType) {
    self.fbb_.push_slot::<ProjectileType>(BattleExcel::VT_GUIDED, Guided, ProjectileType::Guided);
  }
  #[inline]
  pub fn add_Blue(&mut self, Blue: DamageFontColor) {
    self.fbb_.push_slot::<DamageFontColor>(BattleExcel::VT_BLUE, Blue, DamageFontColor::Blue);
  }
  #[inline]
  pub fn add_CoverEnter(&mut self, CoverEnter: EmoticonEvent) {
    self.fbb_.push_slot::<EmoticonEvent>(BattleExcel::VT_COVERENTER, CoverEnter, EmoticonEvent::CoverEnter);
  }
  #[inline]
  pub fn add_normal(&mut self, normal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , BulletType>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BattleExcel::VT_NORMAL, normal);
  }
  #[inline]
  pub fn add_Crush(&mut self, Crush: ActionType) {
    self.fbb_.push_slot::<ActionType>(BattleExcel::VT_CRUSH, Crush, ActionType::Crush);
  }
  #[inline]
  pub fn add_Able(&mut self, Able: BuffOverlap) {
    self.fbb_.push_slot::<BuffOverlap>(BattleExcel::VT_ABLE, Able, BuffOverlap::Able);
  }
  #[inline]
  pub fn add_AllySelf(&mut self, AllySelf: ReArrangeTargetType) {
    self.fbb_.push_slot::<ReArrangeTargetType>(BattleExcel::VT_ALLYSELF, AllySelf, ReArrangeTargetType::AllySelf);
  }
  #[inline]
  pub fn add_LightArmor(&mut self, LightArmor: ArmorType) {
    self.fbb_.push_slot::<ArmorType>(BattleExcel::VT_LIGHTARMOR, LightArmor, ArmorType::LightArmor);
  }
  #[inline]
  pub fn add_Wood(&mut self, Wood: EntityMaterialType) {
    self.fbb_.push_slot::<EntityMaterialType>(BattleExcel::VT_WOOD, Wood, EntityMaterialType::Wood);
  }
  #[inline]
  pub fn add_All(&mut self, All: CoverMotionType) {
    self.fbb_.push_slot::<CoverMotionType>(BattleExcel::VT_ALL, All, CoverMotionType::All);
  }
  #[inline]
  pub fn add_DISTANCE(&mut self, DISTANCE: TargetSortBy) {
    self.fbb_.push_slot::<TargetSortBy>(BattleExcel::VT_DISTANCE, DISTANCE, TargetSortBy::DISTANCE);
  }
  #[inline]
  pub fn add_CloseToObstacle(&mut self, CloseToObstacle: PositioningType) {
    self.fbb_.push_slot::<PositioningType>(BattleExcel::VT_CLOSETOOBSTACLE, CloseToObstacle, PositioningType::CloseToObstacle);
  }
  #[inline]
  pub fn add_Students(&mut self, Students: FormationLine) {
    self.fbb_.push_slot::<FormationLine>(BattleExcel::VT_STUDENTS, Students, FormationLine::Students);
  }
  #[inline]
  pub fn add_Sequence(&mut self, Sequence: ExternalBTNodeType) {
    self.fbb_.push_slot::<ExternalBTNodeType>(BattleExcel::VT_SEQUENCE, Sequence, ExternalBTNodeType::Sequence);
  }
  #[inline]
  pub fn add_UseNextExSkill(&mut self, UseNextExSkill: ExternalBehavior) {
    self.fbb_.push_slot::<ExternalBehavior>(BattleExcel::VT_USENEXTEXSKILL, UseNextExSkill, ExternalBehavior::UseNextExSkill);
  }
  #[inline]
  pub fn add_Student(&mut self, Student: TacticEntityType) {
    self.fbb_.push_slot::<TacticEntityType>(BattleExcel::VT_STUDENT, Student, TacticEntityType::None);
  }
  #[inline]
  pub fn add_SearchAndMove(&mut self, SearchAndMove: EngageType) {
    self.fbb_.push_slot::<EngageType>(BattleExcel::VT_SEARCHANDMOVE, SearchAndMove, EngageType::SearchAndMove);
  }
  #[inline]
  pub fn add_Position(&mut self, Position: HitEffectPosition) {
    self.fbb_.push_slot::<HitEffectPosition>(BattleExcel::VT_POSITION, Position, HitEffectPosition::Position);
  }
  #[inline]
  pub fn add_Street(&mut self, Street: StageTopography) {
    self.fbb_.push_slot::<StageTopography>(BattleExcel::VT_STREET, Street, StageTopography::Street);
  }
  #[inline]
  pub fn add_D(&mut self, D: TerrainAdaptationStat) {
    self.fbb_.push_slot::<TerrainAdaptationStat>(BattleExcel::VT_D, D, TerrainAdaptationStat::D);
  }
  #[inline]
  pub fn add_MAIN(&mut self, MAIN: ObstacleClass) {
    self.fbb_.push_slot::<ObstacleClass>(BattleExcel::VT_MAIN, MAIN, ObstacleClass::MAIN);
  }
  #[inline]
  pub fn add_Remain(&mut self, Remain: ObstacleDestroyType) {
    self.fbb_.push_slot::<ObstacleDestroyType>(BattleExcel::VT_REMAIN, Remain, ObstacleDestroyType::Remain);
  }
  #[inline]
  pub fn add_Low(&mut self, Low: ObstacleHeightType) {
    self.fbb_.push_slot::<ObstacleHeightType>(BattleExcel::VT_LOW, Low, ObstacleHeightType::Low);
  }
  #[inline]
  pub fn add_Resist(&mut self, Resist: DamageAttribute) {
    self.fbb_.push_slot::<DamageAttribute>(BattleExcel::VT_RESIST, Resist, DamageAttribute::Resist);
  }
  #[inline]
  pub fn add_Ally(&mut self, Ally: SkillPriorityCheckTarget) {
    self.fbb_.push_slot::<SkillPriorityCheckTarget>(BattleExcel::VT_ALLY, Ally, SkillPriorityCheckTarget::Ally);
  }
  #[inline]
  pub fn add_Main(&mut self, Main: StageType) {
    self.fbb_.push_slot::<StageType>(BattleExcel::VT_MAIN, Main, StageType::Main);
  }
  #[inline]
  pub fn add_TargetToCaster(&mut self, TargetToCaster: KnockbackDirection) {
    self.fbb_.push_slot::<KnockbackDirection>(BattleExcel::VT_TARGETTOCASTER, TargetToCaster, KnockbackDirection::TargetToCaster);
  }
  #[inline]
  pub fn add_Duration(&mut self, Duration: EndCondition) {
    self.fbb_.push_slot::<EndCondition>(BattleExcel::VT_DURATION, Duration, EndCondition::Duration);
  }
  #[inline]
  pub fn add_Preset(&mut self, Preset: ArenaSimulatorServer) {
    self.fbb_.push_slot::<ArenaSimulatorServer>(BattleExcel::VT_PRESET, Preset, ArenaSimulatorServer::Preset);
  }
  #[inline]
  pub fn add_FinalDamage(&mut self, FinalDamage: BattleCalculationStat) {
    self.fbb_.push_slot::<BattleCalculationStat>(BattleExcel::VT_FINALDAMAGE, FinalDamage, BattleCalculationStat::FinalDamage);
  }
  #[inline]
  pub fn add_SpecialTransStat(&mut self, SpecialTransStat: StatTransType) {
    self.fbb_.push_slot::<StatTransType>(BattleExcel::VT_SPECIALTRANSSTAT, SpecialTransStat, StatTransType::SpecialTransStat);
  }
  #[inline]
  pub fn add_Talk(&mut self, Talk: BattleDialogType) {
    self.fbb_.push_slot::<BattleDialogType>(BattleExcel::VT_TALK, Talk, BattleDialogType::Talk);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BattleExcelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BattleExcelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BattleExcel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BattleExcel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BattleExcel");
      ds.field("none", &self.none());
      ds.field("Single", &self.Single());
      ds.field("Guided", &self.Guided());
      ds.field("Blue", &self.Blue());
      ds.field("CoverEnter", &self.CoverEnter());
      ds.field("normal", &self.normal());
      ds.field("Crush", &self.Crush());
      ds.field("Able", &self.Able());
      ds.field("AllySelf", &self.AllySelf());
      ds.field("LightArmor", &self.LightArmor());
      ds.field("Wood", &self.Wood());
      ds.field("All", &self.All());
      ds.field("DISTANCE", &self.DISTANCE());
      ds.field("CloseToObstacle", &self.CloseToObstacle());
      ds.field("Students", &self.Students());
      ds.field("Sequence", &self.Sequence());
      ds.field("UseNextExSkill", &self.UseNextExSkill());
      ds.field("Student", &self.Student());
      ds.field("SearchAndMove", &self.SearchAndMove());
      ds.field("Position", &self.Position());
      ds.field("Street", &self.Street());
      ds.field("D", &self.D());
      ds.field("MAIN", &self.MAIN());
      ds.field("Remain", &self.Remain());
      ds.field("Low", &self.Low());
      ds.field("Resist", &self.Resist());
      ds.field("Ally", &self.Ally());
      ds.field("Main", &self.Main());
      ds.field("TargetToCaster", &self.TargetToCaster());
      ds.field("Duration", &self.Duration());
      ds.field("Preset", &self.Preset());
      ds.field("FinalDamage", &self.FinalDamage());
      ds.field("SpecialTransStat", &self.SpecialTransStat());
      ds.field("Talk", &self.Talk());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct BattleExcelT {
  pub none: Option<Vec<UnitType>>,
  pub Single: AttackType,
  pub Guided: ProjectileType,
  pub Blue: DamageFontColor,
  pub CoverEnter: EmoticonEvent,
  pub normal: Option<Vec<BulletType>>,
  pub Crush: ActionType,
  pub Able: BuffOverlap,
  pub AllySelf: ReArrangeTargetType,
  pub LightArmor: ArmorType,
  pub Wood: EntityMaterialType,
  pub All: CoverMotionType,
  pub DISTANCE: TargetSortBy,
  pub CloseToObstacle: PositioningType,
  pub Students: FormationLine,
  pub Sequence: ExternalBTNodeType,
  pub UseNextExSkill: ExternalBehavior,
  pub Student: TacticEntityType,
  pub SearchAndMove: EngageType,
  pub Position: HitEffectPosition,
  pub Street: StageTopography,
  pub D: TerrainAdaptationStat,
  pub MAIN: ObstacleClass,
  pub Remain: ObstacleDestroyType,
  pub Low: ObstacleHeightType,
  pub Resist: DamageAttribute,
  pub Ally: SkillPriorityCheckTarget,
  pub Main: StageType,
  pub TargetToCaster: KnockbackDirection,
  pub Duration: EndCondition,
  pub Preset: ArenaSimulatorServer,
  pub FinalDamage: BattleCalculationStat,
  pub SpecialTransStat: StatTransType,
  pub Talk: BattleDialogType,
}
impl Default for BattleExcelT {
  fn default() -> Self {
    Self {
      none: None,
      Single: AttackType::Single,
      Guided: ProjectileType::Guided,
      Blue: DamageFontColor::Blue,
      CoverEnter: EmoticonEvent::CoverEnter,
      normal: None,
      Crush: ActionType::Crush,
      Able: BuffOverlap::Able,
      AllySelf: ReArrangeTargetType::AllySelf,
      LightArmor: ArmorType::LightArmor,
      Wood: EntityMaterialType::Wood,
      All: CoverMotionType::All,
      DISTANCE: TargetSortBy::DISTANCE,
      CloseToObstacle: PositioningType::CloseToObstacle,
      Students: FormationLine::Students,
      Sequence: ExternalBTNodeType::Sequence,
      UseNextExSkill: ExternalBehavior::UseNextExSkill,
      Student: TacticEntityType::None,
      SearchAndMove: EngageType::SearchAndMove,
      Position: HitEffectPosition::Position,
      Street: StageTopography::Street,
      D: TerrainAdaptationStat::D,
      MAIN: ObstacleClass::MAIN,
      Remain: ObstacleDestroyType::Remain,
      Low: ObstacleHeightType::Low,
      Resist: DamageAttribute::Resist,
      Ally: SkillPriorityCheckTarget::Ally,
      Main: StageType::Main,
      TargetToCaster: KnockbackDirection::TargetToCaster,
      Duration: EndCondition::Duration,
      Preset: ArenaSimulatorServer::Preset,
      FinalDamage: BattleCalculationStat::FinalDamage,
      SpecialTransStat: StatTransType::SpecialTransStat,
      Talk: BattleDialogType::Talk,
    }
  }
}
impl BattleExcelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<BattleExcel<'b>> {
    let none = self.none.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let Single = self.Single;
    let Guided = self.Guided;
    let Blue = self.Blue;
    let CoverEnter = self.CoverEnter;
    let normal = self.normal.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let Crush = self.Crush;
    let Able = self.Able;
    let AllySelf = self.AllySelf;
    let LightArmor = self.LightArmor;
    let Wood = self.Wood;
    let All = self.All;
    let DISTANCE = self.DISTANCE;
    let CloseToObstacle = self.CloseToObstacle;
    let Students = self.Students;
    let Sequence = self.Sequence;
    let UseNextExSkill = self.UseNextExSkill;
    let Student = self.Student;
    let SearchAndMove = self.SearchAndMove;
    let Position = self.Position;
    let Street = self.Street;
    let D = self.D;
    let MAIN = self.MAIN;
    let Remain = self.Remain;
    let Low = self.Low;
    let Resist = self.Resist;
    let Ally = self.Ally;
    let Main = self.Main;
    let TargetToCaster = self.TargetToCaster;
    let Duration = self.Duration;
    let Preset = self.Preset;
    let FinalDamage = self.FinalDamage;
    let SpecialTransStat = self.SpecialTransStat;
    let Talk = self.Talk;
    BattleExcel::create(_fbb, &BattleExcelArgs{
      none,
      Single,
      Guided,
      Blue,
      CoverEnter,
      normal,
      Crush,
      Able,
      AllySelf,
      LightArmor,
      Wood,
      All,
      DISTANCE,
      CloseToObstacle,
      Students,
      Sequence,
      UseNextExSkill,
      Student,
      SearchAndMove,
      Position,
      Street,
      D,
      MAIN,
      Remain,
      Low,
      Resist,
      Ally,
      Main,
      TargetToCaster,
      Duration,
      Preset,
      FinalDamage,
      SpecialTransStat,
      Talk,
    })
  }
}
