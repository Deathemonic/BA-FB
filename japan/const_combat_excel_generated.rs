// automatically generated by the FlatBuffers compiler, do not modify
// @generated
#![allow(unused_imports, dead_code)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum ConstCombatExcelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ConstCombatExcel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConstCombatExcel<'a> {
  type Inner = ConstCombatExcel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ConstCombatExcel<'a> {
  pub const VT_SKILLHANDCOUNT: flatbuffers::VOffsetT = 4;
  pub const VT_DYINGTIME: flatbuffers::VOffsetT = 6;
  pub const VT_BUFFICONBLINKTIME: flatbuffers::VOffsetT = 8;
  pub const VT_SHOWBUFFICONEXSKILL: flatbuffers::VOffsetT = 10;
  pub const VT_SHOWBUFFICONPASSIVESKILL: flatbuffers::VOffsetT = 12;
  pub const VT_SHOWBUFFICONEXTRAPASSIVESKILL: flatbuffers::VOffsetT = 14;
  pub const VT_SHOWBUFFICONLEADERSKILL: flatbuffers::VOffsetT = 16;
  pub const VT_SHOWBUFFICONGROUNDPASSIVESKILL: flatbuffers::VOffsetT = 18;
  pub const VT_SUPPLIESCONDITIONSTRINGID: flatbuffers::VOffsetT = 20;
  pub const VT_PUBLICSPEECHBUBBLEOFFSETX: flatbuffers::VOffsetT = 22;
  pub const VT_PUBLICSPEECHBUBBLEOFFSETY: flatbuffers::VOffsetT = 24;
  pub const VT_PUBLICSPEECHBUBBLEOFFSETZ: flatbuffers::VOffsetT = 26;
  pub const VT_SHOWRAIDLISTCOUNT: flatbuffers::VOffsetT = 28;
  pub const VT_MAXRAIDTICKETCOUNT: flatbuffers::VOffsetT = 30;
  pub const VT_MAXRAIDBOSSSKILLSLOT: flatbuffers::VOffsetT = 32;
  pub const VT_ENGAGETIMELINEPATH: flatbuffers::VOffsetT = 34;
  pub const VT_ENGAGEWITHSUPPORTERTIMELINEPATH: flatbuffers::VOffsetT = 36;
  pub const VT_VICTORYTIMELINEPATH: flatbuffers::VOffsetT = 38;
  pub const VT_TIMELIMITALARM: flatbuffers::VOffsetT = 40;
  pub const VT_ECHELONMAXCOMMONCOST: flatbuffers::VOffsetT = 42;
  pub const VT_ECHELONINITCOMMONCOST: flatbuffers::VOffsetT = 44;
  pub const VT_SKILLSLOTCOOLTIME: flatbuffers::VOffsetT = 46;
  pub const VT_ENEMYREGENCOST: flatbuffers::VOffsetT = 48;
  pub const VT_CHAMPIONREGENCOST: flatbuffers::VOffsetT = 50;
  pub const VT_PLAYERREGENCOSTDELAY: flatbuffers::VOffsetT = 52;
  pub const VT_CROWDCONTROLFACTOR: flatbuffers::VOffsetT = 54;
  pub const VT_RAIDOPENSCENARIOID: flatbuffers::VOffsetT = 56;
  pub const VT_ELIMINATERAIDOPENSCENARIOID: flatbuffers::VOffsetT = 58;
  pub const VT_DEFENCECONSTA: flatbuffers::VOffsetT = 60;
  pub const VT_DEFENCECONSTB: flatbuffers::VOffsetT = 62;
  pub const VT_DEFENCECONSTC: flatbuffers::VOffsetT = 64;
  pub const VT_DEFENCECONSTD: flatbuffers::VOffsetT = 66;
  pub const VT_ACCURACYCONSTA: flatbuffers::VOffsetT = 68;
  pub const VT_ACCURACYCONSTB: flatbuffers::VOffsetT = 70;
  pub const VT_ACCURACYCONSTC: flatbuffers::VOffsetT = 72;
  pub const VT_ACCURACYCONSTD: flatbuffers::VOffsetT = 74;
  pub const VT_CRITICALCONSTA: flatbuffers::VOffsetT = 76;
  pub const VT_CRITICALCONSTB: flatbuffers::VOffsetT = 78;
  pub const VT_CRITICALCONSTC: flatbuffers::VOffsetT = 80;
  pub const VT_CRITICALCONSTD: flatbuffers::VOffsetT = 82;
  pub const VT_MAXGROUPBUFFLEVEL: flatbuffers::VOffsetT = 84;
  pub const VT_EMOJIDEFAULTTIME: flatbuffers::VOffsetT = 86;
  pub const VT_TIMELINEACTIONROTATESPEED: flatbuffers::VOffsetT = 88;
  pub const VT_BODYROTATESPEED: flatbuffers::VOffsetT = 90;
  pub const VT_NORMALTIMESCALE: flatbuffers::VOffsetT = 92;
  pub const VT_FASTTIMESCALE: flatbuffers::VOffsetT = 94;
  pub const VT_BULLETTIMESCALE: flatbuffers::VOffsetT = 96;
  pub const VT_UIDISPLAYDELAYAFTERSKILLCUTIN: flatbuffers::VOffsetT = 98;
  pub const VT_USEINITIALRANGEFORCOVERMOVE: flatbuffers::VOffsetT = 100;
  pub const VT_SLOWTIMESCALE: flatbuffers::VOffsetT = 102;
  pub const VT_AIMIKMINDEGREE: flatbuffers::VOffsetT = 104;
  pub const VT_AIMIKMAXDEGREE: flatbuffers::VOffsetT = 106;
  pub const VT_MINIMUMCLEARTIME: flatbuffers::VOffsetT = 108;
  pub const VT_MINIMUMCLEARLEVELGAP: flatbuffers::VOffsetT = 110;
  pub const VT_CHECKCHEATERMAXUSECOSTNONARENA: flatbuffers::VOffsetT = 112;
  pub const VT_CHECKCHEATERMAXUSECOSTARENA: flatbuffers::VOffsetT = 114;
  pub const VT_ALLOWEDMAXTIMESCALE: flatbuffers::VOffsetT = 116;
  pub const VT_RANDOMANIMATIONOUTPUT: flatbuffers::VOffsetT = 118;
  pub const VT_SUMMONEDTELEPORTDISTANCE: flatbuffers::VOffsetT = 120;
  pub const VT_ARENAMINIMUMCLEARTIME: flatbuffers::VOffsetT = 122;
  pub const VT_WORLDBOSSBATTLELITTLE: flatbuffers::VOffsetT = 124;
  pub const VT_WORLDBOSSBATTLEMIDDLE: flatbuffers::VOffsetT = 126;
  pub const VT_WORLDBOSSBATTLEHIGH: flatbuffers::VOffsetT = 128;
  pub const VT_WORLDBOSSBATTLEVERYHIGH: flatbuffers::VOffsetT = 130;
  pub const VT_WORLDRAIDAUTOSYNCTERMSECOND: flatbuffers::VOffsetT = 132;
  pub const VT_WORLDRAIDBOSSHPDECREASETERM: flatbuffers::VOffsetT = 134;
  pub const VT_WORLDRAIDBOSSPARCELREACTIONDELAY: flatbuffers::VOffsetT = 136;
  pub const VT_RAIDRANKINGJUMPMINIMUMWAITINGTIME: flatbuffers::VOffsetT = 138;
  pub const VT_EFFECTTELEPORTDISTANCE: flatbuffers::VOffsetT = 140;
  pub const VT_AURAEXITTHRESHOLDMARGIN: flatbuffers::VOffsetT = 142;
  pub const VT_TSAINTERACTIONDAMAGEFACTOR: flatbuffers::VOffsetT = 144;
  pub const VT_VICTORYINTERACTIONRATE: flatbuffers::VOffsetT = 146;
  pub const VT_ECHELONEXTENSIONENGAGETIMELINEPATH: flatbuffers::VOffsetT = 148;
  pub const VT_ECHELONEXTENSIONENGAGEWITHSUPPORTERTIMELINEPATH: flatbuffers::VOffsetT = 150;
  pub const VT_ECHELONEXTENSIONVICTORYTIMELINEPATH: flatbuffers::VOffsetT = 152;
  pub const VT_ECHELONEXTENSIONECHELONMAXCOMMONCOST: flatbuffers::VOffsetT = 154;
  pub const VT_ECHELONMAXOVERLOADCOST: flatbuffers::VOffsetT = 156;
  pub const VT_ECHELONEXTENSIONMAXOVERLOADCOST: flatbuffers::VOffsetT = 158;
  pub const VT_ECHELONEXTENSIONECHELONINITCOMMONCOST: flatbuffers::VOffsetT = 160;
  pub const VT_ECHELONEXTENSIONCOSTREGENRATIO: flatbuffers::VOffsetT = 162;
  pub const VT_ECHELONOVERLOADCOSTREGENRATIO: flatbuffers::VOffsetT = 164;
  pub const VT_ECHELONEXTENSIONOVERLOADCOSTREGENRATIO: flatbuffers::VOffsetT = 166;
  pub const VT_CHECKCHEATERMAXUSECOSTMULTIFLOORRAID: flatbuffers::VOffsetT = 168;
  pub const VT_EXCESSIVETOUCHCHECKTIME: flatbuffers::VOffsetT = 170;
  pub const VT_EXCESSIVETOUCHCHECKCOUNT: flatbuffers::VOffsetT = 172;
  pub const VT_CAMPAIGNALERTPOPUPLEVELGAP: flatbuffers::VOffsetT = 174;
  pub const VT_MOVECORRECTIONSKIPRATIO: flatbuffers::VOffsetT = 176;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ConstCombatExcel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ConstCombatExcelArgs<'args>
  ) -> flatbuffers::WIPOffset<ConstCombatExcel<'bldr>> {
    let mut builder = ConstCombatExcelBuilder::new(_fbb);
    let key = table_encryption_service::create_key(b"ConstCombat");
      let x = args.EchelonExtensionOverloadCostRegenRatio;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_EchelonExtensionOverloadCostRegenRatio(x);
      let x = args.EchelonOverloadCostRegenRatio;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_EchelonOverloadCostRegenRatio(x);
      let x = args.EchelonExtensionCostRegenRatio;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_EchelonExtensionCostRegenRatio(x);
      let x = args.EchelonExtensionMaxOverloadCost;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_EchelonExtensionMaxOverloadCost(x);
      let x = args.EchelonMaxOverloadCost;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_EchelonMaxOverloadCost(x);
      let x = args.VictoryInteractionRate;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_VictoryInteractionRate(x);
      let x = args.TSAInteractionDamageFactor;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_TSAInteractionDamageFactor(x);
      let x = args.AuraExitThresholdMargin;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_AuraExitThresholdMargin(x);
      let x = args.RaidRankingJumpMinimumWaitingTime;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_RaidRankingJumpMinimumWaitingTime(x);
      let x = args.WorldRaidBossParcelReactionDelay;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_WorldRaidBossParcelReactionDelay(x);
      let x = args.WorldRaidBossHpDecreaseTerm;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_WorldRaidBossHpDecreaseTerm(x);
      let x = args.WorldRaidAutoSyncTermSecond;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_WorldRaidAutoSyncTermSecond(x);
      let x = args.WORLDBOSSBATTLEVERYHIGH;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_WORLDBOSSBATTLEVERYHIGH(x);
      let x = args.WORLDBOSSBATTLEHIGH;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_WORLDBOSSBATTLEHIGH(x);
      let x = args.WORLDBOSSBATTLEMIDDLE;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_WORLDBOSSBATTLEMIDDLE(x);
      let x = args.WORLDBOSSBATTLELITTLE;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_WORLDBOSSBATTLELITTLE(x);
      let x = args.SummonedTeleportDistance;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_SummonedTeleportDistance(x);
      let x = args.RandomAnimationOutput;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_RandomAnimationOutput(x);
      let x = args.AllowedMaxTimeScale;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_AllowedMaxTimeScale(x);
      let x = args.SlowTimeScale;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_SlowTimeScale(x);
      let x = args.UIDisplayDelayAfterSkillCutIn;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_UIDisplayDelayAfterSkillCutIn(x);
      let x = args.BulletTimeScale;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_BulletTimeScale(x);
      let x = args.FastTimeScale;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_FastTimeScale(x);
      let x = args.NormalTimeScale;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_NormalTimeScale(x);
      let x = args.BodyRotateSpeed;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_BodyRotateSpeed(x);
      let x = args.TimeLineActionRotateSpeed;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_TimeLineActionRotateSpeed(x);
      let x = args.CriticalConstD;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_CriticalConstD(x);
      let x = args.CriticalConstC;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_CriticalConstC(x);
      let x = args.CriticalConstB;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_CriticalConstB(x);
      let x = args.CriticalConstA;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_CriticalConstA(x);
      let x = args.AccuracyConstD;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_AccuracyConstD(x);
      let x = args.AccuracyConstC;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_AccuracyConstC(x);
      let x = args.AccuracyConstB;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_AccuracyConstB(x);
      let x = args.AccuracyConstA;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_AccuracyConstA(x);
      let x = args.DefenceConstD;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_DefenceConstD(x);
      let x = args.DefenceConstC;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_DefenceConstC(x);
      let x = args.DefenceConstB;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_DefenceConstB(x);
      let x = args.DefenceConstA;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_DefenceConstA(x);
      let x = args.CrowdControlFactor;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_CrowdControlFactor(x);
      let x = args.PlayerRegenCostDelay;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_PlayerRegenCostDelay(x);
      let x = args.ChampionRegenCost;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_ChampionRegenCost(x);
      let x = args.EnemyRegenCost;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_EnemyRegenCost(x);
      let x = args.SkillSlotCoolTime;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_SkillSlotCoolTime(x);
      let x = args.TimeLimitAlarm;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_TimeLimitAlarm(x);
      let x = args.MaxRaidBossSkillSlot;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_MaxRaidBossSkillSlot(x);
      let x = args.MaxRaidTicketCount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_MaxRaidTicketCount(x);
      let x = args.MoveCorrectionSkipRatio;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_MoveCorrectionSkipRatio(x);
      let x = args.CampaignAlertPopupLevelGap;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_CampaignAlertPopupLevelGap(x);
      let x = args.ExcessiveTouchCheckCount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_ExcessiveTouchCheckCount(x);
      let x = args.ExcessiveTouchCheckTime;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_ExcessiveTouchCheckTime(x);
      let x = args.CheckCheaterMaxUseCostMultiFloorRaid;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_CheckCheaterMaxUseCostMultiFloorRaid(x);
      let x = args.EchelonExtensionEchelonInitCommonCost;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_EchelonExtensionEchelonInitCommonCost(x);
      let x = args.EchelonExtensionEchelonMaxCommonCost;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_EchelonExtensionEchelonMaxCommonCost(x);
      if let Some(x) = args.EchelonExtensionVictoryTimelinePath {
        builder.add_EchelonExtensionVictoryTimelinePath(x);
      }
      if let Some(x) = args.EchelonExtensionEngageWithSupporterTimelinePath {
        builder.add_EchelonExtensionEngageWithSupporterTimelinePath(x);
      }
      if let Some(x) = args.EchelonExtensionEngageTimelinePath {
        builder.add_EchelonExtensionEngageTimelinePath(x);
      }
      let x = args.EffectTeleportDistance;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_EffectTeleportDistance(x);
      let x = args.ArenaMinimumClearTime;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_ArenaMinimumClearTime(x);
      let x = args.CheckCheaterMaxUseCostArena;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_CheckCheaterMaxUseCostArena(x);
      let x = args.CheckCheaterMaxUseCostNonArena;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_CheckCheaterMaxUseCostNonArena(x);
      let x = args.MinimumClearLevelGap;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_MinimumClearLevelGap(x);
      let x = args.MinimumClearTime;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_MinimumClearTime(x);
      let x = args.AimIKMaxDegree;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_AimIKMaxDegree(x);
      let x = args.AimIKMinDegree;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_AimIKMinDegree(x);
      let x = args.EmojiDefaultTime;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_EmojiDefaultTime(x);
      let x = args.MaxGroupBuffLevel;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_MaxGroupBuffLevel(x);
      if let Some(x) = args.EliminateRaidOpenScenarioId {
        builder.add_EliminateRaidOpenScenarioId(x);
      }
      if let Some(x) = args.RaidOpenScenarioId {
        builder.add_RaidOpenScenarioId(x);
      }
      let x = args.EchelonInitCommonCost;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_EchelonInitCommonCost(x);
      let x = args.EchelonMaxCommonCost;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_EchelonMaxCommonCost(x);
      if let Some(x) = args.VictoryTimelinePath {
        builder.add_VictoryTimelinePath(x);
      }
      if let Some(x) = args.EngageWithSupporterTimelinePath {
        builder.add_EngageWithSupporterTimelinePath(x);
      }
      if let Some(x) = args.EngageTimelinePath {
        builder.add_EngageTimelinePath(x);
      }
      let x = args.ShowRaidListCount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_ShowRaidListCount(x);
      let x = args.PublicSpeechBubbleOffsetZ;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_PublicSpeechBubbleOffsetZ(x);
      let x = args.PublicSpeechBubbleOffsetY;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_PublicSpeechBubbleOffsetY(x);
      let x = args.PublicSpeechBubbleOffsetX;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_PublicSpeechBubbleOffsetX(x);
      if let Some(x) = args.SuppliesConditionStringId {
        builder.add_SuppliesConditionStringId(x);
      }
      let x = args.BuffIconBlinkTime;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_BuffIconBlinkTime(x);
      let x = args.DyingTime;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_DyingTime(x);
      let x = args.SkillHandCount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_SkillHandCount(x);
      builder.add_UseInitialRangeForCoverMove(args.UseInitialRangeForCoverMove);
      builder.add_ShowBufficonGroundPassiveSkill(args.ShowBufficonGroundPassiveSkill);
      builder.add_ShowBufficonLeaderSkill(args.ShowBufficonLeaderSkill);
      builder.add_ShowBufficonExtraPassiveSkill(args.ShowBufficonExtraPassiveSkill);
      builder.add_ShowBufficonPassiveSkill(args.ShowBufficonPassiveSkill);
      builder.add_ShowBufficonEXSkill(args.ShowBufficonEXSkill);
    builder.finish()
  }

  pub fn unpack(&self) -> ConstCombatExcelT {
    let key = table_encryption_service::create_key(b"ConstCombat");
      let SkillHandCount = self.SkillHandCount();
      let DyingTime = self.DyingTime();
      let BuffIconBlinkTime = self.BuffIconBlinkTime();
      let ShowBufficonEXSkill = self.ShowBufficonEXSkill();
      let ShowBufficonPassiveSkill = self.ShowBufficonPassiveSkill();
      let ShowBufficonExtraPassiveSkill = self.ShowBufficonExtraPassiveSkill();
      let ShowBufficonLeaderSkill = self.ShowBufficonLeaderSkill();
      let ShowBufficonGroundPassiveSkill = self.ShowBufficonGroundPassiveSkill();
    let SuppliesConditionStringId = self.SuppliesConditionStringId().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let PublicSpeechBubbleOffsetX = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.PublicSpeechBubbleOffsetX(), &key)
      } else {
        self.PublicSpeechBubbleOffsetX()
      };
      let PublicSpeechBubbleOffsetY = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.PublicSpeechBubbleOffsetY(), &key)
      } else {
        self.PublicSpeechBubbleOffsetY()
      };
      let PublicSpeechBubbleOffsetZ = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.PublicSpeechBubbleOffsetZ(), &key)
      } else {
        self.PublicSpeechBubbleOffsetZ()
      };
      let ShowRaidListCount = self.ShowRaidListCount();
      let MaxRaidTicketCount = self.MaxRaidTicketCount();
      let MaxRaidBossSkillSlot = self.MaxRaidBossSkillSlot();
    let EngageTimelinePath = self.EngageTimelinePath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let EngageWithSupporterTimelinePath = self.EngageWithSupporterTimelinePath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let VictoryTimelinePath = self.VictoryTimelinePath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let TimeLimitAlarm = self.TimeLimitAlarm();
      let EchelonMaxCommonCost = self.EchelonMaxCommonCost();
      let EchelonInitCommonCost = self.EchelonInitCommonCost();
      let SkillSlotCoolTime = self.SkillSlotCoolTime();
      let EnemyRegenCost = self.EnemyRegenCost();
      let ChampionRegenCost = self.ChampionRegenCost();
      let PlayerRegenCostDelay = self.PlayerRegenCostDelay();
      let CrowdControlFactor = self.CrowdControlFactor();
    let RaidOpenScenarioId = self.RaidOpenScenarioId().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let EliminateRaidOpenScenarioId = self.EliminateRaidOpenScenarioId().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let DefenceConstA = self.DefenceConstA();
      let DefenceConstB = self.DefenceConstB();
      let DefenceConstC = self.DefenceConstC();
      let DefenceConstD = self.DefenceConstD();
      let AccuracyConstA = self.AccuracyConstA();
      let AccuracyConstB = self.AccuracyConstB();
      let AccuracyConstC = self.AccuracyConstC();
      let AccuracyConstD = self.AccuracyConstD();
      let CriticalConstA = self.CriticalConstA();
      let CriticalConstB = self.CriticalConstB();
      let CriticalConstC = self.CriticalConstC();
      let CriticalConstD = self.CriticalConstD();
      let MaxGroupBuffLevel = self.MaxGroupBuffLevel();
      let EmojiDefaultTime = self.EmojiDefaultTime();
      let TimeLineActionRotateSpeed = self.TimeLineActionRotateSpeed();
      let BodyRotateSpeed = self.BodyRotateSpeed();
      let NormalTimeScale = self.NormalTimeScale();
      let FastTimeScale = self.FastTimeScale();
      let BulletTimeScale = self.BulletTimeScale();
      let UIDisplayDelayAfterSkillCutIn = self.UIDisplayDelayAfterSkillCutIn();
      let UseInitialRangeForCoverMove = self.UseInitialRangeForCoverMove();
      let SlowTimeScale = self.SlowTimeScale();
      let AimIKMinDegree = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.AimIKMinDegree(), &key)
      } else {
        self.AimIKMinDegree()
      };
      let AimIKMaxDegree = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.AimIKMaxDegree(), &key)
      } else {
        self.AimIKMaxDegree()
      };
      let MinimumClearTime = self.MinimumClearTime();
      let MinimumClearLevelGap = self.MinimumClearLevelGap();
      let CheckCheaterMaxUseCostNonArena = self.CheckCheaterMaxUseCostNonArena();
      let CheckCheaterMaxUseCostArena = self.CheckCheaterMaxUseCostArena();
      let AllowedMaxTimeScale = self.AllowedMaxTimeScale();
      let RandomAnimationOutput = self.RandomAnimationOutput();
      let SummonedTeleportDistance = self.SummonedTeleportDistance();
      let ArenaMinimumClearTime = self.ArenaMinimumClearTime();
      let WORLDBOSSBATTLELITTLE = self.WORLDBOSSBATTLELITTLE();
      let WORLDBOSSBATTLEMIDDLE = self.WORLDBOSSBATTLEMIDDLE();
      let WORLDBOSSBATTLEHIGH = self.WORLDBOSSBATTLEHIGH();
      let WORLDBOSSBATTLEVERYHIGH = self.WORLDBOSSBATTLEVERYHIGH();
      let WorldRaidAutoSyncTermSecond = self.WorldRaidAutoSyncTermSecond();
      let WorldRaidBossHpDecreaseTerm = self.WorldRaidBossHpDecreaseTerm();
      let WorldRaidBossParcelReactionDelay = self.WorldRaidBossParcelReactionDelay();
      let RaidRankingJumpMinimumWaitingTime = self.RaidRankingJumpMinimumWaitingTime();
      let EffectTeleportDistance = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.EffectTeleportDistance(), &key)
      } else {
        self.EffectTeleportDistance()
      };
      let AuraExitThresholdMargin = self.AuraExitThresholdMargin();
      let TSAInteractionDamageFactor = self.TSAInteractionDamageFactor();
      let VictoryInteractionRate = self.VictoryInteractionRate();
    let EchelonExtensionEngageTimelinePath = self.EchelonExtensionEngageTimelinePath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let EchelonExtensionEngageWithSupporterTimelinePath = self.EchelonExtensionEngageWithSupporterTimelinePath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let EchelonExtensionVictoryTimelinePath = self.EchelonExtensionVictoryTimelinePath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let EchelonExtensionEchelonMaxCommonCost = self.EchelonExtensionEchelonMaxCommonCost();
      let EchelonMaxOverloadCost = self.EchelonMaxOverloadCost();
      let EchelonExtensionMaxOverloadCost = self.EchelonExtensionMaxOverloadCost();
      let EchelonExtensionEchelonInitCommonCost = self.EchelonExtensionEchelonInitCommonCost();
      let EchelonExtensionCostRegenRatio = self.EchelonExtensionCostRegenRatio();
      let EchelonOverloadCostRegenRatio = self.EchelonOverloadCostRegenRatio();
      let EchelonExtensionOverloadCostRegenRatio = self.EchelonExtensionOverloadCostRegenRatio();
      let CheckCheaterMaxUseCostMultiFloorRaid = self.CheckCheaterMaxUseCostMultiFloorRaid();
      let ExcessiveTouchCheckTime = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.ExcessiveTouchCheckTime(), &key)
      } else {
        self.ExcessiveTouchCheckTime()
      };
      let ExcessiveTouchCheckCount = self.ExcessiveTouchCheckCount();
      let CampaignAlertPopupLevelGap = self.CampaignAlertPopupLevelGap();
      let MoveCorrectionSkipRatio = self.MoveCorrectionSkipRatio();
    ConstCombatExcelT {
      SkillHandCount,
      DyingTime,
      BuffIconBlinkTime,
      ShowBufficonEXSkill,
      ShowBufficonPassiveSkill,
      ShowBufficonExtraPassiveSkill,
      ShowBufficonLeaderSkill,
      ShowBufficonGroundPassiveSkill,
      SuppliesConditionStringId,
      PublicSpeechBubbleOffsetX,
      PublicSpeechBubbleOffsetY,
      PublicSpeechBubbleOffsetZ,
      ShowRaidListCount,
      MaxRaidTicketCount,
      MaxRaidBossSkillSlot,
      EngageTimelinePath,
      EngageWithSupporterTimelinePath,
      VictoryTimelinePath,
      TimeLimitAlarm,
      EchelonMaxCommonCost,
      EchelonInitCommonCost,
      SkillSlotCoolTime,
      EnemyRegenCost,
      ChampionRegenCost,
      PlayerRegenCostDelay,
      CrowdControlFactor,
      RaidOpenScenarioId,
      EliminateRaidOpenScenarioId,
      DefenceConstA,
      DefenceConstB,
      DefenceConstC,
      DefenceConstD,
      AccuracyConstA,
      AccuracyConstB,
      AccuracyConstC,
      AccuracyConstD,
      CriticalConstA,
      CriticalConstB,
      CriticalConstC,
      CriticalConstD,
      MaxGroupBuffLevel,
      EmojiDefaultTime,
      TimeLineActionRotateSpeed,
      BodyRotateSpeed,
      NormalTimeScale,
      FastTimeScale,
      BulletTimeScale,
      UIDisplayDelayAfterSkillCutIn,
      UseInitialRangeForCoverMove,
      SlowTimeScale,
      AimIKMinDegree,
      AimIKMaxDegree,
      MinimumClearTime,
      MinimumClearLevelGap,
      CheckCheaterMaxUseCostNonArena,
      CheckCheaterMaxUseCostArena,
      AllowedMaxTimeScale,
      RandomAnimationOutput,
      SummonedTeleportDistance,
      ArenaMinimumClearTime,
      WORLDBOSSBATTLELITTLE,
      WORLDBOSSBATTLEMIDDLE,
      WORLDBOSSBATTLEHIGH,
      WORLDBOSSBATTLEVERYHIGH,
      WorldRaidAutoSyncTermSecond,
      WorldRaidBossHpDecreaseTerm,
      WorldRaidBossParcelReactionDelay,
      RaidRankingJumpMinimumWaitingTime,
      EffectTeleportDistance,
      AuraExitThresholdMargin,
      TSAInteractionDamageFactor,
      VictoryInteractionRate,
      EchelonExtensionEngageTimelinePath,
      EchelonExtensionEngageWithSupporterTimelinePath,
      EchelonExtensionVictoryTimelinePath,
      EchelonExtensionEchelonMaxCommonCost,
      EchelonMaxOverloadCost,
      EchelonExtensionMaxOverloadCost,
      EchelonExtensionEchelonInitCommonCost,
      EchelonExtensionCostRegenRatio,
      EchelonOverloadCostRegenRatio,
      EchelonExtensionOverloadCostRegenRatio,
      CheckCheaterMaxUseCostMultiFloorRaid,
      ExcessiveTouchCheckTime,
      ExcessiveTouchCheckCount,
      CampaignAlertPopupLevelGap,
      MoveCorrectionSkipRatio,
    }
  }

  #[inline]
  pub fn SkillHandCount(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstCombatExcel::VT_SKILLHANDCOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn DyingTime(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstCombatExcel::VT_DYINGTIME, Some(0)).unwrap()}
  }
  #[inline]
  pub fn BuffIconBlinkTime(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstCombatExcel::VT_BUFFICONBLINKTIME, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ShowBufficonEXSkill(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ConstCombatExcel::VT_SHOWBUFFICONEXSKILL, Some(false)).unwrap()}
  }
  #[inline]
  pub fn ShowBufficonPassiveSkill(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ConstCombatExcel::VT_SHOWBUFFICONPASSIVESKILL, Some(false)).unwrap()}
  }
  #[inline]
  pub fn ShowBufficonExtraPassiveSkill(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ConstCombatExcel::VT_SHOWBUFFICONEXTRAPASSIVESKILL, Some(false)).unwrap()}
  }
  #[inline]
  pub fn ShowBufficonLeaderSkill(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ConstCombatExcel::VT_SHOWBUFFICONLEADERSKILL, Some(false)).unwrap()}
  }
  #[inline]
  pub fn ShowBufficonGroundPassiveSkill(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ConstCombatExcel::VT_SHOWBUFFICONGROUNDPASSIVESKILL, Some(false)).unwrap()}
  }
  #[inline]
  pub fn SuppliesConditionStringId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ConstCombatExcel::VT_SUPPLIESCONDITIONSTRINGID, None)}
  }
  #[inline]
  pub fn PublicSpeechBubbleOffsetX(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ConstCombatExcel::VT_PUBLICSPEECHBUBBLEOFFSETX, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn PublicSpeechBubbleOffsetY(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ConstCombatExcel::VT_PUBLICSPEECHBUBBLEOFFSETY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn PublicSpeechBubbleOffsetZ(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ConstCombatExcel::VT_PUBLICSPEECHBUBBLEOFFSETZ, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ShowRaidListCount(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstCombatExcel::VT_SHOWRAIDLISTCOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn MaxRaidTicketCount(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_MAXRAIDTICKETCOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn MaxRaidBossSkillSlot(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_MAXRAIDBOSSSKILLSLOT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EngageTimelinePath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ConstCombatExcel::VT_ENGAGETIMELINEPATH, None)}
  }
  #[inline]
  pub fn EngageWithSupporterTimelinePath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ConstCombatExcel::VT_ENGAGEWITHSUPPORTERTIMELINEPATH, None)}
  }
  #[inline]
  pub fn VictoryTimelinePath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ConstCombatExcel::VT_VICTORYTIMELINEPATH, None)}
  }
  #[inline]
  pub fn TimeLimitAlarm(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_TIMELIMITALARM, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EchelonMaxCommonCost(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstCombatExcel::VT_ECHELONMAXCOMMONCOST, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EchelonInitCommonCost(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstCombatExcel::VT_ECHELONINITCOMMONCOST, Some(0)).unwrap()}
  }
  #[inline]
  pub fn SkillSlotCoolTime(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_SKILLSLOTCOOLTIME, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EnemyRegenCost(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_ENEMYREGENCOST, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ChampionRegenCost(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_CHAMPIONREGENCOST, Some(0)).unwrap()}
  }
  #[inline]
  pub fn PlayerRegenCostDelay(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_PLAYERREGENCOSTDELAY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CrowdControlFactor(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_CROWDCONTROLFACTOR, Some(0)).unwrap()}
  }
  #[inline]
  pub fn RaidOpenScenarioId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ConstCombatExcel::VT_RAIDOPENSCENARIOID, None)}
  }
  #[inline]
  pub fn EliminateRaidOpenScenarioId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ConstCombatExcel::VT_ELIMINATERAIDOPENSCENARIOID, None)}
  }
  #[inline]
  pub fn DefenceConstA(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_DEFENCECONSTA, Some(0)).unwrap()}
  }
  #[inline]
  pub fn DefenceConstB(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_DEFENCECONSTB, Some(0)).unwrap()}
  }
  #[inline]
  pub fn DefenceConstC(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_DEFENCECONSTC, Some(0)).unwrap()}
  }
  #[inline]
  pub fn DefenceConstD(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_DEFENCECONSTD, Some(0)).unwrap()}
  }
  #[inline]
  pub fn AccuracyConstA(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_ACCURACYCONSTA, Some(0)).unwrap()}
  }
  #[inline]
  pub fn AccuracyConstB(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_ACCURACYCONSTB, Some(0)).unwrap()}
  }
  #[inline]
  pub fn AccuracyConstC(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_ACCURACYCONSTC, Some(0)).unwrap()}
  }
  #[inline]
  pub fn AccuracyConstD(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_ACCURACYCONSTD, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CriticalConstA(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_CRITICALCONSTA, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CriticalConstB(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_CRITICALCONSTB, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CriticalConstC(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_CRITICALCONSTC, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CriticalConstD(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_CRITICALCONSTD, Some(0)).unwrap()}
  }
  #[inline]
  pub fn MaxGroupBuffLevel(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstCombatExcel::VT_MAXGROUPBUFFLEVEL, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EmojiDefaultTime(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstCombatExcel::VT_EMOJIDEFAULTTIME, Some(0)).unwrap()}
  }
  #[inline]
  pub fn TimeLineActionRotateSpeed(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_TIMELINEACTIONROTATESPEED, Some(0)).unwrap()}
  }
  #[inline]
  pub fn BodyRotateSpeed(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_BODYROTATESPEED, Some(0)).unwrap()}
  }
  #[inline]
  pub fn NormalTimeScale(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_NORMALTIMESCALE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn FastTimeScale(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_FASTTIMESCALE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn BulletTimeScale(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_BULLETTIMESCALE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn UIDisplayDelayAfterSkillCutIn(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_UIDISPLAYDELAYAFTERSKILLCUTIN, Some(0)).unwrap()}
  }
  #[inline]
  pub fn UseInitialRangeForCoverMove(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ConstCombatExcel::VT_USEINITIALRANGEFORCOVERMOVE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn SlowTimeScale(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_SLOWTIMESCALE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn AimIKMinDegree(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ConstCombatExcel::VT_AIMIKMINDEGREE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn AimIKMaxDegree(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ConstCombatExcel::VT_AIMIKMAXDEGREE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn MinimumClearTime(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstCombatExcel::VT_MINIMUMCLEARTIME, Some(0)).unwrap()}
  }
  #[inline]
  pub fn MinimumClearLevelGap(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstCombatExcel::VT_MINIMUMCLEARLEVELGAP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CheckCheaterMaxUseCostNonArena(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstCombatExcel::VT_CHECKCHEATERMAXUSECOSTNONARENA, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CheckCheaterMaxUseCostArena(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstCombatExcel::VT_CHECKCHEATERMAXUSECOSTARENA, Some(0)).unwrap()}
  }
  #[inline]
  pub fn AllowedMaxTimeScale(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_ALLOWEDMAXTIMESCALE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn RandomAnimationOutput(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_RANDOMANIMATIONOUTPUT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn SummonedTeleportDistance(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_SUMMONEDTELEPORTDISTANCE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ArenaMinimumClearTime(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstCombatExcel::VT_ARENAMINIMUMCLEARTIME, Some(0)).unwrap()}
  }
  #[inline]
  pub fn WORLDBOSSBATTLELITTLE(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_WORLDBOSSBATTLELITTLE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn WORLDBOSSBATTLEMIDDLE(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_WORLDBOSSBATTLEMIDDLE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn WORLDBOSSBATTLEHIGH(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_WORLDBOSSBATTLEHIGH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn WORLDBOSSBATTLEVERYHIGH(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_WORLDBOSSBATTLEVERYHIGH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn WorldRaidAutoSyncTermSecond(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_WORLDRAIDAUTOSYNCTERMSECOND, Some(0)).unwrap()}
  }
  #[inline]
  pub fn WorldRaidBossHpDecreaseTerm(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_WORLDRAIDBOSSHPDECREASETERM, Some(0)).unwrap()}
  }
  #[inline]
  pub fn WorldRaidBossParcelReactionDelay(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_WORLDRAIDBOSSPARCELREACTIONDELAY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn RaidRankingJumpMinimumWaitingTime(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_RAIDRANKINGJUMPMINIMUMWAITINGTIME, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EffectTeleportDistance(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ConstCombatExcel::VT_EFFECTTELEPORTDISTANCE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn AuraExitThresholdMargin(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_AURAEXITTHRESHOLDMARGIN, Some(0)).unwrap()}
  }
  #[inline]
  pub fn TSAInteractionDamageFactor(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_TSAINTERACTIONDAMAGEFACTOR, Some(0)).unwrap()}
  }
  #[inline]
  pub fn VictoryInteractionRate(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_VICTORYINTERACTIONRATE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EchelonExtensionEngageTimelinePath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ConstCombatExcel::VT_ECHELONEXTENSIONENGAGETIMELINEPATH, None)}
  }
  #[inline]
  pub fn EchelonExtensionEngageWithSupporterTimelinePath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ConstCombatExcel::VT_ECHELONEXTENSIONENGAGEWITHSUPPORTERTIMELINEPATH, None)}
  }
  #[inline]
  pub fn EchelonExtensionVictoryTimelinePath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ConstCombatExcel::VT_ECHELONEXTENSIONVICTORYTIMELINEPATH, None)}
  }
  #[inline]
  pub fn EchelonExtensionEchelonMaxCommonCost(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstCombatExcel::VT_ECHELONEXTENSIONECHELONMAXCOMMONCOST, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EchelonMaxOverloadCost(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_ECHELONMAXOVERLOADCOST, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EchelonExtensionMaxOverloadCost(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_ECHELONEXTENSIONMAXOVERLOADCOST, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EchelonExtensionEchelonInitCommonCost(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstCombatExcel::VT_ECHELONEXTENSIONECHELONINITCOMMONCOST, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EchelonExtensionCostRegenRatio(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_ECHELONEXTENSIONCOSTREGENRATIO, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EchelonOverloadCostRegenRatio(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_ECHELONOVERLOADCOSTREGENRATIO, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EchelonExtensionOverloadCostRegenRatio(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ConstCombatExcel::VT_ECHELONEXTENSIONOVERLOADCOSTREGENRATIO, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CheckCheaterMaxUseCostMultiFloorRaid(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstCombatExcel::VT_CHECKCHEATERMAXUSECOSTMULTIFLOORRAID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ExcessiveTouchCheckTime(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ConstCombatExcel::VT_EXCESSIVETOUCHCHECKTIME, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ExcessiveTouchCheckCount(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstCombatExcel::VT_EXCESSIVETOUCHCHECKCOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CampaignAlertPopupLevelGap(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstCombatExcel::VT_CAMPAIGNALERTPOPUPLEVELGAP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn MoveCorrectionSkipRatio(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ConstCombatExcel::VT_MOVECORRECTIONSKIPRATIO, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ConstCombatExcel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("SkillHandCount", Self::VT_SKILLHANDCOUNT, false)?
     .visit_field::<i32>("DyingTime", Self::VT_DYINGTIME, false)?
     .visit_field::<i32>("BuffIconBlinkTime", Self::VT_BUFFICONBLINKTIME, false)?
     .visit_field::<bool>("ShowBufficonEXSkill", Self::VT_SHOWBUFFICONEXSKILL, false)?
     .visit_field::<bool>("ShowBufficonPassiveSkill", Self::VT_SHOWBUFFICONPASSIVESKILL, false)?
     .visit_field::<bool>("ShowBufficonExtraPassiveSkill", Self::VT_SHOWBUFFICONEXTRAPASSIVESKILL, false)?
     .visit_field::<bool>("ShowBufficonLeaderSkill", Self::VT_SHOWBUFFICONLEADERSKILL, false)?
     .visit_field::<bool>("ShowBufficonGroundPassiveSkill", Self::VT_SHOWBUFFICONGROUNDPASSIVESKILL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SuppliesConditionStringId", Self::VT_SUPPLIESCONDITIONSTRINGID, false)?
     .visit_field::<f32>("PublicSpeechBubbleOffsetX", Self::VT_PUBLICSPEECHBUBBLEOFFSETX, false)?
     .visit_field::<f32>("PublicSpeechBubbleOffsetY", Self::VT_PUBLICSPEECHBUBBLEOFFSETY, false)?
     .visit_field::<f32>("PublicSpeechBubbleOffsetZ", Self::VT_PUBLICSPEECHBUBBLEOFFSETZ, false)?
     .visit_field::<i32>("ShowRaidListCount", Self::VT_SHOWRAIDLISTCOUNT, false)?
     .visit_field::<i64>("MaxRaidTicketCount", Self::VT_MAXRAIDTICKETCOUNT, false)?
     .visit_field::<i64>("MaxRaidBossSkillSlot", Self::VT_MAXRAIDBOSSSKILLSLOT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EngageTimelinePath", Self::VT_ENGAGETIMELINEPATH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EngageWithSupporterTimelinePath", Self::VT_ENGAGEWITHSUPPORTERTIMELINEPATH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("VictoryTimelinePath", Self::VT_VICTORYTIMELINEPATH, false)?
     .visit_field::<i64>("TimeLimitAlarm", Self::VT_TIMELIMITALARM, false)?
     .visit_field::<i32>("EchelonMaxCommonCost", Self::VT_ECHELONMAXCOMMONCOST, false)?
     .visit_field::<i32>("EchelonInitCommonCost", Self::VT_ECHELONINITCOMMONCOST, false)?
     .visit_field::<i64>("SkillSlotCoolTime", Self::VT_SKILLSLOTCOOLTIME, false)?
     .visit_field::<i64>("EnemyRegenCost", Self::VT_ENEMYREGENCOST, false)?
     .visit_field::<i64>("ChampionRegenCost", Self::VT_CHAMPIONREGENCOST, false)?
     .visit_field::<i64>("PlayerRegenCostDelay", Self::VT_PLAYERREGENCOSTDELAY, false)?
     .visit_field::<i64>("CrowdControlFactor", Self::VT_CROWDCONTROLFACTOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("RaidOpenScenarioId", Self::VT_RAIDOPENSCENARIOID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EliminateRaidOpenScenarioId", Self::VT_ELIMINATERAIDOPENSCENARIOID, false)?
     .visit_field::<i64>("DefenceConstA", Self::VT_DEFENCECONSTA, false)?
     .visit_field::<i64>("DefenceConstB", Self::VT_DEFENCECONSTB, false)?
     .visit_field::<i64>("DefenceConstC", Self::VT_DEFENCECONSTC, false)?
     .visit_field::<i64>("DefenceConstD", Self::VT_DEFENCECONSTD, false)?
     .visit_field::<i64>("AccuracyConstA", Self::VT_ACCURACYCONSTA, false)?
     .visit_field::<i64>("AccuracyConstB", Self::VT_ACCURACYCONSTB, false)?
     .visit_field::<i64>("AccuracyConstC", Self::VT_ACCURACYCONSTC, false)?
     .visit_field::<i64>("AccuracyConstD", Self::VT_ACCURACYCONSTD, false)?
     .visit_field::<i64>("CriticalConstA", Self::VT_CRITICALCONSTA, false)?
     .visit_field::<i64>("CriticalConstB", Self::VT_CRITICALCONSTB, false)?
     .visit_field::<i64>("CriticalConstC", Self::VT_CRITICALCONSTC, false)?
     .visit_field::<i64>("CriticalConstD", Self::VT_CRITICALCONSTD, false)?
     .visit_field::<i32>("MaxGroupBuffLevel", Self::VT_MAXGROUPBUFFLEVEL, false)?
     .visit_field::<i32>("EmojiDefaultTime", Self::VT_EMOJIDEFAULTTIME, false)?
     .visit_field::<i64>("TimeLineActionRotateSpeed", Self::VT_TIMELINEACTIONROTATESPEED, false)?
     .visit_field::<i64>("BodyRotateSpeed", Self::VT_BODYROTATESPEED, false)?
     .visit_field::<i64>("NormalTimeScale", Self::VT_NORMALTIMESCALE, false)?
     .visit_field::<i64>("FastTimeScale", Self::VT_FASTTIMESCALE, false)?
     .visit_field::<i64>("BulletTimeScale", Self::VT_BULLETTIMESCALE, false)?
     .visit_field::<i64>("UIDisplayDelayAfterSkillCutIn", Self::VT_UIDISPLAYDELAYAFTERSKILLCUTIN, false)?
     .visit_field::<bool>("UseInitialRangeForCoverMove", Self::VT_USEINITIALRANGEFORCOVERMOVE, false)?
     .visit_field::<i64>("SlowTimeScale", Self::VT_SLOWTIMESCALE, false)?
     .visit_field::<f32>("AimIKMinDegree", Self::VT_AIMIKMINDEGREE, false)?
     .visit_field::<f32>("AimIKMaxDegree", Self::VT_AIMIKMAXDEGREE, false)?
     .visit_field::<i32>("MinimumClearTime", Self::VT_MINIMUMCLEARTIME, false)?
     .visit_field::<i32>("MinimumClearLevelGap", Self::VT_MINIMUMCLEARLEVELGAP, false)?
     .visit_field::<i32>("CheckCheaterMaxUseCostNonArena", Self::VT_CHECKCHEATERMAXUSECOSTNONARENA, false)?
     .visit_field::<i32>("CheckCheaterMaxUseCostArena", Self::VT_CHECKCHEATERMAXUSECOSTARENA, false)?
     .visit_field::<i64>("AllowedMaxTimeScale", Self::VT_ALLOWEDMAXTIMESCALE, false)?
     .visit_field::<i64>("RandomAnimationOutput", Self::VT_RANDOMANIMATIONOUTPUT, false)?
     .visit_field::<i64>("SummonedTeleportDistance", Self::VT_SUMMONEDTELEPORTDISTANCE, false)?
     .visit_field::<i32>("ArenaMinimumClearTime", Self::VT_ARENAMINIMUMCLEARTIME, false)?
     .visit_field::<i64>("WORLDBOSSBATTLELITTLE", Self::VT_WORLDBOSSBATTLELITTLE, false)?
     .visit_field::<i64>("WORLDBOSSBATTLEMIDDLE", Self::VT_WORLDBOSSBATTLEMIDDLE, false)?
     .visit_field::<i64>("WORLDBOSSBATTLEHIGH", Self::VT_WORLDBOSSBATTLEHIGH, false)?
     .visit_field::<i64>("WORLDBOSSBATTLEVERYHIGH", Self::VT_WORLDBOSSBATTLEVERYHIGH, false)?
     .visit_field::<i64>("WorldRaidAutoSyncTermSecond", Self::VT_WORLDRAIDAUTOSYNCTERMSECOND, false)?
     .visit_field::<i64>("WorldRaidBossHpDecreaseTerm", Self::VT_WORLDRAIDBOSSHPDECREASETERM, false)?
     .visit_field::<i64>("WorldRaidBossParcelReactionDelay", Self::VT_WORLDRAIDBOSSPARCELREACTIONDELAY, false)?
     .visit_field::<i64>("RaidRankingJumpMinimumWaitingTime", Self::VT_RAIDRANKINGJUMPMINIMUMWAITINGTIME, false)?
     .visit_field::<f32>("EffectTeleportDistance", Self::VT_EFFECTTELEPORTDISTANCE, false)?
     .visit_field::<i64>("AuraExitThresholdMargin", Self::VT_AURAEXITTHRESHOLDMARGIN, false)?
     .visit_field::<i64>("TSAInteractionDamageFactor", Self::VT_TSAINTERACTIONDAMAGEFACTOR, false)?
     .visit_field::<i64>("VictoryInteractionRate", Self::VT_VICTORYINTERACTIONRATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EchelonExtensionEngageTimelinePath", Self::VT_ECHELONEXTENSIONENGAGETIMELINEPATH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EchelonExtensionEngageWithSupporterTimelinePath", Self::VT_ECHELONEXTENSIONENGAGEWITHSUPPORTERTIMELINEPATH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EchelonExtensionVictoryTimelinePath", Self::VT_ECHELONEXTENSIONVICTORYTIMELINEPATH, false)?
     .visit_field::<i32>("EchelonExtensionEchelonMaxCommonCost", Self::VT_ECHELONEXTENSIONECHELONMAXCOMMONCOST, false)?
     .visit_field::<i64>("EchelonMaxOverloadCost", Self::VT_ECHELONMAXOVERLOADCOST, false)?
     .visit_field::<i64>("EchelonExtensionMaxOverloadCost", Self::VT_ECHELONEXTENSIONMAXOVERLOADCOST, false)?
     .visit_field::<i32>("EchelonExtensionEchelonInitCommonCost", Self::VT_ECHELONEXTENSIONECHELONINITCOMMONCOST, false)?
     .visit_field::<i64>("EchelonExtensionCostRegenRatio", Self::VT_ECHELONEXTENSIONCOSTREGENRATIO, false)?
     .visit_field::<i64>("EchelonOverloadCostRegenRatio", Self::VT_ECHELONOVERLOADCOSTREGENRATIO, false)?
     .visit_field::<i64>("EchelonExtensionOverloadCostRegenRatio", Self::VT_ECHELONEXTENSIONOVERLOADCOSTREGENRATIO, false)?
     .visit_field::<i32>("CheckCheaterMaxUseCostMultiFloorRaid", Self::VT_CHECKCHEATERMAXUSECOSTMULTIFLOORRAID, false)?
     .visit_field::<f32>("ExcessiveTouchCheckTime", Self::VT_EXCESSIVETOUCHCHECKTIME, false)?
     .visit_field::<i32>("ExcessiveTouchCheckCount", Self::VT_EXCESSIVETOUCHCHECKCOUNT, false)?
     .visit_field::<i32>("CampaignAlertPopupLevelGap", Self::VT_CAMPAIGNALERTPOPUPLEVELGAP, false)?
     .visit_field::<i32>("MoveCorrectionSkipRatio", Self::VT_MOVECORRECTIONSKIPRATIO, false)?
     .finish();
    Ok(())
  }
}
pub struct ConstCombatExcelArgs<'a> {
    pub SkillHandCount: i32,
    pub DyingTime: i32,
    pub BuffIconBlinkTime: i32,
    pub ShowBufficonEXSkill: bool,
    pub ShowBufficonPassiveSkill: bool,
    pub ShowBufficonExtraPassiveSkill: bool,
    pub ShowBufficonLeaderSkill: bool,
    pub ShowBufficonGroundPassiveSkill: bool,
    pub SuppliesConditionStringId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PublicSpeechBubbleOffsetX: f32,
    pub PublicSpeechBubbleOffsetY: f32,
    pub PublicSpeechBubbleOffsetZ: f32,
    pub ShowRaidListCount: i32,
    pub MaxRaidTicketCount: i64,
    pub MaxRaidBossSkillSlot: i64,
    pub EngageTimelinePath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EngageWithSupporterTimelinePath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub VictoryTimelinePath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TimeLimitAlarm: i64,
    pub EchelonMaxCommonCost: i32,
    pub EchelonInitCommonCost: i32,
    pub SkillSlotCoolTime: i64,
    pub EnemyRegenCost: i64,
    pub ChampionRegenCost: i64,
    pub PlayerRegenCostDelay: i64,
    pub CrowdControlFactor: i64,
    pub RaidOpenScenarioId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EliminateRaidOpenScenarioId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DefenceConstA: i64,
    pub DefenceConstB: i64,
    pub DefenceConstC: i64,
    pub DefenceConstD: i64,
    pub AccuracyConstA: i64,
    pub AccuracyConstB: i64,
    pub AccuracyConstC: i64,
    pub AccuracyConstD: i64,
    pub CriticalConstA: i64,
    pub CriticalConstB: i64,
    pub CriticalConstC: i64,
    pub CriticalConstD: i64,
    pub MaxGroupBuffLevel: i32,
    pub EmojiDefaultTime: i32,
    pub TimeLineActionRotateSpeed: i64,
    pub BodyRotateSpeed: i64,
    pub NormalTimeScale: i64,
    pub FastTimeScale: i64,
    pub BulletTimeScale: i64,
    pub UIDisplayDelayAfterSkillCutIn: i64,
    pub UseInitialRangeForCoverMove: bool,
    pub SlowTimeScale: i64,
    pub AimIKMinDegree: f32,
    pub AimIKMaxDegree: f32,
    pub MinimumClearTime: i32,
    pub MinimumClearLevelGap: i32,
    pub CheckCheaterMaxUseCostNonArena: i32,
    pub CheckCheaterMaxUseCostArena: i32,
    pub AllowedMaxTimeScale: i64,
    pub RandomAnimationOutput: i64,
    pub SummonedTeleportDistance: i64,
    pub ArenaMinimumClearTime: i32,
    pub WORLDBOSSBATTLELITTLE: i64,
    pub WORLDBOSSBATTLEMIDDLE: i64,
    pub WORLDBOSSBATTLEHIGH: i64,
    pub WORLDBOSSBATTLEVERYHIGH: i64,
    pub WorldRaidAutoSyncTermSecond: i64,
    pub WorldRaidBossHpDecreaseTerm: i64,
    pub WorldRaidBossParcelReactionDelay: i64,
    pub RaidRankingJumpMinimumWaitingTime: i64,
    pub EffectTeleportDistance: f32,
    pub AuraExitThresholdMargin: i64,
    pub TSAInteractionDamageFactor: i64,
    pub VictoryInteractionRate: i64,
    pub EchelonExtensionEngageTimelinePath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EchelonExtensionEngageWithSupporterTimelinePath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EchelonExtensionVictoryTimelinePath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EchelonExtensionEchelonMaxCommonCost: i32,
    pub EchelonMaxOverloadCost: i64,
    pub EchelonExtensionMaxOverloadCost: i64,
    pub EchelonExtensionEchelonInitCommonCost: i32,
    pub EchelonExtensionCostRegenRatio: i64,
    pub EchelonOverloadCostRegenRatio: i64,
    pub EchelonExtensionOverloadCostRegenRatio: i64,
    pub CheckCheaterMaxUseCostMultiFloorRaid: i32,
    pub ExcessiveTouchCheckTime: f32,
    pub ExcessiveTouchCheckCount: i32,
    pub CampaignAlertPopupLevelGap: i32,
    pub MoveCorrectionSkipRatio: i32,
}
impl<'a> Default for ConstCombatExcelArgs<'a> {
  #[inline]
  fn default() -> Self {
    ConstCombatExcelArgs {
      SkillHandCount: 0,
      DyingTime: 0,
      BuffIconBlinkTime: 0,
      ShowBufficonEXSkill: false,
      ShowBufficonPassiveSkill: false,
      ShowBufficonExtraPassiveSkill: false,
      ShowBufficonLeaderSkill: false,
      ShowBufficonGroundPassiveSkill: false,
      SuppliesConditionStringId: None,
      PublicSpeechBubbleOffsetX: 0.0,
      PublicSpeechBubbleOffsetY: 0.0,
      PublicSpeechBubbleOffsetZ: 0.0,
      ShowRaidListCount: 0,
      MaxRaidTicketCount: 0,
      MaxRaidBossSkillSlot: 0,
      EngageTimelinePath: None,
      EngageWithSupporterTimelinePath: None,
      VictoryTimelinePath: None,
      TimeLimitAlarm: 0,
      EchelonMaxCommonCost: 0,
      EchelonInitCommonCost: 0,
      SkillSlotCoolTime: 0,
      EnemyRegenCost: 0,
      ChampionRegenCost: 0,
      PlayerRegenCostDelay: 0,
      CrowdControlFactor: 0,
      RaidOpenScenarioId: None,
      EliminateRaidOpenScenarioId: None,
      DefenceConstA: 0,
      DefenceConstB: 0,
      DefenceConstC: 0,
      DefenceConstD: 0,
      AccuracyConstA: 0,
      AccuracyConstB: 0,
      AccuracyConstC: 0,
      AccuracyConstD: 0,
      CriticalConstA: 0,
      CriticalConstB: 0,
      CriticalConstC: 0,
      CriticalConstD: 0,
      MaxGroupBuffLevel: 0,
      EmojiDefaultTime: 0,
      TimeLineActionRotateSpeed: 0,
      BodyRotateSpeed: 0,
      NormalTimeScale: 0,
      FastTimeScale: 0,
      BulletTimeScale: 0,
      UIDisplayDelayAfterSkillCutIn: 0,
      UseInitialRangeForCoverMove: false,
      SlowTimeScale: 0,
      AimIKMinDegree: 0.0,
      AimIKMaxDegree: 0.0,
      MinimumClearTime: 0,
      MinimumClearLevelGap: 0,
      CheckCheaterMaxUseCostNonArena: 0,
      CheckCheaterMaxUseCostArena: 0,
      AllowedMaxTimeScale: 0,
      RandomAnimationOutput: 0,
      SummonedTeleportDistance: 0,
      ArenaMinimumClearTime: 0,
      WORLDBOSSBATTLELITTLE: 0,
      WORLDBOSSBATTLEMIDDLE: 0,
      WORLDBOSSBATTLEHIGH: 0,
      WORLDBOSSBATTLEVERYHIGH: 0,
      WorldRaidAutoSyncTermSecond: 0,
      WorldRaidBossHpDecreaseTerm: 0,
      WorldRaidBossParcelReactionDelay: 0,
      RaidRankingJumpMinimumWaitingTime: 0,
      EffectTeleportDistance: 0.0,
      AuraExitThresholdMargin: 0,
      TSAInteractionDamageFactor: 0,
      VictoryInteractionRate: 0,
      EchelonExtensionEngageTimelinePath: None,
      EchelonExtensionEngageWithSupporterTimelinePath: None,
      EchelonExtensionVictoryTimelinePath: None,
      EchelonExtensionEchelonMaxCommonCost: 0,
      EchelonMaxOverloadCost: 0,
      EchelonExtensionMaxOverloadCost: 0,
      EchelonExtensionEchelonInitCommonCost: 0,
      EchelonExtensionCostRegenRatio: 0,
      EchelonOverloadCostRegenRatio: 0,
      EchelonExtensionOverloadCostRegenRatio: 0,
      CheckCheaterMaxUseCostMultiFloorRaid: 0,
      ExcessiveTouchCheckTime: 0.0,
      ExcessiveTouchCheckCount: 0,
      CampaignAlertPopupLevelGap: 0,
      MoveCorrectionSkipRatio: 0,
    }
  }
}

impl Serialize for ConstCombatExcel<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("ConstCombatExcel", 87)?;
      s.serialize_field("SkillHandCount", &self.SkillHandCount())?;
      s.serialize_field("DyingTime", &self.DyingTime())?;
      s.serialize_field("BuffIconBlinkTime", &self.BuffIconBlinkTime())?;
      s.serialize_field("ShowBufficonEXSkill", &self.ShowBufficonEXSkill())?;
      s.serialize_field("ShowBufficonPassiveSkill", &self.ShowBufficonPassiveSkill())?;
      s.serialize_field("ShowBufficonExtraPassiveSkill", &self.ShowBufficonExtraPassiveSkill())?;
      s.serialize_field("ShowBufficonLeaderSkill", &self.ShowBufficonLeaderSkill())?;
      s.serialize_field("ShowBufficonGroundPassiveSkill", &self.ShowBufficonGroundPassiveSkill())?;
      if let Some(f) = self.SuppliesConditionStringId() {
        s.serialize_field("SuppliesConditionStringId", &f)?;
      } else {
        s.skip_field("SuppliesConditionStringId")?;
      }
      s.serialize_field("PublicSpeechBubbleOffsetX", &self.PublicSpeechBubbleOffsetX())?;
      s.serialize_field("PublicSpeechBubbleOffsetY", &self.PublicSpeechBubbleOffsetY())?;
      s.serialize_field("PublicSpeechBubbleOffsetZ", &self.PublicSpeechBubbleOffsetZ())?;
      s.serialize_field("ShowRaidListCount", &self.ShowRaidListCount())?;
      s.serialize_field("MaxRaidTicketCount", &self.MaxRaidTicketCount())?;
      s.serialize_field("MaxRaidBossSkillSlot", &self.MaxRaidBossSkillSlot())?;
      if let Some(f) = self.EngageTimelinePath() {
        s.serialize_field("EngageTimelinePath", &f)?;
      } else {
        s.skip_field("EngageTimelinePath")?;
      }
      if let Some(f) = self.EngageWithSupporterTimelinePath() {
        s.serialize_field("EngageWithSupporterTimelinePath", &f)?;
      } else {
        s.skip_field("EngageWithSupporterTimelinePath")?;
      }
      if let Some(f) = self.VictoryTimelinePath() {
        s.serialize_field("VictoryTimelinePath", &f)?;
      } else {
        s.skip_field("VictoryTimelinePath")?;
      }
      s.serialize_field("TimeLimitAlarm", &self.TimeLimitAlarm())?;
      s.serialize_field("EchelonMaxCommonCost", &self.EchelonMaxCommonCost())?;
      s.serialize_field("EchelonInitCommonCost", &self.EchelonInitCommonCost())?;
      s.serialize_field("SkillSlotCoolTime", &self.SkillSlotCoolTime())?;
      s.serialize_field("EnemyRegenCost", &self.EnemyRegenCost())?;
      s.serialize_field("ChampionRegenCost", &self.ChampionRegenCost())?;
      s.serialize_field("PlayerRegenCostDelay", &self.PlayerRegenCostDelay())?;
      s.serialize_field("CrowdControlFactor", &self.CrowdControlFactor())?;
      if let Some(f) = self.RaidOpenScenarioId() {
        s.serialize_field("RaidOpenScenarioId", &f)?;
      } else {
        s.skip_field("RaidOpenScenarioId")?;
      }
      if let Some(f) = self.EliminateRaidOpenScenarioId() {
        s.serialize_field("EliminateRaidOpenScenarioId", &f)?;
      } else {
        s.skip_field("EliminateRaidOpenScenarioId")?;
      }
      s.serialize_field("DefenceConstA", &self.DefenceConstA())?;
      s.serialize_field("DefenceConstB", &self.DefenceConstB())?;
      s.serialize_field("DefenceConstC", &self.DefenceConstC())?;
      s.serialize_field("DefenceConstD", &self.DefenceConstD())?;
      s.serialize_field("AccuracyConstA", &self.AccuracyConstA())?;
      s.serialize_field("AccuracyConstB", &self.AccuracyConstB())?;
      s.serialize_field("AccuracyConstC", &self.AccuracyConstC())?;
      s.serialize_field("AccuracyConstD", &self.AccuracyConstD())?;
      s.serialize_field("CriticalConstA", &self.CriticalConstA())?;
      s.serialize_field("CriticalConstB", &self.CriticalConstB())?;
      s.serialize_field("CriticalConstC", &self.CriticalConstC())?;
      s.serialize_field("CriticalConstD", &self.CriticalConstD())?;
      s.serialize_field("MaxGroupBuffLevel", &self.MaxGroupBuffLevel())?;
      s.serialize_field("EmojiDefaultTime", &self.EmojiDefaultTime())?;
      s.serialize_field("TimeLineActionRotateSpeed", &self.TimeLineActionRotateSpeed())?;
      s.serialize_field("BodyRotateSpeed", &self.BodyRotateSpeed())?;
      s.serialize_field("NormalTimeScale", &self.NormalTimeScale())?;
      s.serialize_field("FastTimeScale", &self.FastTimeScale())?;
      s.serialize_field("BulletTimeScale", &self.BulletTimeScale())?;
      s.serialize_field("UIDisplayDelayAfterSkillCutIn", &self.UIDisplayDelayAfterSkillCutIn())?;
      s.serialize_field("UseInitialRangeForCoverMove", &self.UseInitialRangeForCoverMove())?;
      s.serialize_field("SlowTimeScale", &self.SlowTimeScale())?;
      s.serialize_field("AimIKMinDegree", &self.AimIKMinDegree())?;
      s.serialize_field("AimIKMaxDegree", &self.AimIKMaxDegree())?;
      s.serialize_field("MinimumClearTime", &self.MinimumClearTime())?;
      s.serialize_field("MinimumClearLevelGap", &self.MinimumClearLevelGap())?;
      s.serialize_field("CheckCheaterMaxUseCostNonArena", &self.CheckCheaterMaxUseCostNonArena())?;
      s.serialize_field("CheckCheaterMaxUseCostArena", &self.CheckCheaterMaxUseCostArena())?;
      s.serialize_field("AllowedMaxTimeScale", &self.AllowedMaxTimeScale())?;
      s.serialize_field("RandomAnimationOutput", &self.RandomAnimationOutput())?;
      s.serialize_field("SummonedTeleportDistance", &self.SummonedTeleportDistance())?;
      s.serialize_field("ArenaMinimumClearTime", &self.ArenaMinimumClearTime())?;
      s.serialize_field("WORLDBOSSBATTLELITTLE", &self.WORLDBOSSBATTLELITTLE())?;
      s.serialize_field("WORLDBOSSBATTLEMIDDLE", &self.WORLDBOSSBATTLEMIDDLE())?;
      s.serialize_field("WORLDBOSSBATTLEHIGH", &self.WORLDBOSSBATTLEHIGH())?;
      s.serialize_field("WORLDBOSSBATTLEVERYHIGH", &self.WORLDBOSSBATTLEVERYHIGH())?;
      s.serialize_field("WorldRaidAutoSyncTermSecond", &self.WorldRaidAutoSyncTermSecond())?;
      s.serialize_field("WorldRaidBossHpDecreaseTerm", &self.WorldRaidBossHpDecreaseTerm())?;
      s.serialize_field("WorldRaidBossParcelReactionDelay", &self.WorldRaidBossParcelReactionDelay())?;
      s.serialize_field("RaidRankingJumpMinimumWaitingTime", &self.RaidRankingJumpMinimumWaitingTime())?;
      s.serialize_field("EffectTeleportDistance", &self.EffectTeleportDistance())?;
      s.serialize_field("AuraExitThresholdMargin", &self.AuraExitThresholdMargin())?;
      s.serialize_field("TSAInteractionDamageFactor", &self.TSAInteractionDamageFactor())?;
      s.serialize_field("VictoryInteractionRate", &self.VictoryInteractionRate())?;
      if let Some(f) = self.EchelonExtensionEngageTimelinePath() {
        s.serialize_field("EchelonExtensionEngageTimelinePath", &f)?;
      } else {
        s.skip_field("EchelonExtensionEngageTimelinePath")?;
      }
      if let Some(f) = self.EchelonExtensionEngageWithSupporterTimelinePath() {
        s.serialize_field("EchelonExtensionEngageWithSupporterTimelinePath", &f)?;
      } else {
        s.skip_field("EchelonExtensionEngageWithSupporterTimelinePath")?;
      }
      if let Some(f) = self.EchelonExtensionVictoryTimelinePath() {
        s.serialize_field("EchelonExtensionVictoryTimelinePath", &f)?;
      } else {
        s.skip_field("EchelonExtensionVictoryTimelinePath")?;
      }
      s.serialize_field("EchelonExtensionEchelonMaxCommonCost", &self.EchelonExtensionEchelonMaxCommonCost())?;
      s.serialize_field("EchelonMaxOverloadCost", &self.EchelonMaxOverloadCost())?;
      s.serialize_field("EchelonExtensionMaxOverloadCost", &self.EchelonExtensionMaxOverloadCost())?;
      s.serialize_field("EchelonExtensionEchelonInitCommonCost", &self.EchelonExtensionEchelonInitCommonCost())?;
      s.serialize_field("EchelonExtensionCostRegenRatio", &self.EchelonExtensionCostRegenRatio())?;
      s.serialize_field("EchelonOverloadCostRegenRatio", &self.EchelonOverloadCostRegenRatio())?;
      s.serialize_field("EchelonExtensionOverloadCostRegenRatio", &self.EchelonExtensionOverloadCostRegenRatio())?;
      s.serialize_field("CheckCheaterMaxUseCostMultiFloorRaid", &self.CheckCheaterMaxUseCostMultiFloorRaid())?;
      s.serialize_field("ExcessiveTouchCheckTime", &self.ExcessiveTouchCheckTime())?;
      s.serialize_field("ExcessiveTouchCheckCount", &self.ExcessiveTouchCheckCount())?;
      s.serialize_field("CampaignAlertPopupLevelGap", &self.CampaignAlertPopupLevelGap())?;
      s.serialize_field("MoveCorrectionSkipRatio", &self.MoveCorrectionSkipRatio())?;
    s.end()
  }
}

pub struct ConstCombatExcelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ConstCombatExcelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_SkillHandCount(&mut self, SkillHandCount: i32) {
    self.fbb_.push_slot::<i32>(ConstCombatExcel::VT_SKILLHANDCOUNT, SkillHandCount, 0);
  }
  #[inline]
  pub fn add_DyingTime(&mut self, DyingTime: i32) {
    self.fbb_.push_slot::<i32>(ConstCombatExcel::VT_DYINGTIME, DyingTime, 0);
  }
  #[inline]
  pub fn add_BuffIconBlinkTime(&mut self, BuffIconBlinkTime: i32) {
    self.fbb_.push_slot::<i32>(ConstCombatExcel::VT_BUFFICONBLINKTIME, BuffIconBlinkTime, 0);
  }
  #[inline]
  pub fn add_ShowBufficonEXSkill(&mut self, ShowBufficonEXSkill: bool) {
    self.fbb_.push_slot::<bool>(ConstCombatExcel::VT_SHOWBUFFICONEXSKILL, ShowBufficonEXSkill, false);
  }
  #[inline]
  pub fn add_ShowBufficonPassiveSkill(&mut self, ShowBufficonPassiveSkill: bool) {
    self.fbb_.push_slot::<bool>(ConstCombatExcel::VT_SHOWBUFFICONPASSIVESKILL, ShowBufficonPassiveSkill, false);
  }
  #[inline]
  pub fn add_ShowBufficonExtraPassiveSkill(&mut self, ShowBufficonExtraPassiveSkill: bool) {
    self.fbb_.push_slot::<bool>(ConstCombatExcel::VT_SHOWBUFFICONEXTRAPASSIVESKILL, ShowBufficonExtraPassiveSkill, false);
  }
  #[inline]
  pub fn add_ShowBufficonLeaderSkill(&mut self, ShowBufficonLeaderSkill: bool) {
    self.fbb_.push_slot::<bool>(ConstCombatExcel::VT_SHOWBUFFICONLEADERSKILL, ShowBufficonLeaderSkill, false);
  }
  #[inline]
  pub fn add_ShowBufficonGroundPassiveSkill(&mut self, ShowBufficonGroundPassiveSkill: bool) {
    self.fbb_.push_slot::<bool>(ConstCombatExcel::VT_SHOWBUFFICONGROUNDPASSIVESKILL, ShowBufficonGroundPassiveSkill, false);
  }
  #[inline]
  pub fn add_SuppliesConditionStringId(&mut self, SuppliesConditionStringId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConstCombatExcel::VT_SUPPLIESCONDITIONSTRINGID, SuppliesConditionStringId);
  }
  #[inline]
  pub fn add_PublicSpeechBubbleOffsetX(&mut self, PublicSpeechBubbleOffsetX: f32) {
    self.fbb_.push_slot::<f32>(ConstCombatExcel::VT_PUBLICSPEECHBUBBLEOFFSETX, PublicSpeechBubbleOffsetX, 0.0);
  }
  #[inline]
  pub fn add_PublicSpeechBubbleOffsetY(&mut self, PublicSpeechBubbleOffsetY: f32) {
    self.fbb_.push_slot::<f32>(ConstCombatExcel::VT_PUBLICSPEECHBUBBLEOFFSETY, PublicSpeechBubbleOffsetY, 0.0);
  }
  #[inline]
  pub fn add_PublicSpeechBubbleOffsetZ(&mut self, PublicSpeechBubbleOffsetZ: f32) {
    self.fbb_.push_slot::<f32>(ConstCombatExcel::VT_PUBLICSPEECHBUBBLEOFFSETZ, PublicSpeechBubbleOffsetZ, 0.0);
  }
  #[inline]
  pub fn add_ShowRaidListCount(&mut self, ShowRaidListCount: i32) {
    self.fbb_.push_slot::<i32>(ConstCombatExcel::VT_SHOWRAIDLISTCOUNT, ShowRaidListCount, 0);
  }
  #[inline]
  pub fn add_MaxRaidTicketCount(&mut self, MaxRaidTicketCount: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_MAXRAIDTICKETCOUNT, MaxRaidTicketCount, 0);
  }
  #[inline]
  pub fn add_MaxRaidBossSkillSlot(&mut self, MaxRaidBossSkillSlot: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_MAXRAIDBOSSSKILLSLOT, MaxRaidBossSkillSlot, 0);
  }
  #[inline]
  pub fn add_EngageTimelinePath(&mut self, EngageTimelinePath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConstCombatExcel::VT_ENGAGETIMELINEPATH, EngageTimelinePath);
  }
  #[inline]
  pub fn add_EngageWithSupporterTimelinePath(&mut self, EngageWithSupporterTimelinePath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConstCombatExcel::VT_ENGAGEWITHSUPPORTERTIMELINEPATH, EngageWithSupporterTimelinePath);
  }
  #[inline]
  pub fn add_VictoryTimelinePath(&mut self, VictoryTimelinePath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConstCombatExcel::VT_VICTORYTIMELINEPATH, VictoryTimelinePath);
  }
  #[inline]
  pub fn add_TimeLimitAlarm(&mut self, TimeLimitAlarm: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_TIMELIMITALARM, TimeLimitAlarm, 0);
  }
  #[inline]
  pub fn add_EchelonMaxCommonCost(&mut self, EchelonMaxCommonCost: i32) {
    self.fbb_.push_slot::<i32>(ConstCombatExcel::VT_ECHELONMAXCOMMONCOST, EchelonMaxCommonCost, 0);
  }
  #[inline]
  pub fn add_EchelonInitCommonCost(&mut self, EchelonInitCommonCost: i32) {
    self.fbb_.push_slot::<i32>(ConstCombatExcel::VT_ECHELONINITCOMMONCOST, EchelonInitCommonCost, 0);
  }
  #[inline]
  pub fn add_SkillSlotCoolTime(&mut self, SkillSlotCoolTime: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_SKILLSLOTCOOLTIME, SkillSlotCoolTime, 0);
  }
  #[inline]
  pub fn add_EnemyRegenCost(&mut self, EnemyRegenCost: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_ENEMYREGENCOST, EnemyRegenCost, 0);
  }
  #[inline]
  pub fn add_ChampionRegenCost(&mut self, ChampionRegenCost: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_CHAMPIONREGENCOST, ChampionRegenCost, 0);
  }
  #[inline]
  pub fn add_PlayerRegenCostDelay(&mut self, PlayerRegenCostDelay: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_PLAYERREGENCOSTDELAY, PlayerRegenCostDelay, 0);
  }
  #[inline]
  pub fn add_CrowdControlFactor(&mut self, CrowdControlFactor: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_CROWDCONTROLFACTOR, CrowdControlFactor, 0);
  }
  #[inline]
  pub fn add_RaidOpenScenarioId(&mut self, RaidOpenScenarioId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConstCombatExcel::VT_RAIDOPENSCENARIOID, RaidOpenScenarioId);
  }
  #[inline]
  pub fn add_EliminateRaidOpenScenarioId(&mut self, EliminateRaidOpenScenarioId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConstCombatExcel::VT_ELIMINATERAIDOPENSCENARIOID, EliminateRaidOpenScenarioId);
  }
  #[inline]
  pub fn add_DefenceConstA(&mut self, DefenceConstA: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_DEFENCECONSTA, DefenceConstA, 0);
  }
  #[inline]
  pub fn add_DefenceConstB(&mut self, DefenceConstB: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_DEFENCECONSTB, DefenceConstB, 0);
  }
  #[inline]
  pub fn add_DefenceConstC(&mut self, DefenceConstC: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_DEFENCECONSTC, DefenceConstC, 0);
  }
  #[inline]
  pub fn add_DefenceConstD(&mut self, DefenceConstD: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_DEFENCECONSTD, DefenceConstD, 0);
  }
  #[inline]
  pub fn add_AccuracyConstA(&mut self, AccuracyConstA: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_ACCURACYCONSTA, AccuracyConstA, 0);
  }
  #[inline]
  pub fn add_AccuracyConstB(&mut self, AccuracyConstB: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_ACCURACYCONSTB, AccuracyConstB, 0);
  }
  #[inline]
  pub fn add_AccuracyConstC(&mut self, AccuracyConstC: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_ACCURACYCONSTC, AccuracyConstC, 0);
  }
  #[inline]
  pub fn add_AccuracyConstD(&mut self, AccuracyConstD: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_ACCURACYCONSTD, AccuracyConstD, 0);
  }
  #[inline]
  pub fn add_CriticalConstA(&mut self, CriticalConstA: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_CRITICALCONSTA, CriticalConstA, 0);
  }
  #[inline]
  pub fn add_CriticalConstB(&mut self, CriticalConstB: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_CRITICALCONSTB, CriticalConstB, 0);
  }
  #[inline]
  pub fn add_CriticalConstC(&mut self, CriticalConstC: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_CRITICALCONSTC, CriticalConstC, 0);
  }
  #[inline]
  pub fn add_CriticalConstD(&mut self, CriticalConstD: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_CRITICALCONSTD, CriticalConstD, 0);
  }
  #[inline]
  pub fn add_MaxGroupBuffLevel(&mut self, MaxGroupBuffLevel: i32) {
    self.fbb_.push_slot::<i32>(ConstCombatExcel::VT_MAXGROUPBUFFLEVEL, MaxGroupBuffLevel, 0);
  }
  #[inline]
  pub fn add_EmojiDefaultTime(&mut self, EmojiDefaultTime: i32) {
    self.fbb_.push_slot::<i32>(ConstCombatExcel::VT_EMOJIDEFAULTTIME, EmojiDefaultTime, 0);
  }
  #[inline]
  pub fn add_TimeLineActionRotateSpeed(&mut self, TimeLineActionRotateSpeed: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_TIMELINEACTIONROTATESPEED, TimeLineActionRotateSpeed, 0);
  }
  #[inline]
  pub fn add_BodyRotateSpeed(&mut self, BodyRotateSpeed: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_BODYROTATESPEED, BodyRotateSpeed, 0);
  }
  #[inline]
  pub fn add_NormalTimeScale(&mut self, NormalTimeScale: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_NORMALTIMESCALE, NormalTimeScale, 0);
  }
  #[inline]
  pub fn add_FastTimeScale(&mut self, FastTimeScale: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_FASTTIMESCALE, FastTimeScale, 0);
  }
  #[inline]
  pub fn add_BulletTimeScale(&mut self, BulletTimeScale: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_BULLETTIMESCALE, BulletTimeScale, 0);
  }
  #[inline]
  pub fn add_UIDisplayDelayAfterSkillCutIn(&mut self, UIDisplayDelayAfterSkillCutIn: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_UIDISPLAYDELAYAFTERSKILLCUTIN, UIDisplayDelayAfterSkillCutIn, 0);
  }
  #[inline]
  pub fn add_UseInitialRangeForCoverMove(&mut self, UseInitialRangeForCoverMove: bool) {
    self.fbb_.push_slot::<bool>(ConstCombatExcel::VT_USEINITIALRANGEFORCOVERMOVE, UseInitialRangeForCoverMove, false);
  }
  #[inline]
  pub fn add_SlowTimeScale(&mut self, SlowTimeScale: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_SLOWTIMESCALE, SlowTimeScale, 0);
  }
  #[inline]
  pub fn add_AimIKMinDegree(&mut self, AimIKMinDegree: f32) {
    self.fbb_.push_slot::<f32>(ConstCombatExcel::VT_AIMIKMINDEGREE, AimIKMinDegree, 0.0);
  }
  #[inline]
  pub fn add_AimIKMaxDegree(&mut self, AimIKMaxDegree: f32) {
    self.fbb_.push_slot::<f32>(ConstCombatExcel::VT_AIMIKMAXDEGREE, AimIKMaxDegree, 0.0);
  }
  #[inline]
  pub fn add_MinimumClearTime(&mut self, MinimumClearTime: i32) {
    self.fbb_.push_slot::<i32>(ConstCombatExcel::VT_MINIMUMCLEARTIME, MinimumClearTime, 0);
  }
  #[inline]
  pub fn add_MinimumClearLevelGap(&mut self, MinimumClearLevelGap: i32) {
    self.fbb_.push_slot::<i32>(ConstCombatExcel::VT_MINIMUMCLEARLEVELGAP, MinimumClearLevelGap, 0);
  }
  #[inline]
  pub fn add_CheckCheaterMaxUseCostNonArena(&mut self, CheckCheaterMaxUseCostNonArena: i32) {
    self.fbb_.push_slot::<i32>(ConstCombatExcel::VT_CHECKCHEATERMAXUSECOSTNONARENA, CheckCheaterMaxUseCostNonArena, 0);
  }
  #[inline]
  pub fn add_CheckCheaterMaxUseCostArena(&mut self, CheckCheaterMaxUseCostArena: i32) {
    self.fbb_.push_slot::<i32>(ConstCombatExcel::VT_CHECKCHEATERMAXUSECOSTARENA, CheckCheaterMaxUseCostArena, 0);
  }
  #[inline]
  pub fn add_AllowedMaxTimeScale(&mut self, AllowedMaxTimeScale: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_ALLOWEDMAXTIMESCALE, AllowedMaxTimeScale, 0);
  }
  #[inline]
  pub fn add_RandomAnimationOutput(&mut self, RandomAnimationOutput: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_RANDOMANIMATIONOUTPUT, RandomAnimationOutput, 0);
  }
  #[inline]
  pub fn add_SummonedTeleportDistance(&mut self, SummonedTeleportDistance: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_SUMMONEDTELEPORTDISTANCE, SummonedTeleportDistance, 0);
  }
  #[inline]
  pub fn add_ArenaMinimumClearTime(&mut self, ArenaMinimumClearTime: i32) {
    self.fbb_.push_slot::<i32>(ConstCombatExcel::VT_ARENAMINIMUMCLEARTIME, ArenaMinimumClearTime, 0);
  }
  #[inline]
  pub fn add_WORLDBOSSBATTLELITTLE(&mut self, WORLDBOSSBATTLELITTLE: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_WORLDBOSSBATTLELITTLE, WORLDBOSSBATTLELITTLE, 0);
  }
  #[inline]
  pub fn add_WORLDBOSSBATTLEMIDDLE(&mut self, WORLDBOSSBATTLEMIDDLE: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_WORLDBOSSBATTLEMIDDLE, WORLDBOSSBATTLEMIDDLE, 0);
  }
  #[inline]
  pub fn add_WORLDBOSSBATTLEHIGH(&mut self, WORLDBOSSBATTLEHIGH: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_WORLDBOSSBATTLEHIGH, WORLDBOSSBATTLEHIGH, 0);
  }
  #[inline]
  pub fn add_WORLDBOSSBATTLEVERYHIGH(&mut self, WORLDBOSSBATTLEVERYHIGH: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_WORLDBOSSBATTLEVERYHIGH, WORLDBOSSBATTLEVERYHIGH, 0);
  }
  #[inline]
  pub fn add_WorldRaidAutoSyncTermSecond(&mut self, WorldRaidAutoSyncTermSecond: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_WORLDRAIDAUTOSYNCTERMSECOND, WorldRaidAutoSyncTermSecond, 0);
  }
  #[inline]
  pub fn add_WorldRaidBossHpDecreaseTerm(&mut self, WorldRaidBossHpDecreaseTerm: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_WORLDRAIDBOSSHPDECREASETERM, WorldRaidBossHpDecreaseTerm, 0);
  }
  #[inline]
  pub fn add_WorldRaidBossParcelReactionDelay(&mut self, WorldRaidBossParcelReactionDelay: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_WORLDRAIDBOSSPARCELREACTIONDELAY, WorldRaidBossParcelReactionDelay, 0);
  }
  #[inline]
  pub fn add_RaidRankingJumpMinimumWaitingTime(&mut self, RaidRankingJumpMinimumWaitingTime: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_RAIDRANKINGJUMPMINIMUMWAITINGTIME, RaidRankingJumpMinimumWaitingTime, 0);
  }
  #[inline]
  pub fn add_EffectTeleportDistance(&mut self, EffectTeleportDistance: f32) {
    self.fbb_.push_slot::<f32>(ConstCombatExcel::VT_EFFECTTELEPORTDISTANCE, EffectTeleportDistance, 0.0);
  }
  #[inline]
  pub fn add_AuraExitThresholdMargin(&mut self, AuraExitThresholdMargin: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_AURAEXITTHRESHOLDMARGIN, AuraExitThresholdMargin, 0);
  }
  #[inline]
  pub fn add_TSAInteractionDamageFactor(&mut self, TSAInteractionDamageFactor: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_TSAINTERACTIONDAMAGEFACTOR, TSAInteractionDamageFactor, 0);
  }
  #[inline]
  pub fn add_VictoryInteractionRate(&mut self, VictoryInteractionRate: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_VICTORYINTERACTIONRATE, VictoryInteractionRate, 0);
  }
  #[inline]
  pub fn add_EchelonExtensionEngageTimelinePath(&mut self, EchelonExtensionEngageTimelinePath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConstCombatExcel::VT_ECHELONEXTENSIONENGAGETIMELINEPATH, EchelonExtensionEngageTimelinePath);
  }
  #[inline]
  pub fn add_EchelonExtensionEngageWithSupporterTimelinePath(&mut self, EchelonExtensionEngageWithSupporterTimelinePath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConstCombatExcel::VT_ECHELONEXTENSIONENGAGEWITHSUPPORTERTIMELINEPATH, EchelonExtensionEngageWithSupporterTimelinePath);
  }
  #[inline]
  pub fn add_EchelonExtensionVictoryTimelinePath(&mut self, EchelonExtensionVictoryTimelinePath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConstCombatExcel::VT_ECHELONEXTENSIONVICTORYTIMELINEPATH, EchelonExtensionVictoryTimelinePath);
  }
  #[inline]
  pub fn add_EchelonExtensionEchelonMaxCommonCost(&mut self, EchelonExtensionEchelonMaxCommonCost: i32) {
    self.fbb_.push_slot::<i32>(ConstCombatExcel::VT_ECHELONEXTENSIONECHELONMAXCOMMONCOST, EchelonExtensionEchelonMaxCommonCost, 0);
  }
  #[inline]
  pub fn add_EchelonMaxOverloadCost(&mut self, EchelonMaxOverloadCost: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_ECHELONMAXOVERLOADCOST, EchelonMaxOverloadCost, 0);
  }
  #[inline]
  pub fn add_EchelonExtensionMaxOverloadCost(&mut self, EchelonExtensionMaxOverloadCost: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_ECHELONEXTENSIONMAXOVERLOADCOST, EchelonExtensionMaxOverloadCost, 0);
  }
  #[inline]
  pub fn add_EchelonExtensionEchelonInitCommonCost(&mut self, EchelonExtensionEchelonInitCommonCost: i32) {
    self.fbb_.push_slot::<i32>(ConstCombatExcel::VT_ECHELONEXTENSIONECHELONINITCOMMONCOST, EchelonExtensionEchelonInitCommonCost, 0);
  }
  #[inline]
  pub fn add_EchelonExtensionCostRegenRatio(&mut self, EchelonExtensionCostRegenRatio: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_ECHELONEXTENSIONCOSTREGENRATIO, EchelonExtensionCostRegenRatio, 0);
  }
  #[inline]
  pub fn add_EchelonOverloadCostRegenRatio(&mut self, EchelonOverloadCostRegenRatio: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_ECHELONOVERLOADCOSTREGENRATIO, EchelonOverloadCostRegenRatio, 0);
  }
  #[inline]
  pub fn add_EchelonExtensionOverloadCostRegenRatio(&mut self, EchelonExtensionOverloadCostRegenRatio: i64) {
    self.fbb_.push_slot::<i64>(ConstCombatExcel::VT_ECHELONEXTENSIONOVERLOADCOSTREGENRATIO, EchelonExtensionOverloadCostRegenRatio, 0);
  }
  #[inline]
  pub fn add_CheckCheaterMaxUseCostMultiFloorRaid(&mut self, CheckCheaterMaxUseCostMultiFloorRaid: i32) {
    self.fbb_.push_slot::<i32>(ConstCombatExcel::VT_CHECKCHEATERMAXUSECOSTMULTIFLOORRAID, CheckCheaterMaxUseCostMultiFloorRaid, 0);
  }
  #[inline]
  pub fn add_ExcessiveTouchCheckTime(&mut self, ExcessiveTouchCheckTime: f32) {
    self.fbb_.push_slot::<f32>(ConstCombatExcel::VT_EXCESSIVETOUCHCHECKTIME, ExcessiveTouchCheckTime, 0.0);
  }
  #[inline]
  pub fn add_ExcessiveTouchCheckCount(&mut self, ExcessiveTouchCheckCount: i32) {
    self.fbb_.push_slot::<i32>(ConstCombatExcel::VT_EXCESSIVETOUCHCHECKCOUNT, ExcessiveTouchCheckCount, 0);
  }
  #[inline]
  pub fn add_CampaignAlertPopupLevelGap(&mut self, CampaignAlertPopupLevelGap: i32) {
    self.fbb_.push_slot::<i32>(ConstCombatExcel::VT_CAMPAIGNALERTPOPUPLEVELGAP, CampaignAlertPopupLevelGap, 0);
  }
  #[inline]
  pub fn add_MoveCorrectionSkipRatio(&mut self, MoveCorrectionSkipRatio: i32) {
    self.fbb_.push_slot::<i32>(ConstCombatExcel::VT_MOVECORRECTIONSKIPRATIO, MoveCorrectionSkipRatio, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ConstCombatExcelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ConstCombatExcelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ConstCombatExcel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ConstCombatExcel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ConstCombatExcel");
      ds.field("SkillHandCount", &self.SkillHandCount());
      ds.field("DyingTime", &self.DyingTime());
      ds.field("BuffIconBlinkTime", &self.BuffIconBlinkTime());
      ds.field("ShowBufficonEXSkill", &self.ShowBufficonEXSkill());
      ds.field("ShowBufficonPassiveSkill", &self.ShowBufficonPassiveSkill());
      ds.field("ShowBufficonExtraPassiveSkill", &self.ShowBufficonExtraPassiveSkill());
      ds.field("ShowBufficonLeaderSkill", &self.ShowBufficonLeaderSkill());
      ds.field("ShowBufficonGroundPassiveSkill", &self.ShowBufficonGroundPassiveSkill());
      ds.field("SuppliesConditionStringId", &self.SuppliesConditionStringId());
      ds.field("PublicSpeechBubbleOffsetX", &self.PublicSpeechBubbleOffsetX());
      ds.field("PublicSpeechBubbleOffsetY", &self.PublicSpeechBubbleOffsetY());
      ds.field("PublicSpeechBubbleOffsetZ", &self.PublicSpeechBubbleOffsetZ());
      ds.field("ShowRaidListCount", &self.ShowRaidListCount());
      ds.field("MaxRaidTicketCount", &self.MaxRaidTicketCount());
      ds.field("MaxRaidBossSkillSlot", &self.MaxRaidBossSkillSlot());
      ds.field("EngageTimelinePath", &self.EngageTimelinePath());
      ds.field("EngageWithSupporterTimelinePath", &self.EngageWithSupporterTimelinePath());
      ds.field("VictoryTimelinePath", &self.VictoryTimelinePath());
      ds.field("TimeLimitAlarm", &self.TimeLimitAlarm());
      ds.field("EchelonMaxCommonCost", &self.EchelonMaxCommonCost());
      ds.field("EchelonInitCommonCost", &self.EchelonInitCommonCost());
      ds.field("SkillSlotCoolTime", &self.SkillSlotCoolTime());
      ds.field("EnemyRegenCost", &self.EnemyRegenCost());
      ds.field("ChampionRegenCost", &self.ChampionRegenCost());
      ds.field("PlayerRegenCostDelay", &self.PlayerRegenCostDelay());
      ds.field("CrowdControlFactor", &self.CrowdControlFactor());
      ds.field("RaidOpenScenarioId", &self.RaidOpenScenarioId());
      ds.field("EliminateRaidOpenScenarioId", &self.EliminateRaidOpenScenarioId());
      ds.field("DefenceConstA", &self.DefenceConstA());
      ds.field("DefenceConstB", &self.DefenceConstB());
      ds.field("DefenceConstC", &self.DefenceConstC());
      ds.field("DefenceConstD", &self.DefenceConstD());
      ds.field("AccuracyConstA", &self.AccuracyConstA());
      ds.field("AccuracyConstB", &self.AccuracyConstB());
      ds.field("AccuracyConstC", &self.AccuracyConstC());
      ds.field("AccuracyConstD", &self.AccuracyConstD());
      ds.field("CriticalConstA", &self.CriticalConstA());
      ds.field("CriticalConstB", &self.CriticalConstB());
      ds.field("CriticalConstC", &self.CriticalConstC());
      ds.field("CriticalConstD", &self.CriticalConstD());
      ds.field("MaxGroupBuffLevel", &self.MaxGroupBuffLevel());
      ds.field("EmojiDefaultTime", &self.EmojiDefaultTime());
      ds.field("TimeLineActionRotateSpeed", &self.TimeLineActionRotateSpeed());
      ds.field("BodyRotateSpeed", &self.BodyRotateSpeed());
      ds.field("NormalTimeScale", &self.NormalTimeScale());
      ds.field("FastTimeScale", &self.FastTimeScale());
      ds.field("BulletTimeScale", &self.BulletTimeScale());
      ds.field("UIDisplayDelayAfterSkillCutIn", &self.UIDisplayDelayAfterSkillCutIn());
      ds.field("UseInitialRangeForCoverMove", &self.UseInitialRangeForCoverMove());
      ds.field("SlowTimeScale", &self.SlowTimeScale());
      ds.field("AimIKMinDegree", &self.AimIKMinDegree());
      ds.field("AimIKMaxDegree", &self.AimIKMaxDegree());
      ds.field("MinimumClearTime", &self.MinimumClearTime());
      ds.field("MinimumClearLevelGap", &self.MinimumClearLevelGap());
      ds.field("CheckCheaterMaxUseCostNonArena", &self.CheckCheaterMaxUseCostNonArena());
      ds.field("CheckCheaterMaxUseCostArena", &self.CheckCheaterMaxUseCostArena());
      ds.field("AllowedMaxTimeScale", &self.AllowedMaxTimeScale());
      ds.field("RandomAnimationOutput", &self.RandomAnimationOutput());
      ds.field("SummonedTeleportDistance", &self.SummonedTeleportDistance());
      ds.field("ArenaMinimumClearTime", &self.ArenaMinimumClearTime());
      ds.field("WORLDBOSSBATTLELITTLE", &self.WORLDBOSSBATTLELITTLE());
      ds.field("WORLDBOSSBATTLEMIDDLE", &self.WORLDBOSSBATTLEMIDDLE());
      ds.field("WORLDBOSSBATTLEHIGH", &self.WORLDBOSSBATTLEHIGH());
      ds.field("WORLDBOSSBATTLEVERYHIGH", &self.WORLDBOSSBATTLEVERYHIGH());
      ds.field("WorldRaidAutoSyncTermSecond", &self.WorldRaidAutoSyncTermSecond());
      ds.field("WorldRaidBossHpDecreaseTerm", &self.WorldRaidBossHpDecreaseTerm());
      ds.field("WorldRaidBossParcelReactionDelay", &self.WorldRaidBossParcelReactionDelay());
      ds.field("RaidRankingJumpMinimumWaitingTime", &self.RaidRankingJumpMinimumWaitingTime());
      ds.field("EffectTeleportDistance", &self.EffectTeleportDistance());
      ds.field("AuraExitThresholdMargin", &self.AuraExitThresholdMargin());
      ds.field("TSAInteractionDamageFactor", &self.TSAInteractionDamageFactor());
      ds.field("VictoryInteractionRate", &self.VictoryInteractionRate());
      ds.field("EchelonExtensionEngageTimelinePath", &self.EchelonExtensionEngageTimelinePath());
      ds.field("EchelonExtensionEngageWithSupporterTimelinePath", &self.EchelonExtensionEngageWithSupporterTimelinePath());
      ds.field("EchelonExtensionVictoryTimelinePath", &self.EchelonExtensionVictoryTimelinePath());
      ds.field("EchelonExtensionEchelonMaxCommonCost", &self.EchelonExtensionEchelonMaxCommonCost());
      ds.field("EchelonMaxOverloadCost", &self.EchelonMaxOverloadCost());
      ds.field("EchelonExtensionMaxOverloadCost", &self.EchelonExtensionMaxOverloadCost());
      ds.field("EchelonExtensionEchelonInitCommonCost", &self.EchelonExtensionEchelonInitCommonCost());
      ds.field("EchelonExtensionCostRegenRatio", &self.EchelonExtensionCostRegenRatio());
      ds.field("EchelonOverloadCostRegenRatio", &self.EchelonOverloadCostRegenRatio());
      ds.field("EchelonExtensionOverloadCostRegenRatio", &self.EchelonExtensionOverloadCostRegenRatio());
      ds.field("CheckCheaterMaxUseCostMultiFloorRaid", &self.CheckCheaterMaxUseCostMultiFloorRaid());
      ds.field("ExcessiveTouchCheckTime", &self.ExcessiveTouchCheckTime());
      ds.field("ExcessiveTouchCheckCount", &self.ExcessiveTouchCheckCount());
      ds.field("CampaignAlertPopupLevelGap", &self.CampaignAlertPopupLevelGap());
      ds.field("MoveCorrectionSkipRatio", &self.MoveCorrectionSkipRatio());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ConstCombatExcelT {
  pub SkillHandCount: i32,
  pub DyingTime: i32,
  pub BuffIconBlinkTime: i32,
  pub ShowBufficonEXSkill: bool,
  pub ShowBufficonPassiveSkill: bool,
  pub ShowBufficonExtraPassiveSkill: bool,
  pub ShowBufficonLeaderSkill: bool,
  pub ShowBufficonGroundPassiveSkill: bool,
  pub SuppliesConditionStringId: Option<String>,
  pub PublicSpeechBubbleOffsetX: f32,
  pub PublicSpeechBubbleOffsetY: f32,
  pub PublicSpeechBubbleOffsetZ: f32,
  pub ShowRaidListCount: i32,
  pub MaxRaidTicketCount: i64,
  pub MaxRaidBossSkillSlot: i64,
  pub EngageTimelinePath: Option<String>,
  pub EngageWithSupporterTimelinePath: Option<String>,
  pub VictoryTimelinePath: Option<String>,
  pub TimeLimitAlarm: i64,
  pub EchelonMaxCommonCost: i32,
  pub EchelonInitCommonCost: i32,
  pub SkillSlotCoolTime: i64,
  pub EnemyRegenCost: i64,
  pub ChampionRegenCost: i64,
  pub PlayerRegenCostDelay: i64,
  pub CrowdControlFactor: i64,
  pub RaidOpenScenarioId: Option<String>,
  pub EliminateRaidOpenScenarioId: Option<String>,
  pub DefenceConstA: i64,
  pub DefenceConstB: i64,
  pub DefenceConstC: i64,
  pub DefenceConstD: i64,
  pub AccuracyConstA: i64,
  pub AccuracyConstB: i64,
  pub AccuracyConstC: i64,
  pub AccuracyConstD: i64,
  pub CriticalConstA: i64,
  pub CriticalConstB: i64,
  pub CriticalConstC: i64,
  pub CriticalConstD: i64,
  pub MaxGroupBuffLevel: i32,
  pub EmojiDefaultTime: i32,
  pub TimeLineActionRotateSpeed: i64,
  pub BodyRotateSpeed: i64,
  pub NormalTimeScale: i64,
  pub FastTimeScale: i64,
  pub BulletTimeScale: i64,
  pub UIDisplayDelayAfterSkillCutIn: i64,
  pub UseInitialRangeForCoverMove: bool,
  pub SlowTimeScale: i64,
  pub AimIKMinDegree: f32,
  pub AimIKMaxDegree: f32,
  pub MinimumClearTime: i32,
  pub MinimumClearLevelGap: i32,
  pub CheckCheaterMaxUseCostNonArena: i32,
  pub CheckCheaterMaxUseCostArena: i32,
  pub AllowedMaxTimeScale: i64,
  pub RandomAnimationOutput: i64,
  pub SummonedTeleportDistance: i64,
  pub ArenaMinimumClearTime: i32,
  pub WORLDBOSSBATTLELITTLE: i64,
  pub WORLDBOSSBATTLEMIDDLE: i64,
  pub WORLDBOSSBATTLEHIGH: i64,
  pub WORLDBOSSBATTLEVERYHIGH: i64,
  pub WorldRaidAutoSyncTermSecond: i64,
  pub WorldRaidBossHpDecreaseTerm: i64,
  pub WorldRaidBossParcelReactionDelay: i64,
  pub RaidRankingJumpMinimumWaitingTime: i64,
  pub EffectTeleportDistance: f32,
  pub AuraExitThresholdMargin: i64,
  pub TSAInteractionDamageFactor: i64,
  pub VictoryInteractionRate: i64,
  pub EchelonExtensionEngageTimelinePath: Option<String>,
  pub EchelonExtensionEngageWithSupporterTimelinePath: Option<String>,
  pub EchelonExtensionVictoryTimelinePath: Option<String>,
  pub EchelonExtensionEchelonMaxCommonCost: i32,
  pub EchelonMaxOverloadCost: i64,
  pub EchelonExtensionMaxOverloadCost: i64,
  pub EchelonExtensionEchelonInitCommonCost: i32,
  pub EchelonExtensionCostRegenRatio: i64,
  pub EchelonOverloadCostRegenRatio: i64,
  pub EchelonExtensionOverloadCostRegenRatio: i64,
  pub CheckCheaterMaxUseCostMultiFloorRaid: i32,
  pub ExcessiveTouchCheckTime: f32,
  pub ExcessiveTouchCheckCount: i32,
  pub CampaignAlertPopupLevelGap: i32,
  pub MoveCorrectionSkipRatio: i32,
}
impl Default for ConstCombatExcelT {
  fn default() -> Self {
    Self {
      SkillHandCount: 0,
      DyingTime: 0,
      BuffIconBlinkTime: 0,
      ShowBufficonEXSkill: false,
      ShowBufficonPassiveSkill: false,
      ShowBufficonExtraPassiveSkill: false,
      ShowBufficonLeaderSkill: false,
      ShowBufficonGroundPassiveSkill: false,
      SuppliesConditionStringId: None,
      PublicSpeechBubbleOffsetX: 0.0,
      PublicSpeechBubbleOffsetY: 0.0,
      PublicSpeechBubbleOffsetZ: 0.0,
      ShowRaidListCount: 0,
      MaxRaidTicketCount: 0,
      MaxRaidBossSkillSlot: 0,
      EngageTimelinePath: None,
      EngageWithSupporterTimelinePath: None,
      VictoryTimelinePath: None,
      TimeLimitAlarm: 0,
      EchelonMaxCommonCost: 0,
      EchelonInitCommonCost: 0,
      SkillSlotCoolTime: 0,
      EnemyRegenCost: 0,
      ChampionRegenCost: 0,
      PlayerRegenCostDelay: 0,
      CrowdControlFactor: 0,
      RaidOpenScenarioId: None,
      EliminateRaidOpenScenarioId: None,
      DefenceConstA: 0,
      DefenceConstB: 0,
      DefenceConstC: 0,
      DefenceConstD: 0,
      AccuracyConstA: 0,
      AccuracyConstB: 0,
      AccuracyConstC: 0,
      AccuracyConstD: 0,
      CriticalConstA: 0,
      CriticalConstB: 0,
      CriticalConstC: 0,
      CriticalConstD: 0,
      MaxGroupBuffLevel: 0,
      EmojiDefaultTime: 0,
      TimeLineActionRotateSpeed: 0,
      BodyRotateSpeed: 0,
      NormalTimeScale: 0,
      FastTimeScale: 0,
      BulletTimeScale: 0,
      UIDisplayDelayAfterSkillCutIn: 0,
      UseInitialRangeForCoverMove: false,
      SlowTimeScale: 0,
      AimIKMinDegree: 0.0,
      AimIKMaxDegree: 0.0,
      MinimumClearTime: 0,
      MinimumClearLevelGap: 0,
      CheckCheaterMaxUseCostNonArena: 0,
      CheckCheaterMaxUseCostArena: 0,
      AllowedMaxTimeScale: 0,
      RandomAnimationOutput: 0,
      SummonedTeleportDistance: 0,
      ArenaMinimumClearTime: 0,
      WORLDBOSSBATTLELITTLE: 0,
      WORLDBOSSBATTLEMIDDLE: 0,
      WORLDBOSSBATTLEHIGH: 0,
      WORLDBOSSBATTLEVERYHIGH: 0,
      WorldRaidAutoSyncTermSecond: 0,
      WorldRaidBossHpDecreaseTerm: 0,
      WorldRaidBossParcelReactionDelay: 0,
      RaidRankingJumpMinimumWaitingTime: 0,
      EffectTeleportDistance: 0.0,
      AuraExitThresholdMargin: 0,
      TSAInteractionDamageFactor: 0,
      VictoryInteractionRate: 0,
      EchelonExtensionEngageTimelinePath: None,
      EchelonExtensionEngageWithSupporterTimelinePath: None,
      EchelonExtensionVictoryTimelinePath: None,
      EchelonExtensionEchelonMaxCommonCost: 0,
      EchelonMaxOverloadCost: 0,
      EchelonExtensionMaxOverloadCost: 0,
      EchelonExtensionEchelonInitCommonCost: 0,
      EchelonExtensionCostRegenRatio: 0,
      EchelonOverloadCostRegenRatio: 0,
      EchelonExtensionOverloadCostRegenRatio: 0,
      CheckCheaterMaxUseCostMultiFloorRaid: 0,
      ExcessiveTouchCheckTime: 0.0,
      ExcessiveTouchCheckCount: 0,
      CampaignAlertPopupLevelGap: 0,
      MoveCorrectionSkipRatio: 0,
    }
  }
}
impl ConstCombatExcelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ConstCombatExcel<'b>> {
    let SkillHandCount = self.SkillHandCount;
    let DyingTime = self.DyingTime;
    let BuffIconBlinkTime = self.BuffIconBlinkTime;
    let ShowBufficonEXSkill = self.ShowBufficonEXSkill;
    let ShowBufficonPassiveSkill = self.ShowBufficonPassiveSkill;
    let ShowBufficonExtraPassiveSkill = self.ShowBufficonExtraPassiveSkill;
    let ShowBufficonLeaderSkill = self.ShowBufficonLeaderSkill;
    let ShowBufficonGroundPassiveSkill = self.ShowBufficonGroundPassiveSkill;
    let SuppliesConditionStringId = self.SuppliesConditionStringId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PublicSpeechBubbleOffsetX = self.PublicSpeechBubbleOffsetX;
    let PublicSpeechBubbleOffsetY = self.PublicSpeechBubbleOffsetY;
    let PublicSpeechBubbleOffsetZ = self.PublicSpeechBubbleOffsetZ;
    let ShowRaidListCount = self.ShowRaidListCount;
    let MaxRaidTicketCount = self.MaxRaidTicketCount;
    let MaxRaidBossSkillSlot = self.MaxRaidBossSkillSlot;
    let EngageTimelinePath = self.EngageTimelinePath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EngageWithSupporterTimelinePath = self.EngageWithSupporterTimelinePath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let VictoryTimelinePath = self.VictoryTimelinePath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TimeLimitAlarm = self.TimeLimitAlarm;
    let EchelonMaxCommonCost = self.EchelonMaxCommonCost;
    let EchelonInitCommonCost = self.EchelonInitCommonCost;
    let SkillSlotCoolTime = self.SkillSlotCoolTime;
    let EnemyRegenCost = self.EnemyRegenCost;
    let ChampionRegenCost = self.ChampionRegenCost;
    let PlayerRegenCostDelay = self.PlayerRegenCostDelay;
    let CrowdControlFactor = self.CrowdControlFactor;
    let RaidOpenScenarioId = self.RaidOpenScenarioId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EliminateRaidOpenScenarioId = self.EliminateRaidOpenScenarioId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DefenceConstA = self.DefenceConstA;
    let DefenceConstB = self.DefenceConstB;
    let DefenceConstC = self.DefenceConstC;
    let DefenceConstD = self.DefenceConstD;
    let AccuracyConstA = self.AccuracyConstA;
    let AccuracyConstB = self.AccuracyConstB;
    let AccuracyConstC = self.AccuracyConstC;
    let AccuracyConstD = self.AccuracyConstD;
    let CriticalConstA = self.CriticalConstA;
    let CriticalConstB = self.CriticalConstB;
    let CriticalConstC = self.CriticalConstC;
    let CriticalConstD = self.CriticalConstD;
    let MaxGroupBuffLevel = self.MaxGroupBuffLevel;
    let EmojiDefaultTime = self.EmojiDefaultTime;
    let TimeLineActionRotateSpeed = self.TimeLineActionRotateSpeed;
    let BodyRotateSpeed = self.BodyRotateSpeed;
    let NormalTimeScale = self.NormalTimeScale;
    let FastTimeScale = self.FastTimeScale;
    let BulletTimeScale = self.BulletTimeScale;
    let UIDisplayDelayAfterSkillCutIn = self.UIDisplayDelayAfterSkillCutIn;
    let UseInitialRangeForCoverMove = self.UseInitialRangeForCoverMove;
    let SlowTimeScale = self.SlowTimeScale;
    let AimIKMinDegree = self.AimIKMinDegree;
    let AimIKMaxDegree = self.AimIKMaxDegree;
    let MinimumClearTime = self.MinimumClearTime;
    let MinimumClearLevelGap = self.MinimumClearLevelGap;
    let CheckCheaterMaxUseCostNonArena = self.CheckCheaterMaxUseCostNonArena;
    let CheckCheaterMaxUseCostArena = self.CheckCheaterMaxUseCostArena;
    let AllowedMaxTimeScale = self.AllowedMaxTimeScale;
    let RandomAnimationOutput = self.RandomAnimationOutput;
    let SummonedTeleportDistance = self.SummonedTeleportDistance;
    let ArenaMinimumClearTime = self.ArenaMinimumClearTime;
    let WORLDBOSSBATTLELITTLE = self.WORLDBOSSBATTLELITTLE;
    let WORLDBOSSBATTLEMIDDLE = self.WORLDBOSSBATTLEMIDDLE;
    let WORLDBOSSBATTLEHIGH = self.WORLDBOSSBATTLEHIGH;
    let WORLDBOSSBATTLEVERYHIGH = self.WORLDBOSSBATTLEVERYHIGH;
    let WorldRaidAutoSyncTermSecond = self.WorldRaidAutoSyncTermSecond;
    let WorldRaidBossHpDecreaseTerm = self.WorldRaidBossHpDecreaseTerm;
    let WorldRaidBossParcelReactionDelay = self.WorldRaidBossParcelReactionDelay;
    let RaidRankingJumpMinimumWaitingTime = self.RaidRankingJumpMinimumWaitingTime;
    let EffectTeleportDistance = self.EffectTeleportDistance;
    let AuraExitThresholdMargin = self.AuraExitThresholdMargin;
    let TSAInteractionDamageFactor = self.TSAInteractionDamageFactor;
    let VictoryInteractionRate = self.VictoryInteractionRate;
    let EchelonExtensionEngageTimelinePath = self.EchelonExtensionEngageTimelinePath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EchelonExtensionEngageWithSupporterTimelinePath = self.EchelonExtensionEngageWithSupporterTimelinePath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EchelonExtensionVictoryTimelinePath = self.EchelonExtensionVictoryTimelinePath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EchelonExtensionEchelonMaxCommonCost = self.EchelonExtensionEchelonMaxCommonCost;
    let EchelonMaxOverloadCost = self.EchelonMaxOverloadCost;
    let EchelonExtensionMaxOverloadCost = self.EchelonExtensionMaxOverloadCost;
    let EchelonExtensionEchelonInitCommonCost = self.EchelonExtensionEchelonInitCommonCost;
    let EchelonExtensionCostRegenRatio = self.EchelonExtensionCostRegenRatio;
    let EchelonOverloadCostRegenRatio = self.EchelonOverloadCostRegenRatio;
    let EchelonExtensionOverloadCostRegenRatio = self.EchelonExtensionOverloadCostRegenRatio;
    let CheckCheaterMaxUseCostMultiFloorRaid = self.CheckCheaterMaxUseCostMultiFloorRaid;
    let ExcessiveTouchCheckTime = self.ExcessiveTouchCheckTime;
    let ExcessiveTouchCheckCount = self.ExcessiveTouchCheckCount;
    let CampaignAlertPopupLevelGap = self.CampaignAlertPopupLevelGap;
    let MoveCorrectionSkipRatio = self.MoveCorrectionSkipRatio;
    ConstCombatExcel::create(_fbb, &ConstCombatExcelArgs{
      SkillHandCount,
      DyingTime,
      BuffIconBlinkTime,
      ShowBufficonEXSkill,
      ShowBufficonPassiveSkill,
      ShowBufficonExtraPassiveSkill,
      ShowBufficonLeaderSkill,
      ShowBufficonGroundPassiveSkill,
      SuppliesConditionStringId,
      PublicSpeechBubbleOffsetX,
      PublicSpeechBubbleOffsetY,
      PublicSpeechBubbleOffsetZ,
      ShowRaidListCount,
      MaxRaidTicketCount,
      MaxRaidBossSkillSlot,
      EngageTimelinePath,
      EngageWithSupporterTimelinePath,
      VictoryTimelinePath,
      TimeLimitAlarm,
      EchelonMaxCommonCost,
      EchelonInitCommonCost,
      SkillSlotCoolTime,
      EnemyRegenCost,
      ChampionRegenCost,
      PlayerRegenCostDelay,
      CrowdControlFactor,
      RaidOpenScenarioId,
      EliminateRaidOpenScenarioId,
      DefenceConstA,
      DefenceConstB,
      DefenceConstC,
      DefenceConstD,
      AccuracyConstA,
      AccuracyConstB,
      AccuracyConstC,
      AccuracyConstD,
      CriticalConstA,
      CriticalConstB,
      CriticalConstC,
      CriticalConstD,
      MaxGroupBuffLevel,
      EmojiDefaultTime,
      TimeLineActionRotateSpeed,
      BodyRotateSpeed,
      NormalTimeScale,
      FastTimeScale,
      BulletTimeScale,
      UIDisplayDelayAfterSkillCutIn,
      UseInitialRangeForCoverMove,
      SlowTimeScale,
      AimIKMinDegree,
      AimIKMaxDegree,
      MinimumClearTime,
      MinimumClearLevelGap,
      CheckCheaterMaxUseCostNonArena,
      CheckCheaterMaxUseCostArena,
      AllowedMaxTimeScale,
      RandomAnimationOutput,
      SummonedTeleportDistance,
      ArenaMinimumClearTime,
      WORLDBOSSBATTLELITTLE,
      WORLDBOSSBATTLEMIDDLE,
      WORLDBOSSBATTLEHIGH,
      WORLDBOSSBATTLEVERYHIGH,
      WorldRaidAutoSyncTermSecond,
      WorldRaidBossHpDecreaseTerm,
      WorldRaidBossParcelReactionDelay,
      RaidRankingJumpMinimumWaitingTime,
      EffectTeleportDistance,
      AuraExitThresholdMargin,
      TSAInteractionDamageFactor,
      VictoryInteractionRate,
      EchelonExtensionEngageTimelinePath,
      EchelonExtensionEngageWithSupporterTimelinePath,
      EchelonExtensionVictoryTimelinePath,
      EchelonExtensionEchelonMaxCommonCost,
      EchelonMaxOverloadCost,
      EchelonExtensionMaxOverloadCost,
      EchelonExtensionEchelonInitCommonCost,
      EchelonExtensionCostRegenRatio,
      EchelonOverloadCostRegenRatio,
      EchelonExtensionOverloadCostRegenRatio,
      CheckCheaterMaxUseCostMultiFloorRaid,
      ExcessiveTouchCheckTime,
      ExcessiveTouchCheckCount,
      CampaignAlertPopupLevelGap,
      MoveCorrectionSkipRatio,
    })
  }
}
