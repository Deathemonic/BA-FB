// automatically generated by the FlatBuffers compiler, do not modify
// @generated
#![allow(unused_imports, dead_code)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum TacticalSupportSystemExcelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TacticalSupportSystemExcel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TacticalSupportSystemExcel<'a> {
  type Inner = TacticalSupportSystemExcel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TacticalSupportSystemExcel<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_SUMMONEDTIME: flatbuffers::VOffsetT = 6;
  pub const VT_DEFAULTPERSONALITYID: flatbuffers::VOffsetT = 8;
  pub const VT_CANTARGETING: flatbuffers::VOffsetT = 10;
  pub const VT_CANCOVER: flatbuffers::VOffsetT = 12;
  pub const VT_OBSTACLEUNIQUENAME: flatbuffers::VOffsetT = 14;
  pub const VT_OBSTACLECOVERRANGE: flatbuffers::VOffsetT = 16;
  pub const VT_SUMMONSKILLLGROUPID: flatbuffers::VOffsetT = 18;
  pub const VT_CRASHOBSTACLEOBBWIDTH: flatbuffers::VOffsetT = 20;
  pub const VT_CRASHOBSTACLEOBBHEIGHT: flatbuffers::VOffsetT = 22;
  pub const VT_ISTSSBLOCKEDNODECHECK: flatbuffers::VOffsetT = 24;
  pub const VT_NUMBEROFUSES: flatbuffers::VOffsetT = 26;
  pub const VT_INVENTORYOFFSETX: flatbuffers::VOffsetT = 28;
  pub const VT_INVENTORYOFFSETY: flatbuffers::VOffsetT = 30;
  pub const VT_INVENTORYOFFSETZ: flatbuffers::VOffsetT = 32;
  pub const VT_INTERACTIONCHAR: flatbuffers::VOffsetT = 34;
  pub const VT_CHARACTERINTERACTIONSTARTDELAY: flatbuffers::VOffsetT = 36;
  pub const VT_GETONSTARTEFFECTPATH: flatbuffers::VOffsetT = 38;
  pub const VT_GETONENDEFFECTPATH: flatbuffers::VOffsetT = 40;
  pub const VT_SUMMONERCHARACTERID: flatbuffers::VOffsetT = 42;
  pub const VT_INTERACTIONFRAME: flatbuffers::VOffsetT = 44;
  pub const VT_TSAINTERACTIONADDDURATION: flatbuffers::VOffsetT = 46;
  pub const VT_INTERACTIONSTUDENTEXSKILLGROUPID: flatbuffers::VOffsetT = 48;
  pub const VT_INTERACTIONSKILLCARDTEXTURE: flatbuffers::VOffsetT = 50;
  pub const VT_INTERACTIONSKILLSPINE: flatbuffers::VOffsetT = 52;
  pub const VT_RETREATFRAME: flatbuffers::VOffsetT = 54;
  pub const VT_DESTROYFRAME: flatbuffers::VOffsetT = 56;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TacticalSupportSystemExcel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TacticalSupportSystemExcelArgs<'args>
  ) -> flatbuffers::WIPOffset<TacticalSupportSystemExcel<'bldr>> {
    let mut builder = TacticalSupportSystemExcelBuilder::new(_fbb);
    let key = table_encryption_service::create_key(b"TacticalSupportSystem");
      let x = args.TSAInteractionAddDuration;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_TSAInteractionAddDuration(x);
      let x = args.SummonerCharacterId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_SummonerCharacterId(x);
      let x = args.CharacterInteractionStartDelay;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_CharacterInteractionStartDelay(x);
      let x = args.InteractionChar;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_InteractionChar(x);
      let x = args.CrashObstacleOBBHeight;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_CrashObstacleOBBHeight(x);
      let x = args.CrashObstacleOBBWidth;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_CrashObstacleOBBWidth(x);
      let x = args.ObstacleCoverRange;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_ObstacleCoverRange(x);
      let x = args.DefaultPersonalityId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_DefaultPersonalityId(x);
      let x = args.SummonedTime;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_SummonedTime(x);
      let x = args.Id;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_Id(x);
      let x = args.DestroyFrame;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_DestroyFrame(x);
      let x = args.RetreatFrame;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_RetreatFrame(x);
      if let Some(x) = args.InteractionSkillSpine {
        builder.add_InteractionSkillSpine(x);
      }
      if let Some(x) = args.InteractionSkillCardTexture {
        builder.add_InteractionSkillCardTexture(x);
      }
      if let Some(x) = args.InteractionStudentExSkillGroupId {
        builder.add_InteractionStudentExSkillGroupId(x);
      }
      let x = args.InteractionFrame;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_InteractionFrame(x);
      if let Some(x) = args.GetOnEndEffectPath {
        builder.add_GetOnEndEffectPath(x);
      }
      if let Some(x) = args.GetOnStartEffectPath {
        builder.add_GetOnStartEffectPath(x);
      }
      let x = args.InventoryOffsetZ;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_InventoryOffsetZ(x);
      let x = args.InventoryOffsetY;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_InventoryOffsetY(x);
      let x = args.InventoryOffsetX;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_InventoryOffsetX(x);
      let x = args.NumberOfUses;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_NumberOfUses(x);
      if let Some(x) = args.SummonSkilllGroupId {
        builder.add_SummonSkilllGroupId(x);
      }
      if let Some(x) = args.ObstacleUniqueName {
        builder.add_ObstacleUniqueName(x);
      }
      builder.add_IsTSSBlockedNodeCheck(args.IsTSSBlockedNodeCheck);
      builder.add_CanCover(args.CanCover);
      builder.add_CanTargeting(args.CanTargeting);
    builder.finish()
  }

  pub fn unpack(&self) -> TacticalSupportSystemExcelT {
    let key = table_encryption_service::create_key(b"TacticalSupportSystem");
      let Id = self.Id();
      let SummonedTime = self.SummonedTime();
      let DefaultPersonalityId = self.DefaultPersonalityId();
      let CanTargeting = self.CanTargeting();
      let CanCover = self.CanCover();
    let ObstacleUniqueName = self.ObstacleUniqueName().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let ObstacleCoverRange = self.ObstacleCoverRange();
    let SummonSkilllGroupId = self.SummonSkilllGroupId().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let CrashObstacleOBBWidth = self.CrashObstacleOBBWidth();
      let CrashObstacleOBBHeight = self.CrashObstacleOBBHeight();
      let IsTSSBlockedNodeCheck = self.IsTSSBlockedNodeCheck();
      let NumberOfUses = self.NumberOfUses();
      let InventoryOffsetX = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.InventoryOffsetX(), &key)
      } else {
        self.InventoryOffsetX()
      };
      let InventoryOffsetY = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.InventoryOffsetY(), &key)
      } else {
        self.InventoryOffsetY()
      };
      let InventoryOffsetZ = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.InventoryOffsetZ(), &key)
      } else {
        self.InventoryOffsetZ()
      };
      let InteractionChar = self.InteractionChar();
      let CharacterInteractionStartDelay = self.CharacterInteractionStartDelay();
    let GetOnStartEffectPath = self.GetOnStartEffectPath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let GetOnEndEffectPath = self.GetOnEndEffectPath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let SummonerCharacterId = self.SummonerCharacterId();
      let InteractionFrame = self.InteractionFrame();
      let TSAInteractionAddDuration = self.TSAInteractionAddDuration();
    let InteractionStudentExSkillGroupId = self.InteractionStudentExSkillGroupId().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let InteractionSkillCardTexture = self.InteractionSkillCardTexture().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let InteractionSkillSpine = self.InteractionSkillSpine().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let RetreatFrame = self.RetreatFrame();
      let DestroyFrame = self.DestroyFrame();
    TacticalSupportSystemExcelT {
      Id,
      SummonedTime,
      DefaultPersonalityId,
      CanTargeting,
      CanCover,
      ObstacleUniqueName,
      ObstacleCoverRange,
      SummonSkilllGroupId,
      CrashObstacleOBBWidth,
      CrashObstacleOBBHeight,
      IsTSSBlockedNodeCheck,
      NumberOfUses,
      InventoryOffsetX,
      InventoryOffsetY,
      InventoryOffsetZ,
      InteractionChar,
      CharacterInteractionStartDelay,
      GetOnStartEffectPath,
      GetOnEndEffectPath,
      SummonerCharacterId,
      InteractionFrame,
      TSAInteractionAddDuration,
      InteractionStudentExSkillGroupId,
      InteractionSkillCardTexture,
      InteractionSkillSpine,
      RetreatFrame,
      DestroyFrame,
    }
  }

  #[inline]
  pub fn Id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TacticalSupportSystemExcel::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn SummonedTime(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TacticalSupportSystemExcel::VT_SUMMONEDTIME, Some(0)).unwrap()}
  }
  #[inline]
  pub fn DefaultPersonalityId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TacticalSupportSystemExcel::VT_DEFAULTPERSONALITYID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CanTargeting(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TacticalSupportSystemExcel::VT_CANTARGETING, Some(false)).unwrap()}
  }
  #[inline]
  pub fn CanCover(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TacticalSupportSystemExcel::VT_CANCOVER, Some(false)).unwrap()}
  }
  #[inline]
  pub fn ObstacleUniqueName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TacticalSupportSystemExcel::VT_OBSTACLEUNIQUENAME, None)}
  }
  #[inline]
  pub fn ObstacleCoverRange(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TacticalSupportSystemExcel::VT_OBSTACLECOVERRANGE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn SummonSkilllGroupId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TacticalSupportSystemExcel::VT_SUMMONSKILLLGROUPID, None)}
  }
  #[inline]
  pub fn CrashObstacleOBBWidth(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TacticalSupportSystemExcel::VT_CRASHOBSTACLEOBBWIDTH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CrashObstacleOBBHeight(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TacticalSupportSystemExcel::VT_CRASHOBSTACLEOBBHEIGHT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn IsTSSBlockedNodeCheck(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TacticalSupportSystemExcel::VT_ISTSSBLOCKEDNODECHECK, Some(false)).unwrap()}
  }
  #[inline]
  pub fn NumberOfUses(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TacticalSupportSystemExcel::VT_NUMBEROFUSES, Some(0)).unwrap()}
  }
  #[inline]
  pub fn InventoryOffsetX(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(TacticalSupportSystemExcel::VT_INVENTORYOFFSETX, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn InventoryOffsetY(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(TacticalSupportSystemExcel::VT_INVENTORYOFFSETY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn InventoryOffsetZ(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(TacticalSupportSystemExcel::VT_INVENTORYOFFSETZ, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn InteractionChar(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TacticalSupportSystemExcel::VT_INTERACTIONCHAR, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CharacterInteractionStartDelay(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TacticalSupportSystemExcel::VT_CHARACTERINTERACTIONSTARTDELAY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn GetOnStartEffectPath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TacticalSupportSystemExcel::VT_GETONSTARTEFFECTPATH, None)}
  }
  #[inline]
  pub fn GetOnEndEffectPath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TacticalSupportSystemExcel::VT_GETONENDEFFECTPATH, None)}
  }
  #[inline]
  pub fn SummonerCharacterId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TacticalSupportSystemExcel::VT_SUMMONERCHARACTERID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn InteractionFrame(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TacticalSupportSystemExcel::VT_INTERACTIONFRAME, Some(0)).unwrap()}
  }
  #[inline]
  pub fn TSAInteractionAddDuration(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(TacticalSupportSystemExcel::VT_TSAINTERACTIONADDDURATION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn InteractionStudentExSkillGroupId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TacticalSupportSystemExcel::VT_INTERACTIONSTUDENTEXSKILLGROUPID, None)}
  }
  #[inline]
  pub fn InteractionSkillCardTexture(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TacticalSupportSystemExcel::VT_INTERACTIONSKILLCARDTEXTURE, None)}
  }
  #[inline]
  pub fn InteractionSkillSpine(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TacticalSupportSystemExcel::VT_INTERACTIONSKILLSPINE, None)}
  }
  #[inline]
  pub fn RetreatFrame(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TacticalSupportSystemExcel::VT_RETREATFRAME, Some(0)).unwrap()}
  }
  #[inline]
  pub fn DestroyFrame(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TacticalSupportSystemExcel::VT_DESTROYFRAME, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for TacticalSupportSystemExcel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("Id", Self::VT_ID, false)?
     .visit_field::<i64>("SummonedTime", Self::VT_SUMMONEDTIME, false)?
     .visit_field::<i64>("DefaultPersonalityId", Self::VT_DEFAULTPERSONALITYID, false)?
     .visit_field::<bool>("CanTargeting", Self::VT_CANTARGETING, false)?
     .visit_field::<bool>("CanCover", Self::VT_CANCOVER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ObstacleUniqueName", Self::VT_OBSTACLEUNIQUENAME, false)?
     .visit_field::<i64>("ObstacleCoverRange", Self::VT_OBSTACLECOVERRANGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SummonSkilllGroupId", Self::VT_SUMMONSKILLLGROUPID, false)?
     .visit_field::<i64>("CrashObstacleOBBWidth", Self::VT_CRASHOBSTACLEOBBWIDTH, false)?
     .visit_field::<i64>("CrashObstacleOBBHeight", Self::VT_CRASHOBSTACLEOBBHEIGHT, false)?
     .visit_field::<bool>("IsTSSBlockedNodeCheck", Self::VT_ISTSSBLOCKEDNODECHECK, false)?
     .visit_field::<i32>("NumberOfUses", Self::VT_NUMBEROFUSES, false)?
     .visit_field::<f32>("InventoryOffsetX", Self::VT_INVENTORYOFFSETX, false)?
     .visit_field::<f32>("InventoryOffsetY", Self::VT_INVENTORYOFFSETY, false)?
     .visit_field::<f32>("InventoryOffsetZ", Self::VT_INVENTORYOFFSETZ, false)?
     .visit_field::<i64>("InteractionChar", Self::VT_INTERACTIONCHAR, false)?
     .visit_field::<i64>("CharacterInteractionStartDelay", Self::VT_CHARACTERINTERACTIONSTARTDELAY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("GetOnStartEffectPath", Self::VT_GETONSTARTEFFECTPATH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("GetOnEndEffectPath", Self::VT_GETONENDEFFECTPATH, false)?
     .visit_field::<i64>("SummonerCharacterId", Self::VT_SUMMONERCHARACTERID, false)?
     .visit_field::<i32>("InteractionFrame", Self::VT_INTERACTIONFRAME, false)?
     .visit_field::<i64>("TSAInteractionAddDuration", Self::VT_TSAINTERACTIONADDDURATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("InteractionStudentExSkillGroupId", Self::VT_INTERACTIONSTUDENTEXSKILLGROUPID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("InteractionSkillCardTexture", Self::VT_INTERACTIONSKILLCARDTEXTURE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("InteractionSkillSpine", Self::VT_INTERACTIONSKILLSPINE, false)?
     .visit_field::<i32>("RetreatFrame", Self::VT_RETREATFRAME, false)?
     .visit_field::<i32>("DestroyFrame", Self::VT_DESTROYFRAME, false)?
     .finish();
    Ok(())
  }
}
pub struct TacticalSupportSystemExcelArgs<'a> {
    pub Id: i64,
    pub SummonedTime: i64,
    pub DefaultPersonalityId: i64,
    pub CanTargeting: bool,
    pub CanCover: bool,
    pub ObstacleUniqueName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ObstacleCoverRange: i64,
    pub SummonSkilllGroupId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CrashObstacleOBBWidth: i64,
    pub CrashObstacleOBBHeight: i64,
    pub IsTSSBlockedNodeCheck: bool,
    pub NumberOfUses: i32,
    pub InventoryOffsetX: f32,
    pub InventoryOffsetY: f32,
    pub InventoryOffsetZ: f32,
    pub InteractionChar: i64,
    pub CharacterInteractionStartDelay: i64,
    pub GetOnStartEffectPath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub GetOnEndEffectPath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SummonerCharacterId: i64,
    pub InteractionFrame: i32,
    pub TSAInteractionAddDuration: i64,
    pub InteractionStudentExSkillGroupId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub InteractionSkillCardTexture: Option<flatbuffers::WIPOffset<&'a str>>,
    pub InteractionSkillSpine: Option<flatbuffers::WIPOffset<&'a str>>,
    pub RetreatFrame: i32,
    pub DestroyFrame: i32,
}
impl<'a> Default for TacticalSupportSystemExcelArgs<'a> {
  #[inline]
  fn default() -> Self {
    TacticalSupportSystemExcelArgs {
      Id: 0,
      SummonedTime: 0,
      DefaultPersonalityId: 0,
      CanTargeting: false,
      CanCover: false,
      ObstacleUniqueName: None,
      ObstacleCoverRange: 0,
      SummonSkilllGroupId: None,
      CrashObstacleOBBWidth: 0,
      CrashObstacleOBBHeight: 0,
      IsTSSBlockedNodeCheck: false,
      NumberOfUses: 0,
      InventoryOffsetX: 0.0,
      InventoryOffsetY: 0.0,
      InventoryOffsetZ: 0.0,
      InteractionChar: 0,
      CharacterInteractionStartDelay: 0,
      GetOnStartEffectPath: None,
      GetOnEndEffectPath: None,
      SummonerCharacterId: 0,
      InteractionFrame: 0,
      TSAInteractionAddDuration: 0,
      InteractionStudentExSkillGroupId: None,
      InteractionSkillCardTexture: None,
      InteractionSkillSpine: None,
      RetreatFrame: 0,
      DestroyFrame: 0,
    }
  }
}

impl Serialize for TacticalSupportSystemExcel<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("TacticalSupportSystemExcel", 27)?;
      s.serialize_field("Id", &self.Id())?;
      s.serialize_field("SummonedTime", &self.SummonedTime())?;
      s.serialize_field("DefaultPersonalityId", &self.DefaultPersonalityId())?;
      s.serialize_field("CanTargeting", &self.CanTargeting())?;
      s.serialize_field("CanCover", &self.CanCover())?;
      if let Some(f) = self.ObstacleUniqueName() {
        s.serialize_field("ObstacleUniqueName", &f)?;
      } else {
        s.skip_field("ObstacleUniqueName")?;
      }
      s.serialize_field("ObstacleCoverRange", &self.ObstacleCoverRange())?;
      if let Some(f) = self.SummonSkilllGroupId() {
        s.serialize_field("SummonSkilllGroupId", &f)?;
      } else {
        s.skip_field("SummonSkilllGroupId")?;
      }
      s.serialize_field("CrashObstacleOBBWidth", &self.CrashObstacleOBBWidth())?;
      s.serialize_field("CrashObstacleOBBHeight", &self.CrashObstacleOBBHeight())?;
      s.serialize_field("IsTSSBlockedNodeCheck", &self.IsTSSBlockedNodeCheck())?;
      s.serialize_field("NumberOfUses", &self.NumberOfUses())?;
      s.serialize_field("InventoryOffsetX", &self.InventoryOffsetX())?;
      s.serialize_field("InventoryOffsetY", &self.InventoryOffsetY())?;
      s.serialize_field("InventoryOffsetZ", &self.InventoryOffsetZ())?;
      s.serialize_field("InteractionChar", &self.InteractionChar())?;
      s.serialize_field("CharacterInteractionStartDelay", &self.CharacterInteractionStartDelay())?;
      if let Some(f) = self.GetOnStartEffectPath() {
        s.serialize_field("GetOnStartEffectPath", &f)?;
      } else {
        s.skip_field("GetOnStartEffectPath")?;
      }
      if let Some(f) = self.GetOnEndEffectPath() {
        s.serialize_field("GetOnEndEffectPath", &f)?;
      } else {
        s.skip_field("GetOnEndEffectPath")?;
      }
      s.serialize_field("SummonerCharacterId", &self.SummonerCharacterId())?;
      s.serialize_field("InteractionFrame", &self.InteractionFrame())?;
      s.serialize_field("TSAInteractionAddDuration", &self.TSAInteractionAddDuration())?;
      if let Some(f) = self.InteractionStudentExSkillGroupId() {
        s.serialize_field("InteractionStudentExSkillGroupId", &f)?;
      } else {
        s.skip_field("InteractionStudentExSkillGroupId")?;
      }
      if let Some(f) = self.InteractionSkillCardTexture() {
        s.serialize_field("InteractionSkillCardTexture", &f)?;
      } else {
        s.skip_field("InteractionSkillCardTexture")?;
      }
      if let Some(f) = self.InteractionSkillSpine() {
        s.serialize_field("InteractionSkillSpine", &f)?;
      } else {
        s.skip_field("InteractionSkillSpine")?;
      }
      s.serialize_field("RetreatFrame", &self.RetreatFrame())?;
      s.serialize_field("DestroyFrame", &self.DestroyFrame())?;
    s.end()
  }
}

pub struct TacticalSupportSystemExcelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TacticalSupportSystemExcelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_Id(&mut self, Id: i64) {
    self.fbb_.push_slot::<i64>(TacticalSupportSystemExcel::VT_ID, Id, 0);
  }
  #[inline]
  pub fn add_SummonedTime(&mut self, SummonedTime: i64) {
    self.fbb_.push_slot::<i64>(TacticalSupportSystemExcel::VT_SUMMONEDTIME, SummonedTime, 0);
  }
  #[inline]
  pub fn add_DefaultPersonalityId(&mut self, DefaultPersonalityId: i64) {
    self.fbb_.push_slot::<i64>(TacticalSupportSystemExcel::VT_DEFAULTPERSONALITYID, DefaultPersonalityId, 0);
  }
  #[inline]
  pub fn add_CanTargeting(&mut self, CanTargeting: bool) {
    self.fbb_.push_slot::<bool>(TacticalSupportSystemExcel::VT_CANTARGETING, CanTargeting, false);
  }
  #[inline]
  pub fn add_CanCover(&mut self, CanCover: bool) {
    self.fbb_.push_slot::<bool>(TacticalSupportSystemExcel::VT_CANCOVER, CanCover, false);
  }
  #[inline]
  pub fn add_ObstacleUniqueName(&mut self, ObstacleUniqueName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TacticalSupportSystemExcel::VT_OBSTACLEUNIQUENAME, ObstacleUniqueName);
  }
  #[inline]
  pub fn add_ObstacleCoverRange(&mut self, ObstacleCoverRange: i64) {
    self.fbb_.push_slot::<i64>(TacticalSupportSystemExcel::VT_OBSTACLECOVERRANGE, ObstacleCoverRange, 0);
  }
  #[inline]
  pub fn add_SummonSkilllGroupId(&mut self, SummonSkilllGroupId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TacticalSupportSystemExcel::VT_SUMMONSKILLLGROUPID, SummonSkilllGroupId);
  }
  #[inline]
  pub fn add_CrashObstacleOBBWidth(&mut self, CrashObstacleOBBWidth: i64) {
    self.fbb_.push_slot::<i64>(TacticalSupportSystemExcel::VT_CRASHOBSTACLEOBBWIDTH, CrashObstacleOBBWidth, 0);
  }
  #[inline]
  pub fn add_CrashObstacleOBBHeight(&mut self, CrashObstacleOBBHeight: i64) {
    self.fbb_.push_slot::<i64>(TacticalSupportSystemExcel::VT_CRASHOBSTACLEOBBHEIGHT, CrashObstacleOBBHeight, 0);
  }
  #[inline]
  pub fn add_IsTSSBlockedNodeCheck(&mut self, IsTSSBlockedNodeCheck: bool) {
    self.fbb_.push_slot::<bool>(TacticalSupportSystemExcel::VT_ISTSSBLOCKEDNODECHECK, IsTSSBlockedNodeCheck, false);
  }
  #[inline]
  pub fn add_NumberOfUses(&mut self, NumberOfUses: i32) {
    self.fbb_.push_slot::<i32>(TacticalSupportSystemExcel::VT_NUMBEROFUSES, NumberOfUses, 0);
  }
  #[inline]
  pub fn add_InventoryOffsetX(&mut self, InventoryOffsetX: f32) {
    self.fbb_.push_slot::<f32>(TacticalSupportSystemExcel::VT_INVENTORYOFFSETX, InventoryOffsetX, 0.0);
  }
  #[inline]
  pub fn add_InventoryOffsetY(&mut self, InventoryOffsetY: f32) {
    self.fbb_.push_slot::<f32>(TacticalSupportSystemExcel::VT_INVENTORYOFFSETY, InventoryOffsetY, 0.0);
  }
  #[inline]
  pub fn add_InventoryOffsetZ(&mut self, InventoryOffsetZ: f32) {
    self.fbb_.push_slot::<f32>(TacticalSupportSystemExcel::VT_INVENTORYOFFSETZ, InventoryOffsetZ, 0.0);
  }
  #[inline]
  pub fn add_InteractionChar(&mut self, InteractionChar: i64) {
    self.fbb_.push_slot::<i64>(TacticalSupportSystemExcel::VT_INTERACTIONCHAR, InteractionChar, 0);
  }
  #[inline]
  pub fn add_CharacterInteractionStartDelay(&mut self, CharacterInteractionStartDelay: i64) {
    self.fbb_.push_slot::<i64>(TacticalSupportSystemExcel::VT_CHARACTERINTERACTIONSTARTDELAY, CharacterInteractionStartDelay, 0);
  }
  #[inline]
  pub fn add_GetOnStartEffectPath(&mut self, GetOnStartEffectPath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TacticalSupportSystemExcel::VT_GETONSTARTEFFECTPATH, GetOnStartEffectPath);
  }
  #[inline]
  pub fn add_GetOnEndEffectPath(&mut self, GetOnEndEffectPath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TacticalSupportSystemExcel::VT_GETONENDEFFECTPATH, GetOnEndEffectPath);
  }
  #[inline]
  pub fn add_SummonerCharacterId(&mut self, SummonerCharacterId: i64) {
    self.fbb_.push_slot::<i64>(TacticalSupportSystemExcel::VT_SUMMONERCHARACTERID, SummonerCharacterId, 0);
  }
  #[inline]
  pub fn add_InteractionFrame(&mut self, InteractionFrame: i32) {
    self.fbb_.push_slot::<i32>(TacticalSupportSystemExcel::VT_INTERACTIONFRAME, InteractionFrame, 0);
  }
  #[inline]
  pub fn add_TSAInteractionAddDuration(&mut self, TSAInteractionAddDuration: i64) {
    self.fbb_.push_slot::<i64>(TacticalSupportSystemExcel::VT_TSAINTERACTIONADDDURATION, TSAInteractionAddDuration, 0);
  }
  #[inline]
  pub fn add_InteractionStudentExSkillGroupId(&mut self, InteractionStudentExSkillGroupId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TacticalSupportSystemExcel::VT_INTERACTIONSTUDENTEXSKILLGROUPID, InteractionStudentExSkillGroupId);
  }
  #[inline]
  pub fn add_InteractionSkillCardTexture(&mut self, InteractionSkillCardTexture: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TacticalSupportSystemExcel::VT_INTERACTIONSKILLCARDTEXTURE, InteractionSkillCardTexture);
  }
  #[inline]
  pub fn add_InteractionSkillSpine(&mut self, InteractionSkillSpine: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TacticalSupportSystemExcel::VT_INTERACTIONSKILLSPINE, InteractionSkillSpine);
  }
  #[inline]
  pub fn add_RetreatFrame(&mut self, RetreatFrame: i32) {
    self.fbb_.push_slot::<i32>(TacticalSupportSystemExcel::VT_RETREATFRAME, RetreatFrame, 0);
  }
  #[inline]
  pub fn add_DestroyFrame(&mut self, DestroyFrame: i32) {
    self.fbb_.push_slot::<i32>(TacticalSupportSystemExcel::VT_DESTROYFRAME, DestroyFrame, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TacticalSupportSystemExcelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TacticalSupportSystemExcelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TacticalSupportSystemExcel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TacticalSupportSystemExcel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TacticalSupportSystemExcel");
      ds.field("Id", &self.Id());
      ds.field("SummonedTime", &self.SummonedTime());
      ds.field("DefaultPersonalityId", &self.DefaultPersonalityId());
      ds.field("CanTargeting", &self.CanTargeting());
      ds.field("CanCover", &self.CanCover());
      ds.field("ObstacleUniqueName", &self.ObstacleUniqueName());
      ds.field("ObstacleCoverRange", &self.ObstacleCoverRange());
      ds.field("SummonSkilllGroupId", &self.SummonSkilllGroupId());
      ds.field("CrashObstacleOBBWidth", &self.CrashObstacleOBBWidth());
      ds.field("CrashObstacleOBBHeight", &self.CrashObstacleOBBHeight());
      ds.field("IsTSSBlockedNodeCheck", &self.IsTSSBlockedNodeCheck());
      ds.field("NumberOfUses", &self.NumberOfUses());
      ds.field("InventoryOffsetX", &self.InventoryOffsetX());
      ds.field("InventoryOffsetY", &self.InventoryOffsetY());
      ds.field("InventoryOffsetZ", &self.InventoryOffsetZ());
      ds.field("InteractionChar", &self.InteractionChar());
      ds.field("CharacterInteractionStartDelay", &self.CharacterInteractionStartDelay());
      ds.field("GetOnStartEffectPath", &self.GetOnStartEffectPath());
      ds.field("GetOnEndEffectPath", &self.GetOnEndEffectPath());
      ds.field("SummonerCharacterId", &self.SummonerCharacterId());
      ds.field("InteractionFrame", &self.InteractionFrame());
      ds.field("TSAInteractionAddDuration", &self.TSAInteractionAddDuration());
      ds.field("InteractionStudentExSkillGroupId", &self.InteractionStudentExSkillGroupId());
      ds.field("InteractionSkillCardTexture", &self.InteractionSkillCardTexture());
      ds.field("InteractionSkillSpine", &self.InteractionSkillSpine());
      ds.field("RetreatFrame", &self.RetreatFrame());
      ds.field("DestroyFrame", &self.DestroyFrame());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct TacticalSupportSystemExcelT {
  pub Id: i64,
  pub SummonedTime: i64,
  pub DefaultPersonalityId: i64,
  pub CanTargeting: bool,
  pub CanCover: bool,
  pub ObstacleUniqueName: Option<String>,
  pub ObstacleCoverRange: i64,
  pub SummonSkilllGroupId: Option<String>,
  pub CrashObstacleOBBWidth: i64,
  pub CrashObstacleOBBHeight: i64,
  pub IsTSSBlockedNodeCheck: bool,
  pub NumberOfUses: i32,
  pub InventoryOffsetX: f32,
  pub InventoryOffsetY: f32,
  pub InventoryOffsetZ: f32,
  pub InteractionChar: i64,
  pub CharacterInteractionStartDelay: i64,
  pub GetOnStartEffectPath: Option<String>,
  pub GetOnEndEffectPath: Option<String>,
  pub SummonerCharacterId: i64,
  pub InteractionFrame: i32,
  pub TSAInteractionAddDuration: i64,
  pub InteractionStudentExSkillGroupId: Option<String>,
  pub InteractionSkillCardTexture: Option<String>,
  pub InteractionSkillSpine: Option<String>,
  pub RetreatFrame: i32,
  pub DestroyFrame: i32,
}
impl Default for TacticalSupportSystemExcelT {
  fn default() -> Self {
    Self {
      Id: 0,
      SummonedTime: 0,
      DefaultPersonalityId: 0,
      CanTargeting: false,
      CanCover: false,
      ObstacleUniqueName: None,
      ObstacleCoverRange: 0,
      SummonSkilllGroupId: None,
      CrashObstacleOBBWidth: 0,
      CrashObstacleOBBHeight: 0,
      IsTSSBlockedNodeCheck: false,
      NumberOfUses: 0,
      InventoryOffsetX: 0.0,
      InventoryOffsetY: 0.0,
      InventoryOffsetZ: 0.0,
      InteractionChar: 0,
      CharacterInteractionStartDelay: 0,
      GetOnStartEffectPath: None,
      GetOnEndEffectPath: None,
      SummonerCharacterId: 0,
      InteractionFrame: 0,
      TSAInteractionAddDuration: 0,
      InteractionStudentExSkillGroupId: None,
      InteractionSkillCardTexture: None,
      InteractionSkillSpine: None,
      RetreatFrame: 0,
      DestroyFrame: 0,
    }
  }
}
impl TacticalSupportSystemExcelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<TacticalSupportSystemExcel<'b>> {
    let Id = self.Id;
    let SummonedTime = self.SummonedTime;
    let DefaultPersonalityId = self.DefaultPersonalityId;
    let CanTargeting = self.CanTargeting;
    let CanCover = self.CanCover;
    let ObstacleUniqueName = self.ObstacleUniqueName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ObstacleCoverRange = self.ObstacleCoverRange;
    let SummonSkilllGroupId = self.SummonSkilllGroupId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CrashObstacleOBBWidth = self.CrashObstacleOBBWidth;
    let CrashObstacleOBBHeight = self.CrashObstacleOBBHeight;
    let IsTSSBlockedNodeCheck = self.IsTSSBlockedNodeCheck;
    let NumberOfUses = self.NumberOfUses;
    let InventoryOffsetX = self.InventoryOffsetX;
    let InventoryOffsetY = self.InventoryOffsetY;
    let InventoryOffsetZ = self.InventoryOffsetZ;
    let InteractionChar = self.InteractionChar;
    let CharacterInteractionStartDelay = self.CharacterInteractionStartDelay;
    let GetOnStartEffectPath = self.GetOnStartEffectPath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let GetOnEndEffectPath = self.GetOnEndEffectPath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SummonerCharacterId = self.SummonerCharacterId;
    let InteractionFrame = self.InteractionFrame;
    let TSAInteractionAddDuration = self.TSAInteractionAddDuration;
    let InteractionStudentExSkillGroupId = self.InteractionStudentExSkillGroupId.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let InteractionSkillCardTexture = self.InteractionSkillCardTexture.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let InteractionSkillSpine = self.InteractionSkillSpine.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let RetreatFrame = self.RetreatFrame;
    let DestroyFrame = self.DestroyFrame;
    TacticalSupportSystemExcel::create(_fbb, &TacticalSupportSystemExcelArgs{
      Id,
      SummonedTime,
      DefaultPersonalityId,
      CanTargeting,
      CanCover,
      ObstacleUniqueName,
      ObstacleCoverRange,
      SummonSkilllGroupId,
      CrashObstacleOBBWidth,
      CrashObstacleOBBHeight,
      IsTSSBlockedNodeCheck,
      NumberOfUses,
      InventoryOffsetX,
      InventoryOffsetY,
      InventoryOffsetZ,
      InteractionChar,
      CharacterInteractionStartDelay,
      GetOnStartEffectPath,
      GetOnEndEffectPath,
      SummonerCharacterId,
      InteractionFrame,
      TSAInteractionAddDuration,
      InteractionStudentExSkillGroupId,
      InteractionSkillCardTexture,
      InteractionSkillSpine,
      RetreatFrame,
      DestroyFrame,
    })
  }
}
