// automatically generated by the FlatBuffers compiler, do not modify
// @generated
#![allow(unused_imports, dead_code)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum ScenarioModeExcelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ScenarioModeExcel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ScenarioModeExcel<'a> {
  type Inner = ScenarioModeExcel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ScenarioModeExcel<'a> {
  pub const VT_MODEID: flatbuffers::VOffsetT = 4;
  pub const VT_MODETYPE: flatbuffers::VOffsetT = 6;
  pub const VT_SUBTYPE: flatbuffers::VOffsetT = 8;
  pub const VT_VOLUMEID: flatbuffers::VOffsetT = 10;
  pub const VT_CHAPTERID: flatbuffers::VOffsetT = 12;
  pub const VT_EPISODEID: flatbuffers::VOffsetT = 14;
  pub const VT_EXPOSEDTIME: flatbuffers::VOffsetT = 16;
  pub const VT_HIDE: flatbuffers::VOffsetT = 18;
  pub const VT_OPEN: flatbuffers::VOffsetT = 20;
  pub const VT_ISCONTINUE: flatbuffers::VOffsetT = 22;
  pub const VT_EPISODECONTINUEMODEID: flatbuffers::VOffsetT = 24;
  pub const VT_FRONTSCENARIOGROUPID: flatbuffers::VOffsetT = 26;
  pub const VT_STRATEGYID: flatbuffers::VOffsetT = 28;
  pub const VT_GROUNDID: flatbuffers::VOffsetT = 30;
  pub const VT_ISDEFEATBATTLE: flatbuffers::VOffsetT = 32;
  pub const VT_BATTLEDURATION: flatbuffers::VOffsetT = 34;
  pub const VT_BACKSCENARIOGROUPID: flatbuffers::VOffsetT = 36;
  pub const VT_CLEAREDMODEID: flatbuffers::VOffsetT = 38;
  pub const VT_SCENARIOMODEREWARDID: flatbuffers::VOffsetT = 40;
  pub const VT_ISSCENARIOSPECIALREWARD: flatbuffers::VOffsetT = 42;
  pub const VT_ACCOUNTLEVELLIMIT: flatbuffers::VOffsetT = 44;
  pub const VT_CLEAREDSTAGEID: flatbuffers::VOffsetT = 46;
  pub const VT_NEEDCLUB: flatbuffers::VOffsetT = 48;
  pub const VT_NEEDCLUBSTUDENTCOUNT: flatbuffers::VOffsetT = 50;
  pub const VT_EVENTCONTENTID: flatbuffers::VOffsetT = 52;
  pub const VT_EVENTCONTENTTYPE: flatbuffers::VOffsetT = 54;
  pub const VT_EVENTCONTENTCONDITION: flatbuffers::VOffsetT = 56;
  pub const VT_EVENTCONTENTCONDITIONGROUP: flatbuffers::VOffsetT = 58;
  pub const VT_MAPDIFFICULTY: flatbuffers::VOffsetT = 60;
  pub const VT_STEPINDEX: flatbuffers::VOffsetT = 62;
  pub const VT_RECOMMENDLEVEL: flatbuffers::VOffsetT = 64;
  pub const VT_EVENTICONPARCELPATH: flatbuffers::VOffsetT = 66;
  pub const VT_EVENTBANNERTITLE: flatbuffers::VOffsetT = 68;
  pub const VT_LOF: flatbuffers::VOffsetT = 70;
  pub const VT_STAGETOPOGRAPHY: flatbuffers::VOffsetT = 72;
  pub const VT_FIXEDECHELONID: flatbuffers::VOffsetT = 74;
  pub const VT_COMPLETEREPORTEVENTNAME: flatbuffers::VOffsetT = 76;
  pub const VT_ECHELONEXTENSIONTYPE: flatbuffers::VOffsetT = 78;
  pub const VT_COLLECTIONGROUPID: flatbuffers::VOffsetT = 80;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ScenarioModeExcel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ScenarioModeExcelArgs<'args>
  ) -> flatbuffers::WIPOffset<ScenarioModeExcel<'bldr>> {
    let mut builder = ScenarioModeExcelBuilder::new(_fbb);
    let key = table_encryption_service::create_key(b"ScenarioMode");
      let x = args.CollectionGroupId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_CollectionGroupId(x);
      let x = args.FixedEchelonId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_FixedEchelonId(x);
      let x = args.EventContentConditionGroup;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_EventContentConditionGroup(x);
      let x = args.EventContentCondition;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_EventContentCondition(x);
      let x = args.EventContentId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_EventContentId(x);
      let x = args.ClearedStageId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_ClearedStageId(x);
      let x = args.AccountLevelLimit;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_AccountLevelLimit(x);
      let x = args.ScenarioModeRewardId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_ScenarioModeRewardId(x);
      let x = args.BattleDuration;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_BattleDuration(x);
      let x = args.GroundId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_GroundId(x);
      let x = args.StrategyId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_StrategyId(x);
      let x = args.EpisodeContinueModeId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_EpisodeContinueModeId(x);
      let x = args.EpisodeId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_EpisodeId(x);
      let x = args.ChapterId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_ChapterId(x);
      let x = args.VolumeId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_VolumeId(x);
      let x = args.ModeId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_ModeId(x);
      let x = args.EchelonExtensionType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_EchelonExtensionType(x);
      if let Some(x) = args.CompleteReportEventName {
        builder.add_CompleteReportEventName(x);
      }
      let x = args.StageTopography;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_StageTopography(x);
      let x = args.EventBannerTitle;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_uint(x, &key) } else { x };
      builder.add_EventBannerTitle(x);
      if let Some(x) = args.EventIconParcelPath {
        builder.add_EventIconParcelPath(x);
      }
      let x = args.RecommendLevel;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_RecommendLevel(x);
      let x = args.StepIndex;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_StepIndex(x);
      let x = args.MapDifficulty;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_MapDifficulty(x);
      let x = args.EventContentType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_EventContentType(x);
      let x = args.NeedClubStudentCount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_NeedClubStudentCount(x);
      let x = args.NeedClub;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_NeedClub(x);
      if let Some(x) = args.ClearedModeId {
        builder.add_ClearedModeId(x);
      }
      if let Some(x) = args.BackScenarioGroupId {
        builder.add_BackScenarioGroupId(x);
      }
      if let Some(x) = args.FrontScenarioGroupId {
        builder.add_FrontScenarioGroupId(x);
      }
      if let Some(x) = args.ExposedTime {
        builder.add_ExposedTime(x);
      }
      let x = args.SubType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_SubType(x);
      let x = args.ModeType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_ModeType(x);
      builder.add_lof(args.lof);
      builder.add_IsScenarioSpecialReward(args.IsScenarioSpecialReward);
      builder.add_IsDefeatBattle(args.IsDefeatBattle);
      builder.add_IsContinue(args.IsContinue);
      builder.add_Open(args.Open);
      builder.add_Hide(args.Hide);
    builder.finish()
  }

  pub fn unpack(&self) -> ScenarioModeExcelT {
    let key = table_encryption_service::create_key(b"ScenarioMode");
      let ModeId = self.ModeId();
      let ModeType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.ModeType(), &key)
      } else {
        self.ModeType()
      };
      let SubType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.SubType(), &key)
      } else {
        self.SubType()
      };
      let VolumeId = self.VolumeId();
      let ChapterId = self.ChapterId();
      let EpisodeId = self.EpisodeId();
    let ExposedTime = self.ExposedTime().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let Hide = self.Hide();
      let Open = self.Open();
      let IsContinue = self.IsContinue();
      let EpisodeContinueModeId = self.EpisodeContinueModeId();
    let FrontScenarioGroupId = self.FrontScenarioGroupId().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_long(*val, &key) } else { *val }).collect()
    });
      let StrategyId = self.StrategyId();
      let GroundId = self.GroundId();
      let IsDefeatBattle = self.IsDefeatBattle();
      let BattleDuration = self.BattleDuration();
    let BackScenarioGroupId = self.BackScenarioGroupId().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_long(*val, &key) } else { *val }).collect()
    });
    let ClearedModeId = self.ClearedModeId().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_long(*val, &key) } else { *val }).collect()
    });
      let ScenarioModeRewardId = self.ScenarioModeRewardId();
      let IsScenarioSpecialReward = self.IsScenarioSpecialReward();
      let AccountLevelLimit = self.AccountLevelLimit();
      let ClearedStageId = self.ClearedStageId();
      let NeedClub = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.NeedClub(), &key)
      } else {
        self.NeedClub()
      };
      let NeedClubStudentCount = self.NeedClubStudentCount();
      let EventContentId = self.EventContentId();
      let EventContentType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.EventContentType(), &key)
      } else {
        self.EventContentType()
      };
      let EventContentCondition = self.EventContentCondition();
      let EventContentConditionGroup = self.EventContentConditionGroup();
      let MapDifficulty = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.MapDifficulty(), &key)
      } else {
        self.MapDifficulty()
      };
      let StepIndex = self.StepIndex();
      let RecommendLevel = self.RecommendLevel();
    let EventIconParcelPath = self.EventIconParcelPath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let EventBannerTitle = self.EventBannerTitle();
      let lof = self.lof();
      let StageTopography = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.StageTopography(), &key)
      } else {
        self.StageTopography()
      };
      let FixedEchelonId = self.FixedEchelonId();
    let CompleteReportEventName = self.CompleteReportEventName().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let EchelonExtensionType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.EchelonExtensionType(), &key)
      } else {
        self.EchelonExtensionType()
      };
      let CollectionGroupId = self.CollectionGroupId();
    ScenarioModeExcelT {
      ModeId,
      ModeType,
      SubType,
      VolumeId,
      ChapterId,
      EpisodeId,
      ExposedTime,
      Hide,
      Open,
      IsContinue,
      EpisodeContinueModeId,
      FrontScenarioGroupId,
      StrategyId,
      GroundId,
      IsDefeatBattle,
      BattleDuration,
      BackScenarioGroupId,
      ClearedModeId,
      ScenarioModeRewardId,
      IsScenarioSpecialReward,
      AccountLevelLimit,
      ClearedStageId,
      NeedClub,
      NeedClubStudentCount,
      EventContentId,
      EventContentType,
      EventContentCondition,
      EventContentConditionGroup,
      MapDifficulty,
      StepIndex,
      RecommendLevel,
      EventIconParcelPath,
      EventBannerTitle,
      lof,
      StageTopography,
      FixedEchelonId,
      CompleteReportEventName,
      EchelonExtensionType,
      CollectionGroupId,
    }
  }

  #[inline]
  pub fn ModeId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ScenarioModeExcel::VT_MODEID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ModeType(&self) -> ScenarioModeTypes {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ScenarioModeTypes>(ScenarioModeExcel::VT_MODETYPE, Some(ScenarioModeTypes::None)).unwrap()}
  }
  #[inline]
  pub fn SubType(&self) -> ScenarioModeSubTypes {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ScenarioModeSubTypes>(ScenarioModeExcel::VT_SUBTYPE, Some(ScenarioModeSubTypes::None)).unwrap()}
  }
  #[inline]
  pub fn VolumeId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ScenarioModeExcel::VT_VOLUMEID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ChapterId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ScenarioModeExcel::VT_CHAPTERID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EpisodeId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ScenarioModeExcel::VT_EPISODEID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ExposedTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ScenarioModeExcel::VT_EXPOSEDTIME, None)}
  }
  #[inline]
  pub fn Hide(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ScenarioModeExcel::VT_HIDE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn Open(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ScenarioModeExcel::VT_OPEN, Some(false)).unwrap()}
  }
  #[inline]
  pub fn IsContinue(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ScenarioModeExcel::VT_ISCONTINUE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn EpisodeContinueModeId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ScenarioModeExcel::VT_EPISODECONTINUEMODEID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn FrontScenarioGroupId(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(ScenarioModeExcel::VT_FRONTSCENARIOGROUPID, None)}
  }
  #[inline]
  pub fn StrategyId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ScenarioModeExcel::VT_STRATEGYID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn GroundId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ScenarioModeExcel::VT_GROUNDID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn IsDefeatBattle(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ScenarioModeExcel::VT_ISDEFEATBATTLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn BattleDuration(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ScenarioModeExcel::VT_BATTLEDURATION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn BackScenarioGroupId(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(ScenarioModeExcel::VT_BACKSCENARIOGROUPID, None)}
  }
  #[inline]
  pub fn ClearedModeId(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(ScenarioModeExcel::VT_CLEAREDMODEID, None)}
  }
  #[inline]
  pub fn ScenarioModeRewardId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ScenarioModeExcel::VT_SCENARIOMODEREWARDID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn IsScenarioSpecialReward(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ScenarioModeExcel::VT_ISSCENARIOSPECIALREWARD, Some(false)).unwrap()}
  }
  #[inline]
  pub fn AccountLevelLimit(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ScenarioModeExcel::VT_ACCOUNTLEVELLIMIT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ClearedStageId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ScenarioModeExcel::VT_CLEAREDSTAGEID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn NeedClub(&self) -> Club {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Club>(ScenarioModeExcel::VT_NEEDCLUB, Some(Club::None)).unwrap()}
  }
  #[inline]
  pub fn NeedClubStudentCount(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ScenarioModeExcel::VT_NEEDCLUBSTUDENTCOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EventContentId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ScenarioModeExcel::VT_EVENTCONTENTID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EventContentType(&self) -> EventContentType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<EventContentType>(ScenarioModeExcel::VT_EVENTCONTENTTYPE, Some(EventContentType::Stage)).unwrap()}
  }
  #[inline]
  pub fn EventContentCondition(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ScenarioModeExcel::VT_EVENTCONTENTCONDITION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EventContentConditionGroup(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ScenarioModeExcel::VT_EVENTCONTENTCONDITIONGROUP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn MapDifficulty(&self) -> StageDifficulty {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<StageDifficulty>(ScenarioModeExcel::VT_MAPDIFFICULTY, Some(StageDifficulty::None)).unwrap()}
  }
  #[inline]
  pub fn StepIndex(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ScenarioModeExcel::VT_STEPINDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn RecommendLevel(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ScenarioModeExcel::VT_RECOMMENDLEVEL, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EventIconParcelPath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ScenarioModeExcel::VT_EVENTICONPARCELPATH, None)}
  }
  #[inline]
  pub fn EventBannerTitle(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ScenarioModeExcel::VT_EVENTBANNERTITLE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn lof(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ScenarioModeExcel::VT_LOF, Some(false)).unwrap()}
  }
  #[inline]
  pub fn StageTopography(&self) -> StageTopography {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<StageTopography>(ScenarioModeExcel::VT_STAGETOPOGRAPHY, Some(StageTopography::Street)).unwrap()}
  }
  #[inline]
  pub fn FixedEchelonId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ScenarioModeExcel::VT_FIXEDECHELONID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CompleteReportEventName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ScenarioModeExcel::VT_COMPLETEREPORTEVENTNAME, None)}
  }
  #[inline]
  pub fn EchelonExtensionType(&self) -> EchelonExtensionType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<EchelonExtensionType>(ScenarioModeExcel::VT_ECHELONEXTENSIONTYPE, Some(EchelonExtensionType::Base)).unwrap()}
  }
  #[inline]
  pub fn CollectionGroupId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ScenarioModeExcel::VT_COLLECTIONGROUPID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ScenarioModeExcel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("ModeId", Self::VT_MODEID, false)?
     .visit_field::<ScenarioModeTypes>("ModeType", Self::VT_MODETYPE, false)?
     .visit_field::<ScenarioModeSubTypes>("SubType", Self::VT_SUBTYPE, false)?
     .visit_field::<i64>("VolumeId", Self::VT_VOLUMEID, false)?
     .visit_field::<i64>("ChapterId", Self::VT_CHAPTERID, false)?
     .visit_field::<i64>("EpisodeId", Self::VT_EPISODEID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ExposedTime", Self::VT_EXPOSEDTIME, false)?
     .visit_field::<bool>("Hide", Self::VT_HIDE, false)?
     .visit_field::<bool>("Open", Self::VT_OPEN, false)?
     .visit_field::<bool>("IsContinue", Self::VT_ISCONTINUE, false)?
     .visit_field::<i64>("EpisodeContinueModeId", Self::VT_EPISODECONTINUEMODEID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("FrontScenarioGroupId", Self::VT_FRONTSCENARIOGROUPID, false)?
     .visit_field::<i64>("StrategyId", Self::VT_STRATEGYID, false)?
     .visit_field::<i64>("GroundId", Self::VT_GROUNDID, false)?
     .visit_field::<bool>("IsDefeatBattle", Self::VT_ISDEFEATBATTLE, false)?
     .visit_field::<i64>("BattleDuration", Self::VT_BATTLEDURATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("BackScenarioGroupId", Self::VT_BACKSCENARIOGROUPID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("ClearedModeId", Self::VT_CLEAREDMODEID, false)?
     .visit_field::<i64>("ScenarioModeRewardId", Self::VT_SCENARIOMODEREWARDID, false)?
     .visit_field::<bool>("IsScenarioSpecialReward", Self::VT_ISSCENARIOSPECIALREWARD, false)?
     .visit_field::<i64>("AccountLevelLimit", Self::VT_ACCOUNTLEVELLIMIT, false)?
     .visit_field::<i64>("ClearedStageId", Self::VT_CLEAREDSTAGEID, false)?
     .visit_field::<Club>("NeedClub", Self::VT_NEEDCLUB, false)?
     .visit_field::<i32>("NeedClubStudentCount", Self::VT_NEEDCLUBSTUDENTCOUNT, false)?
     .visit_field::<i64>("EventContentId", Self::VT_EVENTCONTENTID, false)?
     .visit_field::<EventContentType>("EventContentType", Self::VT_EVENTCONTENTTYPE, false)?
     .visit_field::<i64>("EventContentCondition", Self::VT_EVENTCONTENTCONDITION, false)?
     .visit_field::<i64>("EventContentConditionGroup", Self::VT_EVENTCONTENTCONDITIONGROUP, false)?
     .visit_field::<StageDifficulty>("MapDifficulty", Self::VT_MAPDIFFICULTY, false)?
     .visit_field::<i32>("StepIndex", Self::VT_STEPINDEX, false)?
     .visit_field::<i32>("RecommendLevel", Self::VT_RECOMMENDLEVEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EventIconParcelPath", Self::VT_EVENTICONPARCELPATH, false)?
     .visit_field::<u32>("EventBannerTitle", Self::VT_EVENTBANNERTITLE, false)?
     .visit_field::<bool>("lof", Self::VT_LOF, false)?
     .visit_field::<StageTopography>("StageTopography", Self::VT_STAGETOPOGRAPHY, false)?
     .visit_field::<i64>("FixedEchelonId", Self::VT_FIXEDECHELONID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CompleteReportEventName", Self::VT_COMPLETEREPORTEVENTNAME, false)?
     .visit_field::<EchelonExtensionType>("EchelonExtensionType", Self::VT_ECHELONEXTENSIONTYPE, false)?
     .visit_field::<i64>("CollectionGroupId", Self::VT_COLLECTIONGROUPID, false)?
     .finish();
    Ok(())
  }
}
pub struct ScenarioModeExcelArgs<'a> {
    pub ModeId: i64,
    pub ModeType: ScenarioModeTypes,
    pub SubType: ScenarioModeSubTypes,
    pub VolumeId: i64,
    pub ChapterId: i64,
    pub EpisodeId: i64,
    pub ExposedTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub Hide: bool,
    pub Open: bool,
    pub IsContinue: bool,
    pub EpisodeContinueModeId: i64,
    pub FrontScenarioGroupId: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub StrategyId: i64,
    pub GroundId: i64,
    pub IsDefeatBattle: bool,
    pub BattleDuration: i64,
    pub BackScenarioGroupId: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub ClearedModeId: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub ScenarioModeRewardId: i64,
    pub IsScenarioSpecialReward: bool,
    pub AccountLevelLimit: i64,
    pub ClearedStageId: i64,
    pub NeedClub: Club,
    pub NeedClubStudentCount: i32,
    pub EventContentId: i64,
    pub EventContentType: EventContentType,
    pub EventContentCondition: i64,
    pub EventContentConditionGroup: i64,
    pub MapDifficulty: StageDifficulty,
    pub StepIndex: i32,
    pub RecommendLevel: i32,
    pub EventIconParcelPath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EventBannerTitle: u32,
    pub lof: bool,
    pub StageTopography: StageTopography,
    pub FixedEchelonId: i64,
    pub CompleteReportEventName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EchelonExtensionType: EchelonExtensionType,
    pub CollectionGroupId: i64,
}
impl<'a> Default for ScenarioModeExcelArgs<'a> {
  #[inline]
  fn default() -> Self {
    ScenarioModeExcelArgs {
      ModeId: 0,
      ModeType: ScenarioModeTypes::None,
      SubType: ScenarioModeSubTypes::None,
      VolumeId: 0,
      ChapterId: 0,
      EpisodeId: 0,
      ExposedTime: None,
      Hide: false,
      Open: false,
      IsContinue: false,
      EpisodeContinueModeId: 0,
      FrontScenarioGroupId: None,
      StrategyId: 0,
      GroundId: 0,
      IsDefeatBattle: false,
      BattleDuration: 0,
      BackScenarioGroupId: None,
      ClearedModeId: None,
      ScenarioModeRewardId: 0,
      IsScenarioSpecialReward: false,
      AccountLevelLimit: 0,
      ClearedStageId: 0,
      NeedClub: Club::None,
      NeedClubStudentCount: 0,
      EventContentId: 0,
      EventContentType: EventContentType::Stage,
      EventContentCondition: 0,
      EventContentConditionGroup: 0,
      MapDifficulty: StageDifficulty::None,
      StepIndex: 0,
      RecommendLevel: 0,
      EventIconParcelPath: None,
      EventBannerTitle: 0,
      lof: false,
      StageTopography: StageTopography::Street,
      FixedEchelonId: 0,
      CompleteReportEventName: None,
      EchelonExtensionType: EchelonExtensionType::Base,
      CollectionGroupId: 0,
    }
  }
}

impl Serialize for ScenarioModeExcel<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("ScenarioModeExcel", 39)?;
      s.serialize_field("ModeId", &self.ModeId())?;
      s.serialize_field("ModeType", &self.ModeType())?;
      s.serialize_field("SubType", &self.SubType())?;
      s.serialize_field("VolumeId", &self.VolumeId())?;
      s.serialize_field("ChapterId", &self.ChapterId())?;
      s.serialize_field("EpisodeId", &self.EpisodeId())?;
      if let Some(f) = self.ExposedTime() {
        s.serialize_field("ExposedTime", &f)?;
      } else {
        s.skip_field("ExposedTime")?;
      }
      s.serialize_field("Hide", &self.Hide())?;
      s.serialize_field("Open", &self.Open())?;
      s.serialize_field("IsContinue", &self.IsContinue())?;
      s.serialize_field("EpisodeContinueModeId", &self.EpisodeContinueModeId())?;
      if let Some(f) = self.FrontScenarioGroupId() {
        s.serialize_field("FrontScenarioGroupId", &f)?;
      } else {
        s.skip_field("FrontScenarioGroupId")?;
      }
      s.serialize_field("StrategyId", &self.StrategyId())?;
      s.serialize_field("GroundId", &self.GroundId())?;
      s.serialize_field("IsDefeatBattle", &self.IsDefeatBattle())?;
      s.serialize_field("BattleDuration", &self.BattleDuration())?;
      if let Some(f) = self.BackScenarioGroupId() {
        s.serialize_field("BackScenarioGroupId", &f)?;
      } else {
        s.skip_field("BackScenarioGroupId")?;
      }
      if let Some(f) = self.ClearedModeId() {
        s.serialize_field("ClearedModeId", &f)?;
      } else {
        s.skip_field("ClearedModeId")?;
      }
      s.serialize_field("ScenarioModeRewardId", &self.ScenarioModeRewardId())?;
      s.serialize_field("IsScenarioSpecialReward", &self.IsScenarioSpecialReward())?;
      s.serialize_field("AccountLevelLimit", &self.AccountLevelLimit())?;
      s.serialize_field("ClearedStageId", &self.ClearedStageId())?;
      s.serialize_field("NeedClub", &self.NeedClub())?;
      s.serialize_field("NeedClubStudentCount", &self.NeedClubStudentCount())?;
      s.serialize_field("EventContentId", &self.EventContentId())?;
      s.serialize_field("EventContentType", &self.EventContentType())?;
      s.serialize_field("EventContentCondition", &self.EventContentCondition())?;
      s.serialize_field("EventContentConditionGroup", &self.EventContentConditionGroup())?;
      s.serialize_field("MapDifficulty", &self.MapDifficulty())?;
      s.serialize_field("StepIndex", &self.StepIndex())?;
      s.serialize_field("RecommendLevel", &self.RecommendLevel())?;
      if let Some(f) = self.EventIconParcelPath() {
        s.serialize_field("EventIconParcelPath", &f)?;
      } else {
        s.skip_field("EventIconParcelPath")?;
      }
      s.serialize_field("EventBannerTitle", &self.EventBannerTitle())?;
      s.serialize_field("lof", &self.lof())?;
      s.serialize_field("StageTopography", &self.StageTopography())?;
      s.serialize_field("FixedEchelonId", &self.FixedEchelonId())?;
      if let Some(f) = self.CompleteReportEventName() {
        s.serialize_field("CompleteReportEventName", &f)?;
      } else {
        s.skip_field("CompleteReportEventName")?;
      }
      s.serialize_field("EchelonExtensionType", &self.EchelonExtensionType())?;
      s.serialize_field("CollectionGroupId", &self.CollectionGroupId())?;
    s.end()
  }
}

pub struct ScenarioModeExcelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ScenarioModeExcelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ModeId(&mut self, ModeId: i64) {
    self.fbb_.push_slot::<i64>(ScenarioModeExcel::VT_MODEID, ModeId, 0);
  }
  #[inline]
  pub fn add_ModeType(&mut self, ModeType: ScenarioModeTypes) {
    self.fbb_.push_slot::<ScenarioModeTypes>(ScenarioModeExcel::VT_MODETYPE, ModeType, ScenarioModeTypes::None);
  }
  #[inline]
  pub fn add_SubType(&mut self, SubType: ScenarioModeSubTypes) {
    self.fbb_.push_slot::<ScenarioModeSubTypes>(ScenarioModeExcel::VT_SUBTYPE, SubType, ScenarioModeSubTypes::None);
  }
  #[inline]
  pub fn add_VolumeId(&mut self, VolumeId: i64) {
    self.fbb_.push_slot::<i64>(ScenarioModeExcel::VT_VOLUMEID, VolumeId, 0);
  }
  #[inline]
  pub fn add_ChapterId(&mut self, ChapterId: i64) {
    self.fbb_.push_slot::<i64>(ScenarioModeExcel::VT_CHAPTERID, ChapterId, 0);
  }
  #[inline]
  pub fn add_EpisodeId(&mut self, EpisodeId: i64) {
    self.fbb_.push_slot::<i64>(ScenarioModeExcel::VT_EPISODEID, EpisodeId, 0);
  }
  #[inline]
  pub fn add_ExposedTime(&mut self, ExposedTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ScenarioModeExcel::VT_EXPOSEDTIME, ExposedTime);
  }
  #[inline]
  pub fn add_Hide(&mut self, Hide: bool) {
    self.fbb_.push_slot::<bool>(ScenarioModeExcel::VT_HIDE, Hide, false);
  }
  #[inline]
  pub fn add_Open(&mut self, Open: bool) {
    self.fbb_.push_slot::<bool>(ScenarioModeExcel::VT_OPEN, Open, false);
  }
  #[inline]
  pub fn add_IsContinue(&mut self, IsContinue: bool) {
    self.fbb_.push_slot::<bool>(ScenarioModeExcel::VT_ISCONTINUE, IsContinue, false);
  }
  #[inline]
  pub fn add_EpisodeContinueModeId(&mut self, EpisodeContinueModeId: i64) {
    self.fbb_.push_slot::<i64>(ScenarioModeExcel::VT_EPISODECONTINUEMODEID, EpisodeContinueModeId, 0);
  }
  #[inline]
  pub fn add_FrontScenarioGroupId(&mut self, FrontScenarioGroupId: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ScenarioModeExcel::VT_FRONTSCENARIOGROUPID, FrontScenarioGroupId);
  }
  #[inline]
  pub fn add_StrategyId(&mut self, StrategyId: i64) {
    self.fbb_.push_slot::<i64>(ScenarioModeExcel::VT_STRATEGYID, StrategyId, 0);
  }
  #[inline]
  pub fn add_GroundId(&mut self, GroundId: i64) {
    self.fbb_.push_slot::<i64>(ScenarioModeExcel::VT_GROUNDID, GroundId, 0);
  }
  #[inline]
  pub fn add_IsDefeatBattle(&mut self, IsDefeatBattle: bool) {
    self.fbb_.push_slot::<bool>(ScenarioModeExcel::VT_ISDEFEATBATTLE, IsDefeatBattle, false);
  }
  #[inline]
  pub fn add_BattleDuration(&mut self, BattleDuration: i64) {
    self.fbb_.push_slot::<i64>(ScenarioModeExcel::VT_BATTLEDURATION, BattleDuration, 0);
  }
  #[inline]
  pub fn add_BackScenarioGroupId(&mut self, BackScenarioGroupId: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ScenarioModeExcel::VT_BACKSCENARIOGROUPID, BackScenarioGroupId);
  }
  #[inline]
  pub fn add_ClearedModeId(&mut self, ClearedModeId: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ScenarioModeExcel::VT_CLEAREDMODEID, ClearedModeId);
  }
  #[inline]
  pub fn add_ScenarioModeRewardId(&mut self, ScenarioModeRewardId: i64) {
    self.fbb_.push_slot::<i64>(ScenarioModeExcel::VT_SCENARIOMODEREWARDID, ScenarioModeRewardId, 0);
  }
  #[inline]
  pub fn add_IsScenarioSpecialReward(&mut self, IsScenarioSpecialReward: bool) {
    self.fbb_.push_slot::<bool>(ScenarioModeExcel::VT_ISSCENARIOSPECIALREWARD, IsScenarioSpecialReward, false);
  }
  #[inline]
  pub fn add_AccountLevelLimit(&mut self, AccountLevelLimit: i64) {
    self.fbb_.push_slot::<i64>(ScenarioModeExcel::VT_ACCOUNTLEVELLIMIT, AccountLevelLimit, 0);
  }
  #[inline]
  pub fn add_ClearedStageId(&mut self, ClearedStageId: i64) {
    self.fbb_.push_slot::<i64>(ScenarioModeExcel::VT_CLEAREDSTAGEID, ClearedStageId, 0);
  }
  #[inline]
  pub fn add_NeedClub(&mut self, NeedClub: Club) {
    self.fbb_.push_slot::<Club>(ScenarioModeExcel::VT_NEEDCLUB, NeedClub, Club::None);
  }
  #[inline]
  pub fn add_NeedClubStudentCount(&mut self, NeedClubStudentCount: i32) {
    self.fbb_.push_slot::<i32>(ScenarioModeExcel::VT_NEEDCLUBSTUDENTCOUNT, NeedClubStudentCount, 0);
  }
  #[inline]
  pub fn add_EventContentId(&mut self, EventContentId: i64) {
    self.fbb_.push_slot::<i64>(ScenarioModeExcel::VT_EVENTCONTENTID, EventContentId, 0);
  }
  #[inline]
  pub fn add_EventContentType(&mut self, EventContentType: EventContentType) {
    self.fbb_.push_slot::<EventContentType>(ScenarioModeExcel::VT_EVENTCONTENTTYPE, EventContentType, EventContentType::Stage);
  }
  #[inline]
  pub fn add_EventContentCondition(&mut self, EventContentCondition: i64) {
    self.fbb_.push_slot::<i64>(ScenarioModeExcel::VT_EVENTCONTENTCONDITION, EventContentCondition, 0);
  }
  #[inline]
  pub fn add_EventContentConditionGroup(&mut self, EventContentConditionGroup: i64) {
    self.fbb_.push_slot::<i64>(ScenarioModeExcel::VT_EVENTCONTENTCONDITIONGROUP, EventContentConditionGroup, 0);
  }
  #[inline]
  pub fn add_MapDifficulty(&mut self, MapDifficulty: StageDifficulty) {
    self.fbb_.push_slot::<StageDifficulty>(ScenarioModeExcel::VT_MAPDIFFICULTY, MapDifficulty, StageDifficulty::None);
  }
  #[inline]
  pub fn add_StepIndex(&mut self, StepIndex: i32) {
    self.fbb_.push_slot::<i32>(ScenarioModeExcel::VT_STEPINDEX, StepIndex, 0);
  }
  #[inline]
  pub fn add_RecommendLevel(&mut self, RecommendLevel: i32) {
    self.fbb_.push_slot::<i32>(ScenarioModeExcel::VT_RECOMMENDLEVEL, RecommendLevel, 0);
  }
  #[inline]
  pub fn add_EventIconParcelPath(&mut self, EventIconParcelPath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ScenarioModeExcel::VT_EVENTICONPARCELPATH, EventIconParcelPath);
  }
  #[inline]
  pub fn add_EventBannerTitle(&mut self, EventBannerTitle: u32) {
    self.fbb_.push_slot::<u32>(ScenarioModeExcel::VT_EVENTBANNERTITLE, EventBannerTitle, 0);
  }
  #[inline]
  pub fn add_lof(&mut self, lof: bool) {
    self.fbb_.push_slot::<bool>(ScenarioModeExcel::VT_LOF, lof, false);
  }
  #[inline]
  pub fn add_StageTopography(&mut self, StageTopography: StageTopography) {
    self.fbb_.push_slot::<StageTopography>(ScenarioModeExcel::VT_STAGETOPOGRAPHY, StageTopography, StageTopography::Street);
  }
  #[inline]
  pub fn add_FixedEchelonId(&mut self, FixedEchelonId: i64) {
    self.fbb_.push_slot::<i64>(ScenarioModeExcel::VT_FIXEDECHELONID, FixedEchelonId, 0);
  }
  #[inline]
  pub fn add_CompleteReportEventName(&mut self, CompleteReportEventName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ScenarioModeExcel::VT_COMPLETEREPORTEVENTNAME, CompleteReportEventName);
  }
  #[inline]
  pub fn add_EchelonExtensionType(&mut self, EchelonExtensionType: EchelonExtensionType) {
    self.fbb_.push_slot::<EchelonExtensionType>(ScenarioModeExcel::VT_ECHELONEXTENSIONTYPE, EchelonExtensionType, EchelonExtensionType::Base);
  }
  #[inline]
  pub fn add_CollectionGroupId(&mut self, CollectionGroupId: i64) {
    self.fbb_.push_slot::<i64>(ScenarioModeExcel::VT_COLLECTIONGROUPID, CollectionGroupId, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ScenarioModeExcelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ScenarioModeExcelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ScenarioModeExcel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ScenarioModeExcel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ScenarioModeExcel");
      ds.field("ModeId", &self.ModeId());
      ds.field("ModeType", &self.ModeType());
      ds.field("SubType", &self.SubType());
      ds.field("VolumeId", &self.VolumeId());
      ds.field("ChapterId", &self.ChapterId());
      ds.field("EpisodeId", &self.EpisodeId());
      ds.field("ExposedTime", &self.ExposedTime());
      ds.field("Hide", &self.Hide());
      ds.field("Open", &self.Open());
      ds.field("IsContinue", &self.IsContinue());
      ds.field("EpisodeContinueModeId", &self.EpisodeContinueModeId());
      ds.field("FrontScenarioGroupId", &self.FrontScenarioGroupId());
      ds.field("StrategyId", &self.StrategyId());
      ds.field("GroundId", &self.GroundId());
      ds.field("IsDefeatBattle", &self.IsDefeatBattle());
      ds.field("BattleDuration", &self.BattleDuration());
      ds.field("BackScenarioGroupId", &self.BackScenarioGroupId());
      ds.field("ClearedModeId", &self.ClearedModeId());
      ds.field("ScenarioModeRewardId", &self.ScenarioModeRewardId());
      ds.field("IsScenarioSpecialReward", &self.IsScenarioSpecialReward());
      ds.field("AccountLevelLimit", &self.AccountLevelLimit());
      ds.field("ClearedStageId", &self.ClearedStageId());
      ds.field("NeedClub", &self.NeedClub());
      ds.field("NeedClubStudentCount", &self.NeedClubStudentCount());
      ds.field("EventContentId", &self.EventContentId());
      ds.field("EventContentType", &self.EventContentType());
      ds.field("EventContentCondition", &self.EventContentCondition());
      ds.field("EventContentConditionGroup", &self.EventContentConditionGroup());
      ds.field("MapDifficulty", &self.MapDifficulty());
      ds.field("StepIndex", &self.StepIndex());
      ds.field("RecommendLevel", &self.RecommendLevel());
      ds.field("EventIconParcelPath", &self.EventIconParcelPath());
      ds.field("EventBannerTitle", &self.EventBannerTitle());
      ds.field("lof", &self.lof());
      ds.field("StageTopography", &self.StageTopography());
      ds.field("FixedEchelonId", &self.FixedEchelonId());
      ds.field("CompleteReportEventName", &self.CompleteReportEventName());
      ds.field("EchelonExtensionType", &self.EchelonExtensionType());
      ds.field("CollectionGroupId", &self.CollectionGroupId());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ScenarioModeExcelT {
  pub ModeId: i64,
  pub ModeType: ScenarioModeTypes,
  pub SubType: ScenarioModeSubTypes,
  pub VolumeId: i64,
  pub ChapterId: i64,
  pub EpisodeId: i64,
  pub ExposedTime: Option<String>,
  pub Hide: bool,
  pub Open: bool,
  pub IsContinue: bool,
  pub EpisodeContinueModeId: i64,
  pub FrontScenarioGroupId: Option<Vec<i64>>,
  pub StrategyId: i64,
  pub GroundId: i64,
  pub IsDefeatBattle: bool,
  pub BattleDuration: i64,
  pub BackScenarioGroupId: Option<Vec<i64>>,
  pub ClearedModeId: Option<Vec<i64>>,
  pub ScenarioModeRewardId: i64,
  pub IsScenarioSpecialReward: bool,
  pub AccountLevelLimit: i64,
  pub ClearedStageId: i64,
  pub NeedClub: Club,
  pub NeedClubStudentCount: i32,
  pub EventContentId: i64,
  pub EventContentType: EventContentType,
  pub EventContentCondition: i64,
  pub EventContentConditionGroup: i64,
  pub MapDifficulty: StageDifficulty,
  pub StepIndex: i32,
  pub RecommendLevel: i32,
  pub EventIconParcelPath: Option<String>,
  pub EventBannerTitle: u32,
  pub lof: bool,
  pub StageTopography: StageTopography,
  pub FixedEchelonId: i64,
  pub CompleteReportEventName: Option<String>,
  pub EchelonExtensionType: EchelonExtensionType,
  pub CollectionGroupId: i64,
}
impl Default for ScenarioModeExcelT {
  fn default() -> Self {
    Self {
      ModeId: 0,
      ModeType: ScenarioModeTypes::None,
      SubType: ScenarioModeSubTypes::None,
      VolumeId: 0,
      ChapterId: 0,
      EpisodeId: 0,
      ExposedTime: None,
      Hide: false,
      Open: false,
      IsContinue: false,
      EpisodeContinueModeId: 0,
      FrontScenarioGroupId: None,
      StrategyId: 0,
      GroundId: 0,
      IsDefeatBattle: false,
      BattleDuration: 0,
      BackScenarioGroupId: None,
      ClearedModeId: None,
      ScenarioModeRewardId: 0,
      IsScenarioSpecialReward: false,
      AccountLevelLimit: 0,
      ClearedStageId: 0,
      NeedClub: Club::None,
      NeedClubStudentCount: 0,
      EventContentId: 0,
      EventContentType: EventContentType::Stage,
      EventContentCondition: 0,
      EventContentConditionGroup: 0,
      MapDifficulty: StageDifficulty::None,
      StepIndex: 0,
      RecommendLevel: 0,
      EventIconParcelPath: None,
      EventBannerTitle: 0,
      lof: false,
      StageTopography: StageTopography::Street,
      FixedEchelonId: 0,
      CompleteReportEventName: None,
      EchelonExtensionType: EchelonExtensionType::Base,
      CollectionGroupId: 0,
    }
  }
}
impl ScenarioModeExcelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ScenarioModeExcel<'b>> {
    let ModeId = self.ModeId;
    let ModeType = self.ModeType;
    let SubType = self.SubType;
    let VolumeId = self.VolumeId;
    let ChapterId = self.ChapterId;
    let EpisodeId = self.EpisodeId;
    let ExposedTime = self.ExposedTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let Hide = self.Hide;
    let Open = self.Open;
    let IsContinue = self.IsContinue;
    let EpisodeContinueModeId = self.EpisodeContinueModeId;
    let FrontScenarioGroupId = self.FrontScenarioGroupId.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let StrategyId = self.StrategyId;
    let GroundId = self.GroundId;
    let IsDefeatBattle = self.IsDefeatBattle;
    let BattleDuration = self.BattleDuration;
    let BackScenarioGroupId = self.BackScenarioGroupId.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let ClearedModeId = self.ClearedModeId.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let ScenarioModeRewardId = self.ScenarioModeRewardId;
    let IsScenarioSpecialReward = self.IsScenarioSpecialReward;
    let AccountLevelLimit = self.AccountLevelLimit;
    let ClearedStageId = self.ClearedStageId;
    let NeedClub = self.NeedClub;
    let NeedClubStudentCount = self.NeedClubStudentCount;
    let EventContentId = self.EventContentId;
    let EventContentType = self.EventContentType;
    let EventContentCondition = self.EventContentCondition;
    let EventContentConditionGroup = self.EventContentConditionGroup;
    let MapDifficulty = self.MapDifficulty;
    let StepIndex = self.StepIndex;
    let RecommendLevel = self.RecommendLevel;
    let EventIconParcelPath = self.EventIconParcelPath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EventBannerTitle = self.EventBannerTitle;
    let lof = self.lof;
    let StageTopography = self.StageTopography;
    let FixedEchelonId = self.FixedEchelonId;
    let CompleteReportEventName = self.CompleteReportEventName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EchelonExtensionType = self.EchelonExtensionType;
    let CollectionGroupId = self.CollectionGroupId;
    ScenarioModeExcel::create(_fbb, &ScenarioModeExcelArgs{
      ModeId,
      ModeType,
      SubType,
      VolumeId,
      ChapterId,
      EpisodeId,
      ExposedTime,
      Hide,
      Open,
      IsContinue,
      EpisodeContinueModeId,
      FrontScenarioGroupId,
      StrategyId,
      GroundId,
      IsDefeatBattle,
      BattleDuration,
      BackScenarioGroupId,
      ClearedModeId,
      ScenarioModeRewardId,
      IsScenarioSpecialReward,
      AccountLevelLimit,
      ClearedStageId,
      NeedClub,
      NeedClubStudentCount,
      EventContentId,
      EventContentType,
      EventContentCondition,
      EventContentConditionGroup,
      MapDifficulty,
      StepIndex,
      RecommendLevel,
      EventIconParcelPath,
      EventBannerTitle,
      lof,
      StageTopography,
      FixedEchelonId,
      CompleteReportEventName,
      EchelonExtensionType,
      CollectionGroupId,
    })
  }
}
