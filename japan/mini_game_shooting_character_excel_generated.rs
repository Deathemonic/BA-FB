// automatically generated by the FlatBuffers compiler, do not modify
// @generated
#![allow(unused_imports, dead_code)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum MiniGameShootingCharacterExcelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MiniGameShootingCharacterExcel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MiniGameShootingCharacterExcel<'a> {
  type Inner = MiniGameShootingCharacterExcel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MiniGameShootingCharacterExcel<'a> {
  pub const VT_UNIQUEID: flatbuffers::VOffsetT = 4;
  pub const VT_SPINERESOURCENAME: flatbuffers::VOffsetT = 6;
  pub const VT_BODYRADIUS: flatbuffers::VOffsetT = 8;
  pub const VT_MODELPREFABNAME: flatbuffers::VOffsetT = 10;
  pub const VT_NORMALATTACKSKILLDATA: flatbuffers::VOffsetT = 12;
  pub const VT_PUBLICSKILLDATA: flatbuffers::VOffsetT = 14;
  pub const VT_DEATHSKILLDATA: flatbuffers::VOffsetT = 16;
  pub const VT_MAXHP: flatbuffers::VOffsetT = 18;
  pub const VT_ATTACKPOWER: flatbuffers::VOffsetT = 20;
  pub const VT_DEFENSEPOWER: flatbuffers::VOffsetT = 22;
  pub const VT_CRITICALRATE: flatbuffers::VOffsetT = 24;
  pub const VT_CRITICALDAMAGERATE: flatbuffers::VOffsetT = 26;
  pub const VT_ATTACKRANGE: flatbuffers::VOffsetT = 28;
  pub const VT_MOVESPEED: flatbuffers::VOffsetT = 30;
  pub const VT_SHOTTIME: flatbuffers::VOffsetT = 32;
  pub const VT_ISBOSS: flatbuffers::VOffsetT = 34;
  pub const VT_SCALE: flatbuffers::VOffsetT = 36;
  pub const VT_IGNOREOBSTACLECHECK: flatbuffers::VOffsetT = 38;
  pub const VT_CHARACTERVOICEGROUPID: flatbuffers::VOffsetT = 40;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MiniGameShootingCharacterExcel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MiniGameShootingCharacterExcelArgs<'args>
  ) -> flatbuffers::WIPOffset<MiniGameShootingCharacterExcel<'bldr>> {
    let mut builder = MiniGameShootingCharacterExcelBuilder::new(_fbb);
    let key = table_encryption_service::create_key(b"MiniGameShootingCharacter");
      let x = args.CharacterVoiceGroupId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_CharacterVoiceGroupId(x);
      let x = args.ShotTime;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_ShotTime(x);
      let x = args.MoveSpeed;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_MoveSpeed(x);
      let x = args.AttackRange;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_AttackRange(x);
      let x = args.CriticalDamageRate;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_CriticalDamageRate(x);
      let x = args.CriticalRate;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_CriticalRate(x);
      let x = args.DefensePower;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_DefensePower(x);
      let x = args.AttackPower;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_AttackPower(x);
      let x = args.MaxHP;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_MaxHP(x);
      let x = args.UniqueId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_UniqueId(x);
      let x = args.Scale;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_Scale(x);
      if let Some(x) = args.DeathSkillData {
        builder.add_DeathSkillData(x);
      }
      if let Some(x) = args.PublicSkillData {
        builder.add_PublicSkillData(x);
      }
      if let Some(x) = args.NormalAttackSkillData {
        builder.add_NormalAttackSkillData(x);
      }
      if let Some(x) = args.ModelPrefabName {
        builder.add_ModelPrefabName(x);
      }
      let x = args.BodyRadius;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::encrypt_float(x, &key) } else { x };
      builder.add_BodyRadius(x);
      if let Some(x) = args.SpineResourceName {
        builder.add_SpineResourceName(x);
      }
      builder.add_IgnoreObstacleCheck(args.IgnoreObstacleCheck);
      builder.add_IsBoss(args.IsBoss);
    builder.finish()
  }

  pub fn unpack(&self) -> MiniGameShootingCharacterExcelT {
    let key = table_encryption_service::create_key(b"MiniGameShootingCharacter");
      let UniqueId = self.UniqueId();
    let SpineResourceName = self.SpineResourceName().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let BodyRadius = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.BodyRadius(), &key)
      } else {
        self.BodyRadius()
      };
    let ModelPrefabName = self.ModelPrefabName().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let NormalAttackSkillData = self.NormalAttackSkillData().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let PublicSkillData = self.PublicSkillData().map(|x| {
      x.iter().map(|s| if table_encryption_service::use_encryption() { table_encryption_service::convert_string(s, &key).unwrap() } else { s.to_string() }).collect()
    });
    let DeathSkillData = self.DeathSkillData().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let MaxHP = self.MaxHP();
      let AttackPower = self.AttackPower();
      let DefensePower = self.DefensePower();
      let CriticalRate = self.CriticalRate();
      let CriticalDamageRate = self.CriticalDamageRate();
      let AttackRange = self.AttackRange();
      let MoveSpeed = self.MoveSpeed();
      let ShotTime = self.ShotTime();
      let IsBoss = self.IsBoss();
      let Scale = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_float(self.Scale(), &key)
      } else {
        self.Scale()
      };
      let IgnoreObstacleCheck = self.IgnoreObstacleCheck();
      let CharacterVoiceGroupId = self.CharacterVoiceGroupId();
    MiniGameShootingCharacterExcelT {
      UniqueId,
      SpineResourceName,
      BodyRadius,
      ModelPrefabName,
      NormalAttackSkillData,
      PublicSkillData,
      DeathSkillData,
      MaxHP,
      AttackPower,
      DefensePower,
      CriticalRate,
      CriticalDamageRate,
      AttackRange,
      MoveSpeed,
      ShotTime,
      IsBoss,
      Scale,
      IgnoreObstacleCheck,
      CharacterVoiceGroupId,
    }
  }

  #[inline]
  pub fn UniqueId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MiniGameShootingCharacterExcel::VT_UNIQUEID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn SpineResourceName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MiniGameShootingCharacterExcel::VT_SPINERESOURCENAME, None)}
  }
  #[inline]
  pub fn BodyRadius(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(MiniGameShootingCharacterExcel::VT_BODYRADIUS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ModelPrefabName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MiniGameShootingCharacterExcel::VT_MODELPREFABNAME, None)}
  }
  #[inline]
  pub fn NormalAttackSkillData(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MiniGameShootingCharacterExcel::VT_NORMALATTACKSKILLDATA, None)}
  }
  #[inline]
  pub fn PublicSkillData(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(MiniGameShootingCharacterExcel::VT_PUBLICSKILLDATA, None)}
  }
  #[inline]
  pub fn DeathSkillData(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MiniGameShootingCharacterExcel::VT_DEATHSKILLDATA, None)}
  }
  #[inline]
  pub fn MaxHP(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MiniGameShootingCharacterExcel::VT_MAXHP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn AttackPower(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MiniGameShootingCharacterExcel::VT_ATTACKPOWER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn DefensePower(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MiniGameShootingCharacterExcel::VT_DEFENSEPOWER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CriticalRate(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MiniGameShootingCharacterExcel::VT_CRITICALRATE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CriticalDamageRate(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MiniGameShootingCharacterExcel::VT_CRITICALDAMAGERATE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn AttackRange(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MiniGameShootingCharacterExcel::VT_ATTACKRANGE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn MoveSpeed(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MiniGameShootingCharacterExcel::VT_MOVESPEED, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ShotTime(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MiniGameShootingCharacterExcel::VT_SHOTTIME, Some(0)).unwrap()}
  }
  #[inline]
  pub fn IsBoss(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(MiniGameShootingCharacterExcel::VT_ISBOSS, Some(false)).unwrap()}
  }
  #[inline]
  pub fn Scale(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(MiniGameShootingCharacterExcel::VT_SCALE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn IgnoreObstacleCheck(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(MiniGameShootingCharacterExcel::VT_IGNOREOBSTACLECHECK, Some(false)).unwrap()}
  }
  #[inline]
  pub fn CharacterVoiceGroupId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(MiniGameShootingCharacterExcel::VT_CHARACTERVOICEGROUPID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for MiniGameShootingCharacterExcel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("UniqueId", Self::VT_UNIQUEID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SpineResourceName", Self::VT_SPINERESOURCENAME, false)?
     .visit_field::<f32>("BodyRadius", Self::VT_BODYRADIUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ModelPrefabName", Self::VT_MODELPREFABNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NormalAttackSkillData", Self::VT_NORMALATTACKSKILLDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("PublicSkillData", Self::VT_PUBLICSKILLDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DeathSkillData", Self::VT_DEATHSKILLDATA, false)?
     .visit_field::<i64>("MaxHP", Self::VT_MAXHP, false)?
     .visit_field::<i64>("AttackPower", Self::VT_ATTACKPOWER, false)?
     .visit_field::<i64>("DefensePower", Self::VT_DEFENSEPOWER, false)?
     .visit_field::<i64>("CriticalRate", Self::VT_CRITICALRATE, false)?
     .visit_field::<i64>("CriticalDamageRate", Self::VT_CRITICALDAMAGERATE, false)?
     .visit_field::<i64>("AttackRange", Self::VT_ATTACKRANGE, false)?
     .visit_field::<i64>("MoveSpeed", Self::VT_MOVESPEED, false)?
     .visit_field::<i64>("ShotTime", Self::VT_SHOTTIME, false)?
     .visit_field::<bool>("IsBoss", Self::VT_ISBOSS, false)?
     .visit_field::<f32>("Scale", Self::VT_SCALE, false)?
     .visit_field::<bool>("IgnoreObstacleCheck", Self::VT_IGNOREOBSTACLECHECK, false)?
     .visit_field::<i64>("CharacterVoiceGroupId", Self::VT_CHARACTERVOICEGROUPID, false)?
     .finish();
    Ok(())
  }
}
pub struct MiniGameShootingCharacterExcelArgs<'a> {
    pub UniqueId: i64,
    pub SpineResourceName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub BodyRadius: f32,
    pub ModelPrefabName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub NormalAttackSkillData: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PublicSkillData: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub DeathSkillData: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MaxHP: i64,
    pub AttackPower: i64,
    pub DefensePower: i64,
    pub CriticalRate: i64,
    pub CriticalDamageRate: i64,
    pub AttackRange: i64,
    pub MoveSpeed: i64,
    pub ShotTime: i64,
    pub IsBoss: bool,
    pub Scale: f32,
    pub IgnoreObstacleCheck: bool,
    pub CharacterVoiceGroupId: i64,
}
impl<'a> Default for MiniGameShootingCharacterExcelArgs<'a> {
  #[inline]
  fn default() -> Self {
    MiniGameShootingCharacterExcelArgs {
      UniqueId: 0,
      SpineResourceName: None,
      BodyRadius: 0.0,
      ModelPrefabName: None,
      NormalAttackSkillData: None,
      PublicSkillData: None,
      DeathSkillData: None,
      MaxHP: 0,
      AttackPower: 0,
      DefensePower: 0,
      CriticalRate: 0,
      CriticalDamageRate: 0,
      AttackRange: 0,
      MoveSpeed: 0,
      ShotTime: 0,
      IsBoss: false,
      Scale: 0.0,
      IgnoreObstacleCheck: false,
      CharacterVoiceGroupId: 0,
    }
  }
}

impl Serialize for MiniGameShootingCharacterExcel<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("MiniGameShootingCharacterExcel", 19)?;
      s.serialize_field("UniqueId", &self.UniqueId())?;
      if let Some(f) = self.SpineResourceName() {
        s.serialize_field("SpineResourceName", &f)?;
      } else {
        s.skip_field("SpineResourceName")?;
      }
      s.serialize_field("BodyRadius", &self.BodyRadius())?;
      if let Some(f) = self.ModelPrefabName() {
        s.serialize_field("ModelPrefabName", &f)?;
      } else {
        s.skip_field("ModelPrefabName")?;
      }
      if let Some(f) = self.NormalAttackSkillData() {
        s.serialize_field("NormalAttackSkillData", &f)?;
      } else {
        s.skip_field("NormalAttackSkillData")?;
      }
      if let Some(f) = self.PublicSkillData() {
        s.serialize_field("PublicSkillData", &f)?;
      } else {
        s.skip_field("PublicSkillData")?;
      }
      if let Some(f) = self.DeathSkillData() {
        s.serialize_field("DeathSkillData", &f)?;
      } else {
        s.skip_field("DeathSkillData")?;
      }
      s.serialize_field("MaxHP", &self.MaxHP())?;
      s.serialize_field("AttackPower", &self.AttackPower())?;
      s.serialize_field("DefensePower", &self.DefensePower())?;
      s.serialize_field("CriticalRate", &self.CriticalRate())?;
      s.serialize_field("CriticalDamageRate", &self.CriticalDamageRate())?;
      s.serialize_field("AttackRange", &self.AttackRange())?;
      s.serialize_field("MoveSpeed", &self.MoveSpeed())?;
      s.serialize_field("ShotTime", &self.ShotTime())?;
      s.serialize_field("IsBoss", &self.IsBoss())?;
      s.serialize_field("Scale", &self.Scale())?;
      s.serialize_field("IgnoreObstacleCheck", &self.IgnoreObstacleCheck())?;
      s.serialize_field("CharacterVoiceGroupId", &self.CharacterVoiceGroupId())?;
    s.end()
  }
}

pub struct MiniGameShootingCharacterExcelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MiniGameShootingCharacterExcelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_UniqueId(&mut self, UniqueId: i64) {
    self.fbb_.push_slot::<i64>(MiniGameShootingCharacterExcel::VT_UNIQUEID, UniqueId, 0);
  }
  #[inline]
  pub fn add_SpineResourceName(&mut self, SpineResourceName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MiniGameShootingCharacterExcel::VT_SPINERESOURCENAME, SpineResourceName);
  }
  #[inline]
  pub fn add_BodyRadius(&mut self, BodyRadius: f32) {
    self.fbb_.push_slot::<f32>(MiniGameShootingCharacterExcel::VT_BODYRADIUS, BodyRadius, 0.0);
  }
  #[inline]
  pub fn add_ModelPrefabName(&mut self, ModelPrefabName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MiniGameShootingCharacterExcel::VT_MODELPREFABNAME, ModelPrefabName);
  }
  #[inline]
  pub fn add_NormalAttackSkillData(&mut self, NormalAttackSkillData: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MiniGameShootingCharacterExcel::VT_NORMALATTACKSKILLDATA, NormalAttackSkillData);
  }
  #[inline]
  pub fn add_PublicSkillData(&mut self, PublicSkillData: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MiniGameShootingCharacterExcel::VT_PUBLICSKILLDATA, PublicSkillData);
  }
  #[inline]
  pub fn add_DeathSkillData(&mut self, DeathSkillData: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MiniGameShootingCharacterExcel::VT_DEATHSKILLDATA, DeathSkillData);
  }
  #[inline]
  pub fn add_MaxHP(&mut self, MaxHP: i64) {
    self.fbb_.push_slot::<i64>(MiniGameShootingCharacterExcel::VT_MAXHP, MaxHP, 0);
  }
  #[inline]
  pub fn add_AttackPower(&mut self, AttackPower: i64) {
    self.fbb_.push_slot::<i64>(MiniGameShootingCharacterExcel::VT_ATTACKPOWER, AttackPower, 0);
  }
  #[inline]
  pub fn add_DefensePower(&mut self, DefensePower: i64) {
    self.fbb_.push_slot::<i64>(MiniGameShootingCharacterExcel::VT_DEFENSEPOWER, DefensePower, 0);
  }
  #[inline]
  pub fn add_CriticalRate(&mut self, CriticalRate: i64) {
    self.fbb_.push_slot::<i64>(MiniGameShootingCharacterExcel::VT_CRITICALRATE, CriticalRate, 0);
  }
  #[inline]
  pub fn add_CriticalDamageRate(&mut self, CriticalDamageRate: i64) {
    self.fbb_.push_slot::<i64>(MiniGameShootingCharacterExcel::VT_CRITICALDAMAGERATE, CriticalDamageRate, 0);
  }
  #[inline]
  pub fn add_AttackRange(&mut self, AttackRange: i64) {
    self.fbb_.push_slot::<i64>(MiniGameShootingCharacterExcel::VT_ATTACKRANGE, AttackRange, 0);
  }
  #[inline]
  pub fn add_MoveSpeed(&mut self, MoveSpeed: i64) {
    self.fbb_.push_slot::<i64>(MiniGameShootingCharacterExcel::VT_MOVESPEED, MoveSpeed, 0);
  }
  #[inline]
  pub fn add_ShotTime(&mut self, ShotTime: i64) {
    self.fbb_.push_slot::<i64>(MiniGameShootingCharacterExcel::VT_SHOTTIME, ShotTime, 0);
  }
  #[inline]
  pub fn add_IsBoss(&mut self, IsBoss: bool) {
    self.fbb_.push_slot::<bool>(MiniGameShootingCharacterExcel::VT_ISBOSS, IsBoss, false);
  }
  #[inline]
  pub fn add_Scale(&mut self, Scale: f32) {
    self.fbb_.push_slot::<f32>(MiniGameShootingCharacterExcel::VT_SCALE, Scale, 0.0);
  }
  #[inline]
  pub fn add_IgnoreObstacleCheck(&mut self, IgnoreObstacleCheck: bool) {
    self.fbb_.push_slot::<bool>(MiniGameShootingCharacterExcel::VT_IGNOREOBSTACLECHECK, IgnoreObstacleCheck, false);
  }
  #[inline]
  pub fn add_CharacterVoiceGroupId(&mut self, CharacterVoiceGroupId: i64) {
    self.fbb_.push_slot::<i64>(MiniGameShootingCharacterExcel::VT_CHARACTERVOICEGROUPID, CharacterVoiceGroupId, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MiniGameShootingCharacterExcelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MiniGameShootingCharacterExcelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MiniGameShootingCharacterExcel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MiniGameShootingCharacterExcel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MiniGameShootingCharacterExcel");
      ds.field("UniqueId", &self.UniqueId());
      ds.field("SpineResourceName", &self.SpineResourceName());
      ds.field("BodyRadius", &self.BodyRadius());
      ds.field("ModelPrefabName", &self.ModelPrefabName());
      ds.field("NormalAttackSkillData", &self.NormalAttackSkillData());
      ds.field("PublicSkillData", &self.PublicSkillData());
      ds.field("DeathSkillData", &self.DeathSkillData());
      ds.field("MaxHP", &self.MaxHP());
      ds.field("AttackPower", &self.AttackPower());
      ds.field("DefensePower", &self.DefensePower());
      ds.field("CriticalRate", &self.CriticalRate());
      ds.field("CriticalDamageRate", &self.CriticalDamageRate());
      ds.field("AttackRange", &self.AttackRange());
      ds.field("MoveSpeed", &self.MoveSpeed());
      ds.field("ShotTime", &self.ShotTime());
      ds.field("IsBoss", &self.IsBoss());
      ds.field("Scale", &self.Scale());
      ds.field("IgnoreObstacleCheck", &self.IgnoreObstacleCheck());
      ds.field("CharacterVoiceGroupId", &self.CharacterVoiceGroupId());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MiniGameShootingCharacterExcelT {
  pub UniqueId: i64,
  pub SpineResourceName: Option<String>,
  pub BodyRadius: f32,
  pub ModelPrefabName: Option<String>,
  pub NormalAttackSkillData: Option<String>,
  pub PublicSkillData: Option<Vec<String>>,
  pub DeathSkillData: Option<String>,
  pub MaxHP: i64,
  pub AttackPower: i64,
  pub DefensePower: i64,
  pub CriticalRate: i64,
  pub CriticalDamageRate: i64,
  pub AttackRange: i64,
  pub MoveSpeed: i64,
  pub ShotTime: i64,
  pub IsBoss: bool,
  pub Scale: f32,
  pub IgnoreObstacleCheck: bool,
  pub CharacterVoiceGroupId: i64,
}
impl Default for MiniGameShootingCharacterExcelT {
  fn default() -> Self {
    Self {
      UniqueId: 0,
      SpineResourceName: None,
      BodyRadius: 0.0,
      ModelPrefabName: None,
      NormalAttackSkillData: None,
      PublicSkillData: None,
      DeathSkillData: None,
      MaxHP: 0,
      AttackPower: 0,
      DefensePower: 0,
      CriticalRate: 0,
      CriticalDamageRate: 0,
      AttackRange: 0,
      MoveSpeed: 0,
      ShotTime: 0,
      IsBoss: false,
      Scale: 0.0,
      IgnoreObstacleCheck: false,
      CharacterVoiceGroupId: 0,
    }
  }
}
impl MiniGameShootingCharacterExcelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<MiniGameShootingCharacterExcel<'b>> {
    let UniqueId = self.UniqueId;
    let SpineResourceName = self.SpineResourceName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let BodyRadius = self.BodyRadius;
    let ModelPrefabName = self.ModelPrefabName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let NormalAttackSkillData = self.NormalAttackSkillData.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PublicSkillData = self.PublicSkillData.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let DeathSkillData = self.DeathSkillData.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MaxHP = self.MaxHP;
    let AttackPower = self.AttackPower;
    let DefensePower = self.DefensePower;
    let CriticalRate = self.CriticalRate;
    let CriticalDamageRate = self.CriticalDamageRate;
    let AttackRange = self.AttackRange;
    let MoveSpeed = self.MoveSpeed;
    let ShotTime = self.ShotTime;
    let IsBoss = self.IsBoss;
    let Scale = self.Scale;
    let IgnoreObstacleCheck = self.IgnoreObstacleCheck;
    let CharacterVoiceGroupId = self.CharacterVoiceGroupId;
    MiniGameShootingCharacterExcel::create(_fbb, &MiniGameShootingCharacterExcelArgs{
      UniqueId,
      SpineResourceName,
      BodyRadius,
      ModelPrefabName,
      NormalAttackSkillData,
      PublicSkillData,
      DeathSkillData,
      MaxHP,
      AttackPower,
      DefensePower,
      CriticalRate,
      CriticalDamageRate,
      AttackRange,
      MoveSpeed,
      ShotTime,
      IsBoss,
      Scale,
      IgnoreObstacleCheck,
      CharacterVoiceGroupId,
    })
  }
}
