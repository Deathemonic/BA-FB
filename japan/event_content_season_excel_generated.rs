// automatically generated by the FlatBuffers compiler, do not modify
// @generated
#![allow(unused_imports, dead_code)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum EventContentSeasonExcelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EventContentSeasonExcel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EventContentSeasonExcel<'a> {
  type Inner = EventContentSeasonExcel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EventContentSeasonExcel<'a> {
  pub const VT_EVENTCONTENTID: flatbuffers::VOffsetT = 4;
  pub const VT_ORIGINALEVENTCONTENTID: flatbuffers::VOffsetT = 6;
  pub const VT_ISRETURN: flatbuffers::VOffsetT = 8;
  pub const VT_NAME: flatbuffers::VOffsetT = 10;
  pub const VT_EVENTCONTENTTYPE: flatbuffers::VOffsetT = 12;
  pub const VT_OPENCONDITIONCONTENT: flatbuffers::VOffsetT = 14;
  pub const VT_EVENTDISPLAY: flatbuffers::VOffsetT = 16;
  pub const VT_ICONORDER: flatbuffers::VOffsetT = 18;
  pub const VT_SUBEVENTTYPE: flatbuffers::VOffsetT = 20;
  pub const VT_SUBEVENT: flatbuffers::VOffsetT = 22;
  pub const VT_EVENTITEMID: flatbuffers::VOffsetT = 24;
  pub const VT_MAINEVENTID: flatbuffers::VOffsetT = 26;
  pub const VT_EVENTCHANGEOPENCONDITION: flatbuffers::VOffsetT = 28;
  pub const VT_BEFOREHANDEXPOSEDTIME: flatbuffers::VOffsetT = 30;
  pub const VT_EVENTCONTENTOPENTIME: flatbuffers::VOffsetT = 32;
  pub const VT_EVENTCONTENTCLOSENOTETIME: flatbuffers::VOffsetT = 34;
  pub const VT_EVENTCONTENTCLOSETIME: flatbuffers::VOffsetT = 36;
  pub const VT_EXTENSIONTIME: flatbuffers::VOffsetT = 38;
  pub const VT_MAINICONPARCELPATH: flatbuffers::VOffsetT = 40;
  pub const VT_SUBICONPARCELPATH: flatbuffers::VOffsetT = 42;
  pub const VT_BEFOREHANDBGIMAGEPATH: flatbuffers::VOffsetT = 44;
  pub const VT_MINIGAMEPROLOGSCENARIOGROUPID: flatbuffers::VOffsetT = 46;
  pub const VT_BEFOREHANDSCENARIOGROUPID: flatbuffers::VOffsetT = 48;
  pub const VT_MAINBANNERIMAGEPATH: flatbuffers::VOffsetT = 50;
  pub const VT_MAINBGIMAGEPATH: flatbuffers::VOffsetT = 52;
  pub const VT_SHIFTTRIGGERSTAGEID: flatbuffers::VOffsetT = 54;
  pub const VT_SHIFTMAINBGIMAGEPATH: flatbuffers::VOffsetT = 56;
  pub const VT_MINIGAMELOBBYPREFABNAME: flatbuffers::VOffsetT = 58;
  pub const VT_MINIGAMEVICTORYPREFABNAME: flatbuffers::VOffsetT = 60;
  pub const VT_MINIGAMEMISSIONBGPREFABNAME: flatbuffers::VOffsetT = 62;
  pub const VT_MINIGAMEMISSIONBGIMAGEPATH: flatbuffers::VOffsetT = 64;
  pub const VT_CARDBGIMAGEPATH: flatbuffers::VOffsetT = 66;
  pub const VT_EVENTASSIST: flatbuffers::VOffsetT = 68;
  pub const VT_EVENTCONTENTRELEASETYPE: flatbuffers::VOffsetT = 70;
  pub const VT_EVENTCONTENTSTAGEREWARDIDPERMANENT: flatbuffers::VOffsetT = 72;
  pub const VT_REWARDTAGPERMANENT: flatbuffers::VOffsetT = 74;
  pub const VT_MINIEVENTSHORTCUTSCENARIOMODEID: flatbuffers::VOffsetT = 76;
  pub const VT_SCENARIOCONTENTCOLLECTIONGROUPID: flatbuffers::VOffsetT = 78;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EventContentSeasonExcel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EventContentSeasonExcelArgs<'args>
  ) -> flatbuffers::WIPOffset<EventContentSeasonExcel<'bldr>> {
    let mut builder = EventContentSeasonExcelBuilder::new(_fbb);
    let key = table_encryption_service::create_key(b"EventContentSeason");
      let x = args.ScenarioContentCollectionGroupId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_ScenarioContentCollectionGroupId(x);
      let x = args.MiniEventShortCutScenarioModeId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_MiniEventShortCutScenarioModeId(x);
      let x = args.EventContentStageRewardIdPermanent;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_EventContentStageRewardIdPermanent(x);
      let x = args.ShiftTriggerStageId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_ShiftTriggerStageId(x);
      let x = args.MinigamePrologScenarioGroupId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_MinigamePrologScenarioGroupId(x);
      let x = args.EventChangeOpenCondition;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_EventChangeOpenCondition(x);
      let x = args.MainEventId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_MainEventId(x);
      let x = args.EventItemId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_EventItemId(x);
      let x = args.OriginalEventContentId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_OriginalEventContentId(x);
      let x = args.EventContentId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_EventContentId(x);
      let x = args.RewardTagPermanent;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_RewardTagPermanent(x);
      let x = args.EventContentReleaseType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_EventContentReleaseType(x);
      if let Some(x) = args.CardBgImagePath {
        builder.add_CardBgImagePath(x);
      }
      if let Some(x) = args.MinigameMissionBgImagePath {
        builder.add_MinigameMissionBgImagePath(x);
      }
      if let Some(x) = args.MinigameMissionBgPrefabName {
        builder.add_MinigameMissionBgPrefabName(x);
      }
      if let Some(x) = args.MinigameVictoryPrefabName {
        builder.add_MinigameVictoryPrefabName(x);
      }
      if let Some(x) = args.MinigameLobbyPrefabName {
        builder.add_MinigameLobbyPrefabName(x);
      }
      if let Some(x) = args.ShiftMainBgImagePath {
        builder.add_ShiftMainBgImagePath(x);
      }
      if let Some(x) = args.MainBgImagePath {
        builder.add_MainBgImagePath(x);
      }
      if let Some(x) = args.MainBannerImagePath {
        builder.add_MainBannerImagePath(x);
      }
      if let Some(x) = args.BeforehandScenarioGroupId {
        builder.add_BeforehandScenarioGroupId(x);
      }
      if let Some(x) = args.BeforehandBgImagePath {
        builder.add_BeforehandBgImagePath(x);
      }
      if let Some(x) = args.SubIconParcelPath {
        builder.add_SubIconParcelPath(x);
      }
      if let Some(x) = args.MainIconParcelPath {
        builder.add_MainIconParcelPath(x);
      }
      if let Some(x) = args.ExtensionTime {
        builder.add_ExtensionTime(x);
      }
      if let Some(x) = args.EventContentCloseTime {
        builder.add_EventContentCloseTime(x);
      }
      if let Some(x) = args.EventContentCloseNoteTime {
        builder.add_EventContentCloseNoteTime(x);
      }
      if let Some(x) = args.EventContentOpenTime {
        builder.add_EventContentOpenTime(x);
      }
      if let Some(x) = args.BeforehandExposedTime {
        builder.add_BeforehandExposedTime(x);
      }
      let x = args.SubEventType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_SubEventType(x);
      let x = args.IconOrder;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_IconOrder(x);
      let x = args.OpenConditionContent;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_OpenConditionContent(x);
      let x = args.EventContentType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_EventContentType(x);
      if let Some(x) = args.Name {
        builder.add_Name(x);
      }
      builder.add_EventAssist(args.EventAssist);
      builder.add_SubEvent(args.SubEvent);
      builder.add_EventDisplay(args.EventDisplay);
      builder.add_IsReturn(args.IsReturn);
    builder.finish()
  }

  pub fn unpack(&self) -> EventContentSeasonExcelT {
    let key = table_encryption_service::create_key(b"EventContentSeason");
      let EventContentId = self.EventContentId();
      let OriginalEventContentId = self.OriginalEventContentId();
      let IsReturn = self.IsReturn();
    let Name = self.Name().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let EventContentType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.EventContentType(), &key)
      } else {
        self.EventContentType()
      };
      let OpenConditionContent = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.OpenConditionContent(), &key)
      } else {
        self.OpenConditionContent()
      };
      let EventDisplay = self.EventDisplay();
      let IconOrder = self.IconOrder();
      let SubEventType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.SubEventType(), &key)
      } else {
        self.SubEventType()
      };
      let SubEvent = self.SubEvent();
      let EventItemId = self.EventItemId();
      let MainEventId = self.MainEventId();
      let EventChangeOpenCondition = self.EventChangeOpenCondition();
    let BeforehandExposedTime = self.BeforehandExposedTime().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let EventContentOpenTime = self.EventContentOpenTime().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let EventContentCloseNoteTime = self.EventContentCloseNoteTime().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let EventContentCloseTime = self.EventContentCloseTime().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let ExtensionTime = self.ExtensionTime().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let MainIconParcelPath = self.MainIconParcelPath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let SubIconParcelPath = self.SubIconParcelPath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let BeforehandBgImagePath = self.BeforehandBgImagePath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let MinigamePrologScenarioGroupId = self.MinigamePrologScenarioGroupId();
    let BeforehandScenarioGroupId = self.BeforehandScenarioGroupId().map(|x| {
      x.iter().map(|val| if table_encryption_service::use_encryption() { table_encryption_service::convert_long(*val, &key) } else { *val }).collect()
    });
    let MainBannerImagePath = self.MainBannerImagePath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let MainBgImagePath = self.MainBgImagePath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let ShiftTriggerStageId = self.ShiftTriggerStageId();
    let ShiftMainBgImagePath = self.ShiftMainBgImagePath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let MinigameLobbyPrefabName = self.MinigameLobbyPrefabName().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let MinigameVictoryPrefabName = self.MinigameVictoryPrefabName().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let MinigameMissionBgPrefabName = self.MinigameMissionBgPrefabName().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let MinigameMissionBgImagePath = self.MinigameMissionBgImagePath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let CardBgImagePath = self.CardBgImagePath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let EventAssist = self.EventAssist();
      let EventContentReleaseType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.EventContentReleaseType(), &key)
      } else {
        self.EventContentReleaseType()
      };
      let EventContentStageRewardIdPermanent = self.EventContentStageRewardIdPermanent();
      let RewardTagPermanent = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.RewardTagPermanent(), &key)
      } else {
        self.RewardTagPermanent()
      };
      let MiniEventShortCutScenarioModeId = self.MiniEventShortCutScenarioModeId();
      let ScenarioContentCollectionGroupId = self.ScenarioContentCollectionGroupId();
    EventContentSeasonExcelT {
      EventContentId,
      OriginalEventContentId,
      IsReturn,
      Name,
      EventContentType,
      OpenConditionContent,
      EventDisplay,
      IconOrder,
      SubEventType,
      SubEvent,
      EventItemId,
      MainEventId,
      EventChangeOpenCondition,
      BeforehandExposedTime,
      EventContentOpenTime,
      EventContentCloseNoteTime,
      EventContentCloseTime,
      ExtensionTime,
      MainIconParcelPath,
      SubIconParcelPath,
      BeforehandBgImagePath,
      MinigamePrologScenarioGroupId,
      BeforehandScenarioGroupId,
      MainBannerImagePath,
      MainBgImagePath,
      ShiftTriggerStageId,
      ShiftMainBgImagePath,
      MinigameLobbyPrefabName,
      MinigameVictoryPrefabName,
      MinigameMissionBgPrefabName,
      MinigameMissionBgImagePath,
      CardBgImagePath,
      EventAssist,
      EventContentReleaseType,
      EventContentStageRewardIdPermanent,
      RewardTagPermanent,
      MiniEventShortCutScenarioModeId,
      ScenarioContentCollectionGroupId,
    }
  }

  #[inline]
  pub fn EventContentId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(EventContentSeasonExcel::VT_EVENTCONTENTID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn OriginalEventContentId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(EventContentSeasonExcel::VT_ORIGINALEVENTCONTENTID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn IsReturn(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(EventContentSeasonExcel::VT_ISRETURN, Some(false)).unwrap()}
  }
  #[inline]
  pub fn Name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EventContentSeasonExcel::VT_NAME, None)}
  }
  #[inline]
  pub fn EventContentType(&self) -> EventContentType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<EventContentType>(EventContentSeasonExcel::VT_EVENTCONTENTTYPE, Some(EventContentType::Stage)).unwrap()}
  }
  #[inline]
  pub fn OpenConditionContent(&self) -> OpenConditionContent {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<OpenConditionContent>(EventContentSeasonExcel::VT_OPENCONDITIONCONTENT, Some(OpenConditionContent::Shop)).unwrap()}
  }
  #[inline]
  pub fn EventDisplay(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(EventContentSeasonExcel::VT_EVENTDISPLAY, Some(false)).unwrap()}
  }
  #[inline]
  pub fn IconOrder(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(EventContentSeasonExcel::VT_ICONORDER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn SubEventType(&self) -> SubEventType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SubEventType>(EventContentSeasonExcel::VT_SUBEVENTTYPE, Some(SubEventType::None)).unwrap()}
  }
  #[inline]
  pub fn SubEvent(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(EventContentSeasonExcel::VT_SUBEVENT, Some(false)).unwrap()}
  }
  #[inline]
  pub fn EventItemId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(EventContentSeasonExcel::VT_EVENTITEMID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn MainEventId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(EventContentSeasonExcel::VT_MAINEVENTID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EventChangeOpenCondition(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(EventContentSeasonExcel::VT_EVENTCHANGEOPENCONDITION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn BeforehandExposedTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EventContentSeasonExcel::VT_BEFOREHANDEXPOSEDTIME, None)}
  }
  #[inline]
  pub fn EventContentOpenTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EventContentSeasonExcel::VT_EVENTCONTENTOPENTIME, None)}
  }
  #[inline]
  pub fn EventContentCloseNoteTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EventContentSeasonExcel::VT_EVENTCONTENTCLOSENOTETIME, None)}
  }
  #[inline]
  pub fn EventContentCloseTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EventContentSeasonExcel::VT_EVENTCONTENTCLOSETIME, None)}
  }
  #[inline]
  pub fn ExtensionTime(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EventContentSeasonExcel::VT_EXTENSIONTIME, None)}
  }
  #[inline]
  pub fn MainIconParcelPath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EventContentSeasonExcel::VT_MAINICONPARCELPATH, None)}
  }
  #[inline]
  pub fn SubIconParcelPath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EventContentSeasonExcel::VT_SUBICONPARCELPATH, None)}
  }
  #[inline]
  pub fn BeforehandBgImagePath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EventContentSeasonExcel::VT_BEFOREHANDBGIMAGEPATH, None)}
  }
  #[inline]
  pub fn MinigamePrologScenarioGroupId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(EventContentSeasonExcel::VT_MINIGAMEPROLOGSCENARIOGROUPID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn BeforehandScenarioGroupId(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(EventContentSeasonExcel::VT_BEFOREHANDSCENARIOGROUPID, None)}
  }
  #[inline]
  pub fn MainBannerImagePath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EventContentSeasonExcel::VT_MAINBANNERIMAGEPATH, None)}
  }
  #[inline]
  pub fn MainBgImagePath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EventContentSeasonExcel::VT_MAINBGIMAGEPATH, None)}
  }
  #[inline]
  pub fn ShiftTriggerStageId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(EventContentSeasonExcel::VT_SHIFTTRIGGERSTAGEID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ShiftMainBgImagePath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EventContentSeasonExcel::VT_SHIFTMAINBGIMAGEPATH, None)}
  }
  #[inline]
  pub fn MinigameLobbyPrefabName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EventContentSeasonExcel::VT_MINIGAMELOBBYPREFABNAME, None)}
  }
  #[inline]
  pub fn MinigameVictoryPrefabName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EventContentSeasonExcel::VT_MINIGAMEVICTORYPREFABNAME, None)}
  }
  #[inline]
  pub fn MinigameMissionBgPrefabName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EventContentSeasonExcel::VT_MINIGAMEMISSIONBGPREFABNAME, None)}
  }
  #[inline]
  pub fn MinigameMissionBgImagePath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EventContentSeasonExcel::VT_MINIGAMEMISSIONBGIMAGEPATH, None)}
  }
  #[inline]
  pub fn CardBgImagePath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EventContentSeasonExcel::VT_CARDBGIMAGEPATH, None)}
  }
  #[inline]
  pub fn EventAssist(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(EventContentSeasonExcel::VT_EVENTASSIST, Some(false)).unwrap()}
  }
  #[inline]
  pub fn EventContentReleaseType(&self) -> EventContentReleaseType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<EventContentReleaseType>(EventContentSeasonExcel::VT_EVENTCONTENTRELEASETYPE, Some(EventContentReleaseType::None)).unwrap()}
  }
  #[inline]
  pub fn EventContentStageRewardIdPermanent(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(EventContentSeasonExcel::VT_EVENTCONTENTSTAGEREWARDIDPERMANENT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn RewardTagPermanent(&self) -> RewardTag {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<RewardTag>(EventContentSeasonExcel::VT_REWARDTAGPERMANENT, Some(RewardTag::Default)).unwrap()}
  }
  #[inline]
  pub fn MiniEventShortCutScenarioModeId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(EventContentSeasonExcel::VT_MINIEVENTSHORTCUTSCENARIOMODEID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ScenarioContentCollectionGroupId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(EventContentSeasonExcel::VT_SCENARIOCONTENTCOLLECTIONGROUPID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for EventContentSeasonExcel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("EventContentId", Self::VT_EVENTCONTENTID, false)?
     .visit_field::<i64>("OriginalEventContentId", Self::VT_ORIGINALEVENTCONTENTID, false)?
     .visit_field::<bool>("IsReturn", Self::VT_ISRETURN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("Name", Self::VT_NAME, false)?
     .visit_field::<EventContentType>("EventContentType", Self::VT_EVENTCONTENTTYPE, false)?
     .visit_field::<OpenConditionContent>("OpenConditionContent", Self::VT_OPENCONDITIONCONTENT, false)?
     .visit_field::<bool>("EventDisplay", Self::VT_EVENTDISPLAY, false)?
     .visit_field::<i32>("IconOrder", Self::VT_ICONORDER, false)?
     .visit_field::<SubEventType>("SubEventType", Self::VT_SUBEVENTTYPE, false)?
     .visit_field::<bool>("SubEvent", Self::VT_SUBEVENT, false)?
     .visit_field::<i64>("EventItemId", Self::VT_EVENTITEMID, false)?
     .visit_field::<i64>("MainEventId", Self::VT_MAINEVENTID, false)?
     .visit_field::<i64>("EventChangeOpenCondition", Self::VT_EVENTCHANGEOPENCONDITION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("BeforehandExposedTime", Self::VT_BEFOREHANDEXPOSEDTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EventContentOpenTime", Self::VT_EVENTCONTENTOPENTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EventContentCloseNoteTime", Self::VT_EVENTCONTENTCLOSENOTETIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EventContentCloseTime", Self::VT_EVENTCONTENTCLOSETIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ExtensionTime", Self::VT_EXTENSIONTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MainIconParcelPath", Self::VT_MAINICONPARCELPATH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SubIconParcelPath", Self::VT_SUBICONPARCELPATH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("BeforehandBgImagePath", Self::VT_BEFOREHANDBGIMAGEPATH, false)?
     .visit_field::<i64>("MinigamePrologScenarioGroupId", Self::VT_MINIGAMEPROLOGSCENARIOGROUPID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("BeforehandScenarioGroupId", Self::VT_BEFOREHANDSCENARIOGROUPID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MainBannerImagePath", Self::VT_MAINBANNERIMAGEPATH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MainBgImagePath", Self::VT_MAINBGIMAGEPATH, false)?
     .visit_field::<i64>("ShiftTriggerStageId", Self::VT_SHIFTTRIGGERSTAGEID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ShiftMainBgImagePath", Self::VT_SHIFTMAINBGIMAGEPATH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MinigameLobbyPrefabName", Self::VT_MINIGAMELOBBYPREFABNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MinigameVictoryPrefabName", Self::VT_MINIGAMEVICTORYPREFABNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MinigameMissionBgPrefabName", Self::VT_MINIGAMEMISSIONBGPREFABNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MinigameMissionBgImagePath", Self::VT_MINIGAMEMISSIONBGIMAGEPATH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CardBgImagePath", Self::VT_CARDBGIMAGEPATH, false)?
     .visit_field::<bool>("EventAssist", Self::VT_EVENTASSIST, false)?
     .visit_field::<EventContentReleaseType>("EventContentReleaseType", Self::VT_EVENTCONTENTRELEASETYPE, false)?
     .visit_field::<i64>("EventContentStageRewardIdPermanent", Self::VT_EVENTCONTENTSTAGEREWARDIDPERMANENT, false)?
     .visit_field::<RewardTag>("RewardTagPermanent", Self::VT_REWARDTAGPERMANENT, false)?
     .visit_field::<i64>("MiniEventShortCutScenarioModeId", Self::VT_MINIEVENTSHORTCUTSCENARIOMODEID, false)?
     .visit_field::<i64>("ScenarioContentCollectionGroupId", Self::VT_SCENARIOCONTENTCOLLECTIONGROUPID, false)?
     .finish();
    Ok(())
  }
}
pub struct EventContentSeasonExcelArgs<'a> {
    pub EventContentId: i64,
    pub OriginalEventContentId: i64,
    pub IsReturn: bool,
    pub Name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EventContentType: EventContentType,
    pub OpenConditionContent: OpenConditionContent,
    pub EventDisplay: bool,
    pub IconOrder: i32,
    pub SubEventType: SubEventType,
    pub SubEvent: bool,
    pub EventItemId: i64,
    pub MainEventId: i64,
    pub EventChangeOpenCondition: i64,
    pub BeforehandExposedTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EventContentOpenTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EventContentCloseNoteTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EventContentCloseTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ExtensionTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MainIconParcelPath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SubIconParcelPath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub BeforehandBgImagePath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MinigamePrologScenarioGroupId: i64,
    pub BeforehandScenarioGroupId: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub MainBannerImagePath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MainBgImagePath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ShiftTriggerStageId: i64,
    pub ShiftMainBgImagePath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MinigameLobbyPrefabName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MinigameVictoryPrefabName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MinigameMissionBgPrefabName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MinigameMissionBgImagePath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CardBgImagePath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EventAssist: bool,
    pub EventContentReleaseType: EventContentReleaseType,
    pub EventContentStageRewardIdPermanent: i64,
    pub RewardTagPermanent: RewardTag,
    pub MiniEventShortCutScenarioModeId: i64,
    pub ScenarioContentCollectionGroupId: i64,
}
impl<'a> Default for EventContentSeasonExcelArgs<'a> {
  #[inline]
  fn default() -> Self {
    EventContentSeasonExcelArgs {
      EventContentId: 0,
      OriginalEventContentId: 0,
      IsReturn: false,
      Name: None,
      EventContentType: EventContentType::Stage,
      OpenConditionContent: OpenConditionContent::Shop,
      EventDisplay: false,
      IconOrder: 0,
      SubEventType: SubEventType::None,
      SubEvent: false,
      EventItemId: 0,
      MainEventId: 0,
      EventChangeOpenCondition: 0,
      BeforehandExposedTime: None,
      EventContentOpenTime: None,
      EventContentCloseNoteTime: None,
      EventContentCloseTime: None,
      ExtensionTime: None,
      MainIconParcelPath: None,
      SubIconParcelPath: None,
      BeforehandBgImagePath: None,
      MinigamePrologScenarioGroupId: 0,
      BeforehandScenarioGroupId: None,
      MainBannerImagePath: None,
      MainBgImagePath: None,
      ShiftTriggerStageId: 0,
      ShiftMainBgImagePath: None,
      MinigameLobbyPrefabName: None,
      MinigameVictoryPrefabName: None,
      MinigameMissionBgPrefabName: None,
      MinigameMissionBgImagePath: None,
      CardBgImagePath: None,
      EventAssist: false,
      EventContentReleaseType: EventContentReleaseType::None,
      EventContentStageRewardIdPermanent: 0,
      RewardTagPermanent: RewardTag::Default,
      MiniEventShortCutScenarioModeId: 0,
      ScenarioContentCollectionGroupId: 0,
    }
  }
}

impl Serialize for EventContentSeasonExcel<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("EventContentSeasonExcel", 38)?;
      s.serialize_field("EventContentId", &self.EventContentId())?;
      s.serialize_field("OriginalEventContentId", &self.OriginalEventContentId())?;
      s.serialize_field("IsReturn", &self.IsReturn())?;
      if let Some(f) = self.Name() {
        s.serialize_field("Name", &f)?;
      } else {
        s.skip_field("Name")?;
      }
      s.serialize_field("EventContentType", &self.EventContentType())?;
      s.serialize_field("OpenConditionContent", &self.OpenConditionContent())?;
      s.serialize_field("EventDisplay", &self.EventDisplay())?;
      s.serialize_field("IconOrder", &self.IconOrder())?;
      s.serialize_field("SubEventType", &self.SubEventType())?;
      s.serialize_field("SubEvent", &self.SubEvent())?;
      s.serialize_field("EventItemId", &self.EventItemId())?;
      s.serialize_field("MainEventId", &self.MainEventId())?;
      s.serialize_field("EventChangeOpenCondition", &self.EventChangeOpenCondition())?;
      if let Some(f) = self.BeforehandExposedTime() {
        s.serialize_field("BeforehandExposedTime", &f)?;
      } else {
        s.skip_field("BeforehandExposedTime")?;
      }
      if let Some(f) = self.EventContentOpenTime() {
        s.serialize_field("EventContentOpenTime", &f)?;
      } else {
        s.skip_field("EventContentOpenTime")?;
      }
      if let Some(f) = self.EventContentCloseNoteTime() {
        s.serialize_field("EventContentCloseNoteTime", &f)?;
      } else {
        s.skip_field("EventContentCloseNoteTime")?;
      }
      if let Some(f) = self.EventContentCloseTime() {
        s.serialize_field("EventContentCloseTime", &f)?;
      } else {
        s.skip_field("EventContentCloseTime")?;
      }
      if let Some(f) = self.ExtensionTime() {
        s.serialize_field("ExtensionTime", &f)?;
      } else {
        s.skip_field("ExtensionTime")?;
      }
      if let Some(f) = self.MainIconParcelPath() {
        s.serialize_field("MainIconParcelPath", &f)?;
      } else {
        s.skip_field("MainIconParcelPath")?;
      }
      if let Some(f) = self.SubIconParcelPath() {
        s.serialize_field("SubIconParcelPath", &f)?;
      } else {
        s.skip_field("SubIconParcelPath")?;
      }
      if let Some(f) = self.BeforehandBgImagePath() {
        s.serialize_field("BeforehandBgImagePath", &f)?;
      } else {
        s.skip_field("BeforehandBgImagePath")?;
      }
      s.serialize_field("MinigamePrologScenarioGroupId", &self.MinigamePrologScenarioGroupId())?;
      if let Some(f) = self.BeforehandScenarioGroupId() {
        s.serialize_field("BeforehandScenarioGroupId", &f)?;
      } else {
        s.skip_field("BeforehandScenarioGroupId")?;
      }
      if let Some(f) = self.MainBannerImagePath() {
        s.serialize_field("MainBannerImagePath", &f)?;
      } else {
        s.skip_field("MainBannerImagePath")?;
      }
      if let Some(f) = self.MainBgImagePath() {
        s.serialize_field("MainBgImagePath", &f)?;
      } else {
        s.skip_field("MainBgImagePath")?;
      }
      s.serialize_field("ShiftTriggerStageId", &self.ShiftTriggerStageId())?;
      if let Some(f) = self.ShiftMainBgImagePath() {
        s.serialize_field("ShiftMainBgImagePath", &f)?;
      } else {
        s.skip_field("ShiftMainBgImagePath")?;
      }
      if let Some(f) = self.MinigameLobbyPrefabName() {
        s.serialize_field("MinigameLobbyPrefabName", &f)?;
      } else {
        s.skip_field("MinigameLobbyPrefabName")?;
      }
      if let Some(f) = self.MinigameVictoryPrefabName() {
        s.serialize_field("MinigameVictoryPrefabName", &f)?;
      } else {
        s.skip_field("MinigameVictoryPrefabName")?;
      }
      if let Some(f) = self.MinigameMissionBgPrefabName() {
        s.serialize_field("MinigameMissionBgPrefabName", &f)?;
      } else {
        s.skip_field("MinigameMissionBgPrefabName")?;
      }
      if let Some(f) = self.MinigameMissionBgImagePath() {
        s.serialize_field("MinigameMissionBgImagePath", &f)?;
      } else {
        s.skip_field("MinigameMissionBgImagePath")?;
      }
      if let Some(f) = self.CardBgImagePath() {
        s.serialize_field("CardBgImagePath", &f)?;
      } else {
        s.skip_field("CardBgImagePath")?;
      }
      s.serialize_field("EventAssist", &self.EventAssist())?;
      s.serialize_field("EventContentReleaseType", &self.EventContentReleaseType())?;
      s.serialize_field("EventContentStageRewardIdPermanent", &self.EventContentStageRewardIdPermanent())?;
      s.serialize_field("RewardTagPermanent", &self.RewardTagPermanent())?;
      s.serialize_field("MiniEventShortCutScenarioModeId", &self.MiniEventShortCutScenarioModeId())?;
      s.serialize_field("ScenarioContentCollectionGroupId", &self.ScenarioContentCollectionGroupId())?;
    s.end()
  }
}

pub struct EventContentSeasonExcelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EventContentSeasonExcelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_EventContentId(&mut self, EventContentId: i64) {
    self.fbb_.push_slot::<i64>(EventContentSeasonExcel::VT_EVENTCONTENTID, EventContentId, 0);
  }
  #[inline]
  pub fn add_OriginalEventContentId(&mut self, OriginalEventContentId: i64) {
    self.fbb_.push_slot::<i64>(EventContentSeasonExcel::VT_ORIGINALEVENTCONTENTID, OriginalEventContentId, 0);
  }
  #[inline]
  pub fn add_IsReturn(&mut self, IsReturn: bool) {
    self.fbb_.push_slot::<bool>(EventContentSeasonExcel::VT_ISRETURN, IsReturn, false);
  }
  #[inline]
  pub fn add_Name(&mut self, Name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EventContentSeasonExcel::VT_NAME, Name);
  }
  #[inline]
  pub fn add_EventContentType(&mut self, EventContentType: EventContentType) {
    self.fbb_.push_slot::<EventContentType>(EventContentSeasonExcel::VT_EVENTCONTENTTYPE, EventContentType, EventContentType::Stage);
  }
  #[inline]
  pub fn add_OpenConditionContent(&mut self, OpenConditionContent: OpenConditionContent) {
    self.fbb_.push_slot::<OpenConditionContent>(EventContentSeasonExcel::VT_OPENCONDITIONCONTENT, OpenConditionContent, OpenConditionContent::Shop);
  }
  #[inline]
  pub fn add_EventDisplay(&mut self, EventDisplay: bool) {
    self.fbb_.push_slot::<bool>(EventContentSeasonExcel::VT_EVENTDISPLAY, EventDisplay, false);
  }
  #[inline]
  pub fn add_IconOrder(&mut self, IconOrder: i32) {
    self.fbb_.push_slot::<i32>(EventContentSeasonExcel::VT_ICONORDER, IconOrder, 0);
  }
  #[inline]
  pub fn add_SubEventType(&mut self, SubEventType: SubEventType) {
    self.fbb_.push_slot::<SubEventType>(EventContentSeasonExcel::VT_SUBEVENTTYPE, SubEventType, SubEventType::None);
  }
  #[inline]
  pub fn add_SubEvent(&mut self, SubEvent: bool) {
    self.fbb_.push_slot::<bool>(EventContentSeasonExcel::VT_SUBEVENT, SubEvent, false);
  }
  #[inline]
  pub fn add_EventItemId(&mut self, EventItemId: i64) {
    self.fbb_.push_slot::<i64>(EventContentSeasonExcel::VT_EVENTITEMID, EventItemId, 0);
  }
  #[inline]
  pub fn add_MainEventId(&mut self, MainEventId: i64) {
    self.fbb_.push_slot::<i64>(EventContentSeasonExcel::VT_MAINEVENTID, MainEventId, 0);
  }
  #[inline]
  pub fn add_EventChangeOpenCondition(&mut self, EventChangeOpenCondition: i64) {
    self.fbb_.push_slot::<i64>(EventContentSeasonExcel::VT_EVENTCHANGEOPENCONDITION, EventChangeOpenCondition, 0);
  }
  #[inline]
  pub fn add_BeforehandExposedTime(&mut self, BeforehandExposedTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EventContentSeasonExcel::VT_BEFOREHANDEXPOSEDTIME, BeforehandExposedTime);
  }
  #[inline]
  pub fn add_EventContentOpenTime(&mut self, EventContentOpenTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EventContentSeasonExcel::VT_EVENTCONTENTOPENTIME, EventContentOpenTime);
  }
  #[inline]
  pub fn add_EventContentCloseNoteTime(&mut self, EventContentCloseNoteTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EventContentSeasonExcel::VT_EVENTCONTENTCLOSENOTETIME, EventContentCloseNoteTime);
  }
  #[inline]
  pub fn add_EventContentCloseTime(&mut self, EventContentCloseTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EventContentSeasonExcel::VT_EVENTCONTENTCLOSETIME, EventContentCloseTime);
  }
  #[inline]
  pub fn add_ExtensionTime(&mut self, ExtensionTime: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EventContentSeasonExcel::VT_EXTENSIONTIME, ExtensionTime);
  }
  #[inline]
  pub fn add_MainIconParcelPath(&mut self, MainIconParcelPath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EventContentSeasonExcel::VT_MAINICONPARCELPATH, MainIconParcelPath);
  }
  #[inline]
  pub fn add_SubIconParcelPath(&mut self, SubIconParcelPath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EventContentSeasonExcel::VT_SUBICONPARCELPATH, SubIconParcelPath);
  }
  #[inline]
  pub fn add_BeforehandBgImagePath(&mut self, BeforehandBgImagePath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EventContentSeasonExcel::VT_BEFOREHANDBGIMAGEPATH, BeforehandBgImagePath);
  }
  #[inline]
  pub fn add_MinigamePrologScenarioGroupId(&mut self, MinigamePrologScenarioGroupId: i64) {
    self.fbb_.push_slot::<i64>(EventContentSeasonExcel::VT_MINIGAMEPROLOGSCENARIOGROUPID, MinigamePrologScenarioGroupId, 0);
  }
  #[inline]
  pub fn add_BeforehandScenarioGroupId(&mut self, BeforehandScenarioGroupId: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EventContentSeasonExcel::VT_BEFOREHANDSCENARIOGROUPID, BeforehandScenarioGroupId);
  }
  #[inline]
  pub fn add_MainBannerImagePath(&mut self, MainBannerImagePath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EventContentSeasonExcel::VT_MAINBANNERIMAGEPATH, MainBannerImagePath);
  }
  #[inline]
  pub fn add_MainBgImagePath(&mut self, MainBgImagePath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EventContentSeasonExcel::VT_MAINBGIMAGEPATH, MainBgImagePath);
  }
  #[inline]
  pub fn add_ShiftTriggerStageId(&mut self, ShiftTriggerStageId: i64) {
    self.fbb_.push_slot::<i64>(EventContentSeasonExcel::VT_SHIFTTRIGGERSTAGEID, ShiftTriggerStageId, 0);
  }
  #[inline]
  pub fn add_ShiftMainBgImagePath(&mut self, ShiftMainBgImagePath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EventContentSeasonExcel::VT_SHIFTMAINBGIMAGEPATH, ShiftMainBgImagePath);
  }
  #[inline]
  pub fn add_MinigameLobbyPrefabName(&mut self, MinigameLobbyPrefabName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EventContentSeasonExcel::VT_MINIGAMELOBBYPREFABNAME, MinigameLobbyPrefabName);
  }
  #[inline]
  pub fn add_MinigameVictoryPrefabName(&mut self, MinigameVictoryPrefabName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EventContentSeasonExcel::VT_MINIGAMEVICTORYPREFABNAME, MinigameVictoryPrefabName);
  }
  #[inline]
  pub fn add_MinigameMissionBgPrefabName(&mut self, MinigameMissionBgPrefabName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EventContentSeasonExcel::VT_MINIGAMEMISSIONBGPREFABNAME, MinigameMissionBgPrefabName);
  }
  #[inline]
  pub fn add_MinigameMissionBgImagePath(&mut self, MinigameMissionBgImagePath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EventContentSeasonExcel::VT_MINIGAMEMISSIONBGIMAGEPATH, MinigameMissionBgImagePath);
  }
  #[inline]
  pub fn add_CardBgImagePath(&mut self, CardBgImagePath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EventContentSeasonExcel::VT_CARDBGIMAGEPATH, CardBgImagePath);
  }
  #[inline]
  pub fn add_EventAssist(&mut self, EventAssist: bool) {
    self.fbb_.push_slot::<bool>(EventContentSeasonExcel::VT_EVENTASSIST, EventAssist, false);
  }
  #[inline]
  pub fn add_EventContentReleaseType(&mut self, EventContentReleaseType: EventContentReleaseType) {
    self.fbb_.push_slot::<EventContentReleaseType>(EventContentSeasonExcel::VT_EVENTCONTENTRELEASETYPE, EventContentReleaseType, EventContentReleaseType::None);
  }
  #[inline]
  pub fn add_EventContentStageRewardIdPermanent(&mut self, EventContentStageRewardIdPermanent: i64) {
    self.fbb_.push_slot::<i64>(EventContentSeasonExcel::VT_EVENTCONTENTSTAGEREWARDIDPERMANENT, EventContentStageRewardIdPermanent, 0);
  }
  #[inline]
  pub fn add_RewardTagPermanent(&mut self, RewardTagPermanent: RewardTag) {
    self.fbb_.push_slot::<RewardTag>(EventContentSeasonExcel::VT_REWARDTAGPERMANENT, RewardTagPermanent, RewardTag::Default);
  }
  #[inline]
  pub fn add_MiniEventShortCutScenarioModeId(&mut self, MiniEventShortCutScenarioModeId: i64) {
    self.fbb_.push_slot::<i64>(EventContentSeasonExcel::VT_MINIEVENTSHORTCUTSCENARIOMODEID, MiniEventShortCutScenarioModeId, 0);
  }
  #[inline]
  pub fn add_ScenarioContentCollectionGroupId(&mut self, ScenarioContentCollectionGroupId: i64) {
    self.fbb_.push_slot::<i64>(EventContentSeasonExcel::VT_SCENARIOCONTENTCOLLECTIONGROUPID, ScenarioContentCollectionGroupId, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EventContentSeasonExcelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EventContentSeasonExcelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EventContentSeasonExcel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EventContentSeasonExcel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EventContentSeasonExcel");
      ds.field("EventContentId", &self.EventContentId());
      ds.field("OriginalEventContentId", &self.OriginalEventContentId());
      ds.field("IsReturn", &self.IsReturn());
      ds.field("Name", &self.Name());
      ds.field("EventContentType", &self.EventContentType());
      ds.field("OpenConditionContent", &self.OpenConditionContent());
      ds.field("EventDisplay", &self.EventDisplay());
      ds.field("IconOrder", &self.IconOrder());
      ds.field("SubEventType", &self.SubEventType());
      ds.field("SubEvent", &self.SubEvent());
      ds.field("EventItemId", &self.EventItemId());
      ds.field("MainEventId", &self.MainEventId());
      ds.field("EventChangeOpenCondition", &self.EventChangeOpenCondition());
      ds.field("BeforehandExposedTime", &self.BeforehandExposedTime());
      ds.field("EventContentOpenTime", &self.EventContentOpenTime());
      ds.field("EventContentCloseNoteTime", &self.EventContentCloseNoteTime());
      ds.field("EventContentCloseTime", &self.EventContentCloseTime());
      ds.field("ExtensionTime", &self.ExtensionTime());
      ds.field("MainIconParcelPath", &self.MainIconParcelPath());
      ds.field("SubIconParcelPath", &self.SubIconParcelPath());
      ds.field("BeforehandBgImagePath", &self.BeforehandBgImagePath());
      ds.field("MinigamePrologScenarioGroupId", &self.MinigamePrologScenarioGroupId());
      ds.field("BeforehandScenarioGroupId", &self.BeforehandScenarioGroupId());
      ds.field("MainBannerImagePath", &self.MainBannerImagePath());
      ds.field("MainBgImagePath", &self.MainBgImagePath());
      ds.field("ShiftTriggerStageId", &self.ShiftTriggerStageId());
      ds.field("ShiftMainBgImagePath", &self.ShiftMainBgImagePath());
      ds.field("MinigameLobbyPrefabName", &self.MinigameLobbyPrefabName());
      ds.field("MinigameVictoryPrefabName", &self.MinigameVictoryPrefabName());
      ds.field("MinigameMissionBgPrefabName", &self.MinigameMissionBgPrefabName());
      ds.field("MinigameMissionBgImagePath", &self.MinigameMissionBgImagePath());
      ds.field("CardBgImagePath", &self.CardBgImagePath());
      ds.field("EventAssist", &self.EventAssist());
      ds.field("EventContentReleaseType", &self.EventContentReleaseType());
      ds.field("EventContentStageRewardIdPermanent", &self.EventContentStageRewardIdPermanent());
      ds.field("RewardTagPermanent", &self.RewardTagPermanent());
      ds.field("MiniEventShortCutScenarioModeId", &self.MiniEventShortCutScenarioModeId());
      ds.field("ScenarioContentCollectionGroupId", &self.ScenarioContentCollectionGroupId());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct EventContentSeasonExcelT {
  pub EventContentId: i64,
  pub OriginalEventContentId: i64,
  pub IsReturn: bool,
  pub Name: Option<String>,
  pub EventContentType: EventContentType,
  pub OpenConditionContent: OpenConditionContent,
  pub EventDisplay: bool,
  pub IconOrder: i32,
  pub SubEventType: SubEventType,
  pub SubEvent: bool,
  pub EventItemId: i64,
  pub MainEventId: i64,
  pub EventChangeOpenCondition: i64,
  pub BeforehandExposedTime: Option<String>,
  pub EventContentOpenTime: Option<String>,
  pub EventContentCloseNoteTime: Option<String>,
  pub EventContentCloseTime: Option<String>,
  pub ExtensionTime: Option<String>,
  pub MainIconParcelPath: Option<String>,
  pub SubIconParcelPath: Option<String>,
  pub BeforehandBgImagePath: Option<String>,
  pub MinigamePrologScenarioGroupId: i64,
  pub BeforehandScenarioGroupId: Option<Vec<i64>>,
  pub MainBannerImagePath: Option<String>,
  pub MainBgImagePath: Option<String>,
  pub ShiftTriggerStageId: i64,
  pub ShiftMainBgImagePath: Option<String>,
  pub MinigameLobbyPrefabName: Option<String>,
  pub MinigameVictoryPrefabName: Option<String>,
  pub MinigameMissionBgPrefabName: Option<String>,
  pub MinigameMissionBgImagePath: Option<String>,
  pub CardBgImagePath: Option<String>,
  pub EventAssist: bool,
  pub EventContentReleaseType: EventContentReleaseType,
  pub EventContentStageRewardIdPermanent: i64,
  pub RewardTagPermanent: RewardTag,
  pub MiniEventShortCutScenarioModeId: i64,
  pub ScenarioContentCollectionGroupId: i64,
}
impl Default for EventContentSeasonExcelT {
  fn default() -> Self {
    Self {
      EventContentId: 0,
      OriginalEventContentId: 0,
      IsReturn: false,
      Name: None,
      EventContentType: EventContentType::Stage,
      OpenConditionContent: OpenConditionContent::Shop,
      EventDisplay: false,
      IconOrder: 0,
      SubEventType: SubEventType::None,
      SubEvent: false,
      EventItemId: 0,
      MainEventId: 0,
      EventChangeOpenCondition: 0,
      BeforehandExposedTime: None,
      EventContentOpenTime: None,
      EventContentCloseNoteTime: None,
      EventContentCloseTime: None,
      ExtensionTime: None,
      MainIconParcelPath: None,
      SubIconParcelPath: None,
      BeforehandBgImagePath: None,
      MinigamePrologScenarioGroupId: 0,
      BeforehandScenarioGroupId: None,
      MainBannerImagePath: None,
      MainBgImagePath: None,
      ShiftTriggerStageId: 0,
      ShiftMainBgImagePath: None,
      MinigameLobbyPrefabName: None,
      MinigameVictoryPrefabName: None,
      MinigameMissionBgPrefabName: None,
      MinigameMissionBgImagePath: None,
      CardBgImagePath: None,
      EventAssist: false,
      EventContentReleaseType: EventContentReleaseType::None,
      EventContentStageRewardIdPermanent: 0,
      RewardTagPermanent: RewardTag::Default,
      MiniEventShortCutScenarioModeId: 0,
      ScenarioContentCollectionGroupId: 0,
    }
  }
}
impl EventContentSeasonExcelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<EventContentSeasonExcel<'b>> {
    let EventContentId = self.EventContentId;
    let OriginalEventContentId = self.OriginalEventContentId;
    let IsReturn = self.IsReturn;
    let Name = self.Name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EventContentType = self.EventContentType;
    let OpenConditionContent = self.OpenConditionContent;
    let EventDisplay = self.EventDisplay;
    let IconOrder = self.IconOrder;
    let SubEventType = self.SubEventType;
    let SubEvent = self.SubEvent;
    let EventItemId = self.EventItemId;
    let MainEventId = self.MainEventId;
    let EventChangeOpenCondition = self.EventChangeOpenCondition;
    let BeforehandExposedTime = self.BeforehandExposedTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EventContentOpenTime = self.EventContentOpenTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EventContentCloseNoteTime = self.EventContentCloseNoteTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EventContentCloseTime = self.EventContentCloseTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ExtensionTime = self.ExtensionTime.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MainIconParcelPath = self.MainIconParcelPath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SubIconParcelPath = self.SubIconParcelPath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let BeforehandBgImagePath = self.BeforehandBgImagePath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MinigamePrologScenarioGroupId = self.MinigamePrologScenarioGroupId;
    let BeforehandScenarioGroupId = self.BeforehandScenarioGroupId.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let MainBannerImagePath = self.MainBannerImagePath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MainBgImagePath = self.MainBgImagePath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ShiftTriggerStageId = self.ShiftTriggerStageId;
    let ShiftMainBgImagePath = self.ShiftMainBgImagePath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MinigameLobbyPrefabName = self.MinigameLobbyPrefabName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MinigameVictoryPrefabName = self.MinigameVictoryPrefabName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MinigameMissionBgPrefabName = self.MinigameMissionBgPrefabName.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MinigameMissionBgImagePath = self.MinigameMissionBgImagePath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CardBgImagePath = self.CardBgImagePath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EventAssist = self.EventAssist;
    let EventContentReleaseType = self.EventContentReleaseType;
    let EventContentStageRewardIdPermanent = self.EventContentStageRewardIdPermanent;
    let RewardTagPermanent = self.RewardTagPermanent;
    let MiniEventShortCutScenarioModeId = self.MiniEventShortCutScenarioModeId;
    let ScenarioContentCollectionGroupId = self.ScenarioContentCollectionGroupId;
    EventContentSeasonExcel::create(_fbb, &EventContentSeasonExcelArgs{
      EventContentId,
      OriginalEventContentId,
      IsReturn,
      Name,
      EventContentType,
      OpenConditionContent,
      EventDisplay,
      IconOrder,
      SubEventType,
      SubEvent,
      EventItemId,
      MainEventId,
      EventChangeOpenCondition,
      BeforehandExposedTime,
      EventContentOpenTime,
      EventContentCloseNoteTime,
      EventContentCloseTime,
      ExtensionTime,
      MainIconParcelPath,
      SubIconParcelPath,
      BeforehandBgImagePath,
      MinigamePrologScenarioGroupId,
      BeforehandScenarioGroupId,
      MainBannerImagePath,
      MainBgImagePath,
      ShiftTriggerStageId,
      ShiftMainBgImagePath,
      MinigameLobbyPrefabName,
      MinigameVictoryPrefabName,
      MinigameMissionBgPrefabName,
      MinigameMissionBgImagePath,
      CardBgImagePath,
      EventAssist,
      EventContentReleaseType,
      EventContentStageRewardIdPermanent,
      RewardTagPermanent,
      MiniEventShortCutScenarioModeId,
      ScenarioContentCollectionGroupId,
    })
  }
}
