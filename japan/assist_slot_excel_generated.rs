// automatically generated by the FlatBuffers compiler, do not modify
// @generated
#![allow(unused_imports, dead_code)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum AssistSlotExcelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AssistSlotExcel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AssistSlotExcel<'a> {
  type Inner = AssistSlotExcel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AssistSlotExcel<'a> {
  pub const VT_SLOTID: flatbuffers::VOffsetT = 4;
  pub const VT_ECHELONTYPE: flatbuffers::VOffsetT = 6;
  pub const VT_SLOTNUMBER: flatbuffers::VOffsetT = 8;
  pub const VT_ASSISTTERMREWARDPERIODFROMSEC: flatbuffers::VOffsetT = 10;
  pub const VT_ASSISTREWARDLIMIT: flatbuffers::VOffsetT = 12;
  pub const VT_ASSISTRENTREWARDDAILYMAXCOUNT: flatbuffers::VOffsetT = 14;
  pub const VT_ASSISTRENTALFEEAMOUNT: flatbuffers::VOffsetT = 16;
  pub const VT_ASSISTRENTALFEEAMOUNTSTRANGER: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AssistSlotExcel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AssistSlotExcelArgs
  ) -> flatbuffers::WIPOffset<AssistSlotExcel<'bldr>> {
    let mut builder = AssistSlotExcelBuilder::new(_fbb);
    let key = table_encryption_service::create_key(b"AssistSlot");
      let x = args.AssistRentalFeeAmountStranger;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_AssistRentalFeeAmountStranger(x);
      let x = args.AssistRentalFeeAmount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_AssistRentalFeeAmount(x);
      let x = args.AssistRentRewardDailyMaxCount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_AssistRentRewardDailyMaxCount(x);
      let x = args.AssistRewardLimit;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_AssistRewardLimit(x);
      let x = args.AssistTermRewardPeriodFromSec;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_AssistTermRewardPeriodFromSec(x);
      let x = args.SlotNumber;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_SlotNumber(x);
      let x = args.SlotId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_SlotId(x);
      let x = args.EchelonType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_EchelonType(x);
    builder.finish()
  }

  pub fn unpack(&self) -> AssistSlotExcelT {
    let key = table_encryption_service::create_key(b"AssistSlot");
      let SlotId = self.SlotId();
      let EchelonType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.EchelonType(), &key)
      } else {
        self.EchelonType()
      };
      let SlotNumber = self.SlotNumber();
      let AssistTermRewardPeriodFromSec = self.AssistTermRewardPeriodFromSec();
      let AssistRewardLimit = self.AssistRewardLimit();
      let AssistRentRewardDailyMaxCount = self.AssistRentRewardDailyMaxCount();
      let AssistRentalFeeAmount = self.AssistRentalFeeAmount();
      let AssistRentalFeeAmountStranger = self.AssistRentalFeeAmountStranger();
    AssistSlotExcelT {
      SlotId,
      EchelonType,
      SlotNumber,
      AssistTermRewardPeriodFromSec,
      AssistRewardLimit,
      AssistRentRewardDailyMaxCount,
      AssistRentalFeeAmount,
      AssistRentalFeeAmountStranger,
    }
  }

  #[inline]
  pub fn SlotId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(AssistSlotExcel::VT_SLOTID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EchelonType(&self) -> EchelonType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<EchelonType>(AssistSlotExcel::VT_ECHELONTYPE, Some(EchelonType::None)).unwrap()}
  }
  #[inline]
  pub fn SlotNumber(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(AssistSlotExcel::VT_SLOTNUMBER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn AssistTermRewardPeriodFromSec(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(AssistSlotExcel::VT_ASSISTTERMREWARDPERIODFROMSEC, Some(0)).unwrap()}
  }
  #[inline]
  pub fn AssistRewardLimit(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(AssistSlotExcel::VT_ASSISTREWARDLIMIT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn AssistRentRewardDailyMaxCount(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(AssistSlotExcel::VT_ASSISTRENTREWARDDAILYMAXCOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn AssistRentalFeeAmount(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(AssistSlotExcel::VT_ASSISTRENTALFEEAMOUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn AssistRentalFeeAmountStranger(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(AssistSlotExcel::VT_ASSISTRENTALFEEAMOUNTSTRANGER, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for AssistSlotExcel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("SlotId", Self::VT_SLOTID, false)?
     .visit_field::<EchelonType>("EchelonType", Self::VT_ECHELONTYPE, false)?
     .visit_field::<i64>("SlotNumber", Self::VT_SLOTNUMBER, false)?
     .visit_field::<i64>("AssistTermRewardPeriodFromSec", Self::VT_ASSISTTERMREWARDPERIODFROMSEC, false)?
     .visit_field::<i64>("AssistRewardLimit", Self::VT_ASSISTREWARDLIMIT, false)?
     .visit_field::<i64>("AssistRentRewardDailyMaxCount", Self::VT_ASSISTRENTREWARDDAILYMAXCOUNT, false)?
     .visit_field::<i64>("AssistRentalFeeAmount", Self::VT_ASSISTRENTALFEEAMOUNT, false)?
     .visit_field::<i64>("AssistRentalFeeAmountStranger", Self::VT_ASSISTRENTALFEEAMOUNTSTRANGER, false)?
     .finish();
    Ok(())
  }
}
pub struct AssistSlotExcelArgs {
    pub SlotId: i64,
    pub EchelonType: EchelonType,
    pub SlotNumber: i64,
    pub AssistTermRewardPeriodFromSec: i64,
    pub AssistRewardLimit: i64,
    pub AssistRentRewardDailyMaxCount: i64,
    pub AssistRentalFeeAmount: i64,
    pub AssistRentalFeeAmountStranger: i64,
}
impl<'a> Default for AssistSlotExcelArgs {
  #[inline]
  fn default() -> Self {
    AssistSlotExcelArgs {
      SlotId: 0,
      EchelonType: EchelonType::None,
      SlotNumber: 0,
      AssistTermRewardPeriodFromSec: 0,
      AssistRewardLimit: 0,
      AssistRentRewardDailyMaxCount: 0,
      AssistRentalFeeAmount: 0,
      AssistRentalFeeAmountStranger: 0,
    }
  }
}

impl Serialize for AssistSlotExcel<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("AssistSlotExcel", 8)?;
      s.serialize_field("SlotId", &self.SlotId())?;
      s.serialize_field("EchelonType", &self.EchelonType())?;
      s.serialize_field("SlotNumber", &self.SlotNumber())?;
      s.serialize_field("AssistTermRewardPeriodFromSec", &self.AssistTermRewardPeriodFromSec())?;
      s.serialize_field("AssistRewardLimit", &self.AssistRewardLimit())?;
      s.serialize_field("AssistRentRewardDailyMaxCount", &self.AssistRentRewardDailyMaxCount())?;
      s.serialize_field("AssistRentalFeeAmount", &self.AssistRentalFeeAmount())?;
      s.serialize_field("AssistRentalFeeAmountStranger", &self.AssistRentalFeeAmountStranger())?;
    s.end()
  }
}

pub struct AssistSlotExcelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AssistSlotExcelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_SlotId(&mut self, SlotId: i64) {
    self.fbb_.push_slot::<i64>(AssistSlotExcel::VT_SLOTID, SlotId, 0);
  }
  #[inline]
  pub fn add_EchelonType(&mut self, EchelonType: EchelonType) {
    self.fbb_.push_slot::<EchelonType>(AssistSlotExcel::VT_ECHELONTYPE, EchelonType, EchelonType::None);
  }
  #[inline]
  pub fn add_SlotNumber(&mut self, SlotNumber: i64) {
    self.fbb_.push_slot::<i64>(AssistSlotExcel::VT_SLOTNUMBER, SlotNumber, 0);
  }
  #[inline]
  pub fn add_AssistTermRewardPeriodFromSec(&mut self, AssistTermRewardPeriodFromSec: i64) {
    self.fbb_.push_slot::<i64>(AssistSlotExcel::VT_ASSISTTERMREWARDPERIODFROMSEC, AssistTermRewardPeriodFromSec, 0);
  }
  #[inline]
  pub fn add_AssistRewardLimit(&mut self, AssistRewardLimit: i64) {
    self.fbb_.push_slot::<i64>(AssistSlotExcel::VT_ASSISTREWARDLIMIT, AssistRewardLimit, 0);
  }
  #[inline]
  pub fn add_AssistRentRewardDailyMaxCount(&mut self, AssistRentRewardDailyMaxCount: i64) {
    self.fbb_.push_slot::<i64>(AssistSlotExcel::VT_ASSISTRENTREWARDDAILYMAXCOUNT, AssistRentRewardDailyMaxCount, 0);
  }
  #[inline]
  pub fn add_AssistRentalFeeAmount(&mut self, AssistRentalFeeAmount: i64) {
    self.fbb_.push_slot::<i64>(AssistSlotExcel::VT_ASSISTRENTALFEEAMOUNT, AssistRentalFeeAmount, 0);
  }
  #[inline]
  pub fn add_AssistRentalFeeAmountStranger(&mut self, AssistRentalFeeAmountStranger: i64) {
    self.fbb_.push_slot::<i64>(AssistSlotExcel::VT_ASSISTRENTALFEEAMOUNTSTRANGER, AssistRentalFeeAmountStranger, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AssistSlotExcelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AssistSlotExcelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AssistSlotExcel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AssistSlotExcel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AssistSlotExcel");
      ds.field("SlotId", &self.SlotId());
      ds.field("EchelonType", &self.EchelonType());
      ds.field("SlotNumber", &self.SlotNumber());
      ds.field("AssistTermRewardPeriodFromSec", &self.AssistTermRewardPeriodFromSec());
      ds.field("AssistRewardLimit", &self.AssistRewardLimit());
      ds.field("AssistRentRewardDailyMaxCount", &self.AssistRentRewardDailyMaxCount());
      ds.field("AssistRentalFeeAmount", &self.AssistRentalFeeAmount());
      ds.field("AssistRentalFeeAmountStranger", &self.AssistRentalFeeAmountStranger());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct AssistSlotExcelT {
  pub SlotId: i64,
  pub EchelonType: EchelonType,
  pub SlotNumber: i64,
  pub AssistTermRewardPeriodFromSec: i64,
  pub AssistRewardLimit: i64,
  pub AssistRentRewardDailyMaxCount: i64,
  pub AssistRentalFeeAmount: i64,
  pub AssistRentalFeeAmountStranger: i64,
}
impl Default for AssistSlotExcelT {
  fn default() -> Self {
    Self {
      SlotId: 0,
      EchelonType: EchelonType::None,
      SlotNumber: 0,
      AssistTermRewardPeriodFromSec: 0,
      AssistRewardLimit: 0,
      AssistRentRewardDailyMaxCount: 0,
      AssistRentalFeeAmount: 0,
      AssistRentalFeeAmountStranger: 0,
    }
  }
}
impl AssistSlotExcelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<AssistSlotExcel<'b>> {
    let SlotId = self.SlotId;
    let EchelonType = self.EchelonType;
    let SlotNumber = self.SlotNumber;
    let AssistTermRewardPeriodFromSec = self.AssistTermRewardPeriodFromSec;
    let AssistRewardLimit = self.AssistRewardLimit;
    let AssistRentRewardDailyMaxCount = self.AssistRentRewardDailyMaxCount;
    let AssistRentalFeeAmount = self.AssistRentalFeeAmount;
    let AssistRentalFeeAmountStranger = self.AssistRentalFeeAmountStranger;
    AssistSlotExcel::create(_fbb, &AssistSlotExcelArgs{
      SlotId,
      EchelonType,
      SlotNumber,
      AssistTermRewardPeriodFromSec,
      AssistRewardLimit,
      AssistRentRewardDailyMaxCount,
      AssistRentalFeeAmount,
      AssistRentalFeeAmountStranger,
    })
  }
}
