// automatically generated by the FlatBuffers compiler, do not modify
// @generated
#![allow(unused_imports, dead_code)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum EmblemExcelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EmblemExcel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EmblemExcel<'a> {
  type Inner = EmblemExcel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EmblemExcel<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CATEGORY: flatbuffers::VOffsetT = 6;
  pub const VT_RARITY: flatbuffers::VOffsetT = 8;
  pub const VT_DISPLAYORDER: flatbuffers::VOffsetT = 10;
  pub const VT_LOCALIZEETCID: flatbuffers::VOffsetT = 12;
  pub const VT_LOCALIZECODEID: flatbuffers::VOffsetT = 14;
  pub const VT_USEATLOCALIZEID: flatbuffers::VOffsetT = 16;
  pub const VT_EMBLEMTEXTVISIBLE: flatbuffers::VOffsetT = 18;
  pub const VT_ICONPATH: flatbuffers::VOffsetT = 20;
  pub const VT_EMBLEMICONPATH: flatbuffers::VOffsetT = 22;
  pub const VT_EMBLEMICONNUMCONTROL: flatbuffers::VOffsetT = 24;
  pub const VT_EMBLEMICONBGPATH: flatbuffers::VOffsetT = 26;
  pub const VT_EMBLEMBGPATHJP: flatbuffers::VOffsetT = 28;
  pub const VT_EMBLEMBGPATHKR: flatbuffers::VOffsetT = 30;
  pub const VT_EMBLEMEFFECTPATH: flatbuffers::VOffsetT = 32;
  pub const VT_DISPLAYTYPE: flatbuffers::VOffsetT = 34;
  pub const VT_DISPLAYSTARTDATE: flatbuffers::VOffsetT = 36;
  pub const VT_DISPLAYENDDATE: flatbuffers::VOffsetT = 38;
  pub const VT_DISLPAYFAVORLEVEL: flatbuffers::VOffsetT = 40;
  pub const VT_CHECKPASSTYPE: flatbuffers::VOffsetT = 42;
  pub const VT_EMBLEMPARAMETER: flatbuffers::VOffsetT = 44;
  pub const VT_CHECKPASSCOUNT: flatbuffers::VOffsetT = 46;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EmblemExcel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EmblemExcelArgs<'args>
  ) -> flatbuffers::WIPOffset<EmblemExcel<'bldr>> {
    let mut builder = EmblemExcelBuilder::new(_fbb);
    let key = table_encryption_service::create_key(b"Emblem");
      let x = args.CheckPassCount;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_CheckPassCount(x);
      let x = args.EmblemParameter;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_EmblemParameter(x);
      let x = args.UseAtLocalizeId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_UseAtLocalizeId(x);
      let x = args.DisplayOrder;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_DisplayOrder(x);
      let x = args.Id;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_long(x, &key) } else { x };
      builder.add_Id(x);
      let x = args.CheckPassType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_CheckPassType(x);
      let x = args.DislpayFavorLevel;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_DislpayFavorLevel(x);
      if let Some(x) = args.DisplayEndDate {
        builder.add_DisplayEndDate(x);
      }
      if let Some(x) = args.DisplayStartDate {
        builder.add_DisplayStartDate(x);
      }
      let x = args.DisplayType;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_DisplayType(x);
      if let Some(x) = args.EmblemEffectPath {
        builder.add_EmblemEffectPath(x);
      }
      if let Some(x) = args.EmblemBGPathKr {
        builder.add_EmblemBGPathKr(x);
      }
      if let Some(x) = args.EmblemBGPathJp {
        builder.add_EmblemBGPathJp(x);
      }
      if let Some(x) = args.EmblemIconBGPath {
        builder.add_EmblemIconBGPath(x);
      }
      let x = args.EmblemIconNumControl;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_int(x, &key) } else { x };
      builder.add_EmblemIconNumControl(x);
      if let Some(x) = args.EmblemIconPath {
        builder.add_EmblemIconPath(x);
      }
      if let Some(x) = args.IconPath {
        builder.add_IconPath(x);
      }
      let x = args.LocalizeCodeId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_uint(x, &key) } else { x };
      builder.add_LocalizeCodeId(x);
      let x = args.LocalizeEtcId;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_uint(x, &key) } else { x };
      builder.add_LocalizeEtcId(x);
      let x = args.Rarity;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_Rarity(x);
      let x = args.Category;
      let x = if table_encryption_service::use_encryption() { table_encryption_service::convert_enum(x, &key) } else { x };
      builder.add_Category(x);
      builder.add_EmblemTextVisible(args.EmblemTextVisible);
    builder.finish()
  }

  pub fn unpack(&self) -> EmblemExcelT {
    let key = table_encryption_service::create_key(b"Emblem");
      let Id = self.Id();
      let Category = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.Category(), &key)
      } else {
        self.Category()
      };
      let Rarity = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.Rarity(), &key)
      } else {
        self.Rarity()
      };
      let DisplayOrder = self.DisplayOrder();
      let LocalizeEtcId = self.LocalizeEtcId();
      let LocalizeCodeId = self.LocalizeCodeId();
      let UseAtLocalizeId = self.UseAtLocalizeId();
      let EmblemTextVisible = self.EmblemTextVisible();
    let IconPath = self.IconPath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let EmblemIconPath = self.EmblemIconPath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let EmblemIconNumControl = self.EmblemIconNumControl();
    let EmblemIconBGPath = self.EmblemIconBGPath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let EmblemBGPathJp = self.EmblemBGPathJp().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let EmblemBGPathKr = self.EmblemBGPathKr().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let EmblemEffectPath = self.EmblemEffectPath().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let DisplayType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.DisplayType(), &key)
      } else {
        self.DisplayType()
      };
    let DisplayStartDate = self.DisplayStartDate().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
    let DisplayEndDate = self.DisplayEndDate().map(|x| {
      if table_encryption_service::use_encryption() { table_encryption_service::convert_string(&x, &key).unwrap() } else { x.to_string() }
    });
      let DislpayFavorLevel = self.DislpayFavorLevel();
      let CheckPassType = if table_encryption_service::use_encryption() {
        table_encryption_service::convert_enum(self.CheckPassType(), &key)
      } else {
        self.CheckPassType()
      };
      let EmblemParameter = self.EmblemParameter();
      let CheckPassCount = self.CheckPassCount();
    EmblemExcelT {
      Id,
      Category,
      Rarity,
      DisplayOrder,
      LocalizeEtcId,
      LocalizeCodeId,
      UseAtLocalizeId,
      EmblemTextVisible,
      IconPath,
      EmblemIconPath,
      EmblemIconNumControl,
      EmblemIconBGPath,
      EmblemBGPathJp,
      EmblemBGPathKr,
      EmblemEffectPath,
      DisplayType,
      DisplayStartDate,
      DisplayEndDate,
      DislpayFavorLevel,
      CheckPassType,
      EmblemParameter,
      CheckPassCount,
    }
  }

  #[inline]
  pub fn Id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(EmblemExcel::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn Category(&self) -> EmblemCategory {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<EmblemCategory>(EmblemExcel::VT_CATEGORY, Some(EmblemCategory::None)).unwrap()}
  }
  #[inline]
  pub fn Rarity(&self) -> Rarity {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Rarity>(EmblemExcel::VT_RARITY, Some(Rarity::N)).unwrap()}
  }
  #[inline]
  pub fn DisplayOrder(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(EmblemExcel::VT_DISPLAYORDER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn LocalizeEtcId(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(EmblemExcel::VT_LOCALIZEETCID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn LocalizeCodeId(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(EmblemExcel::VT_LOCALIZECODEID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn UseAtLocalizeId(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(EmblemExcel::VT_USEATLOCALIZEID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EmblemTextVisible(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(EmblemExcel::VT_EMBLEMTEXTVISIBLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn IconPath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EmblemExcel::VT_ICONPATH, None)}
  }
  #[inline]
  pub fn EmblemIconPath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EmblemExcel::VT_EMBLEMICONPATH, None)}
  }
  #[inline]
  pub fn EmblemIconNumControl(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(EmblemExcel::VT_EMBLEMICONNUMCONTROL, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EmblemIconBGPath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EmblemExcel::VT_EMBLEMICONBGPATH, None)}
  }
  #[inline]
  pub fn EmblemBGPathJp(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EmblemExcel::VT_EMBLEMBGPATHJP, None)}
  }
  #[inline]
  pub fn EmblemBGPathKr(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EmblemExcel::VT_EMBLEMBGPATHKR, None)}
  }
  #[inline]
  pub fn EmblemEffectPath(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EmblemExcel::VT_EMBLEMEFFECTPATH, None)}
  }
  #[inline]
  pub fn DisplayType(&self) -> EmblemDisplayType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<EmblemDisplayType>(EmblemExcel::VT_DISPLAYTYPE, Some(EmblemDisplayType::Always)).unwrap()}
  }
  #[inline]
  pub fn DisplayStartDate(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EmblemExcel::VT_DISPLAYSTARTDATE, None)}
  }
  #[inline]
  pub fn DisplayEndDate(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EmblemExcel::VT_DISPLAYENDDATE, None)}
  }
  #[inline]
  pub fn DislpayFavorLevel(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(EmblemExcel::VT_DISLPAYFAVORLEVEL, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CheckPassType(&self) -> EmblemCheckPassType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<EmblemCheckPassType>(EmblemExcel::VT_CHECKPASSTYPE, Some(EmblemCheckPassType::None)).unwrap()}
  }
  #[inline]
  pub fn EmblemParameter(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(EmblemExcel::VT_EMBLEMPARAMETER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CheckPassCount(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(EmblemExcel::VT_CHECKPASSCOUNT, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for EmblemExcel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("Id", Self::VT_ID, false)?
     .visit_field::<EmblemCategory>("Category", Self::VT_CATEGORY, false)?
     .visit_field::<Rarity>("Rarity", Self::VT_RARITY, false)?
     .visit_field::<i64>("DisplayOrder", Self::VT_DISPLAYORDER, false)?
     .visit_field::<u32>("LocalizeEtcId", Self::VT_LOCALIZEETCID, false)?
     .visit_field::<u32>("LocalizeCodeId", Self::VT_LOCALIZECODEID, false)?
     .visit_field::<i64>("UseAtLocalizeId", Self::VT_USEATLOCALIZEID, false)?
     .visit_field::<bool>("EmblemTextVisible", Self::VT_EMBLEMTEXTVISIBLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("IconPath", Self::VT_ICONPATH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EmblemIconPath", Self::VT_EMBLEMICONPATH, false)?
     .visit_field::<i32>("EmblemIconNumControl", Self::VT_EMBLEMICONNUMCONTROL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EmblemIconBGPath", Self::VT_EMBLEMICONBGPATH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EmblemBGPathJp", Self::VT_EMBLEMBGPATHJP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EmblemBGPathKr", Self::VT_EMBLEMBGPATHKR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EmblemEffectPath", Self::VT_EMBLEMEFFECTPATH, false)?
     .visit_field::<EmblemDisplayType>("DisplayType", Self::VT_DISPLAYTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DisplayStartDate", Self::VT_DISPLAYSTARTDATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DisplayEndDate", Self::VT_DISPLAYENDDATE, false)?
     .visit_field::<i32>("DislpayFavorLevel", Self::VT_DISLPAYFAVORLEVEL, false)?
     .visit_field::<EmblemCheckPassType>("CheckPassType", Self::VT_CHECKPASSTYPE, false)?
     .visit_field::<i64>("EmblemParameter", Self::VT_EMBLEMPARAMETER, false)?
     .visit_field::<i64>("CheckPassCount", Self::VT_CHECKPASSCOUNT, false)?
     .finish();
    Ok(())
  }
}
pub struct EmblemExcelArgs<'a> {
    pub Id: i64,
    pub Category: EmblemCategory,
    pub Rarity: Rarity,
    pub DisplayOrder: i64,
    pub LocalizeEtcId: u32,
    pub LocalizeCodeId: u32,
    pub UseAtLocalizeId: i64,
    pub EmblemTextVisible: bool,
    pub IconPath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EmblemIconPath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EmblemIconNumControl: i32,
    pub EmblemIconBGPath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EmblemBGPathJp: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EmblemBGPathKr: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EmblemEffectPath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DisplayType: EmblemDisplayType,
    pub DisplayStartDate: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DisplayEndDate: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DislpayFavorLevel: i32,
    pub CheckPassType: EmblemCheckPassType,
    pub EmblemParameter: i64,
    pub CheckPassCount: i64,
}
impl<'a> Default for EmblemExcelArgs<'a> {
  #[inline]
  fn default() -> Self {
    EmblemExcelArgs {
      Id: 0,
      Category: EmblemCategory::None,
      Rarity: Rarity::N,
      DisplayOrder: 0,
      LocalizeEtcId: 0,
      LocalizeCodeId: 0,
      UseAtLocalizeId: 0,
      EmblemTextVisible: false,
      IconPath: None,
      EmblemIconPath: None,
      EmblemIconNumControl: 0,
      EmblemIconBGPath: None,
      EmblemBGPathJp: None,
      EmblemBGPathKr: None,
      EmblemEffectPath: None,
      DisplayType: EmblemDisplayType::Always,
      DisplayStartDate: None,
      DisplayEndDate: None,
      DislpayFavorLevel: 0,
      CheckPassType: EmblemCheckPassType::None,
      EmblemParameter: 0,
      CheckPassCount: 0,
    }
  }
}

impl Serialize for EmblemExcel<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("EmblemExcel", 22)?;
      s.serialize_field("Id", &self.Id())?;
      s.serialize_field("Category", &self.Category())?;
      s.serialize_field("Rarity", &self.Rarity())?;
      s.serialize_field("DisplayOrder", &self.DisplayOrder())?;
      s.serialize_field("LocalizeEtcId", &self.LocalizeEtcId())?;
      s.serialize_field("LocalizeCodeId", &self.LocalizeCodeId())?;
      s.serialize_field("UseAtLocalizeId", &self.UseAtLocalizeId())?;
      s.serialize_field("EmblemTextVisible", &self.EmblemTextVisible())?;
      if let Some(f) = self.IconPath() {
        s.serialize_field("IconPath", &f)?;
      } else {
        s.skip_field("IconPath")?;
      }
      if let Some(f) = self.EmblemIconPath() {
        s.serialize_field("EmblemIconPath", &f)?;
      } else {
        s.skip_field("EmblemIconPath")?;
      }
      s.serialize_field("EmblemIconNumControl", &self.EmblemIconNumControl())?;
      if let Some(f) = self.EmblemIconBGPath() {
        s.serialize_field("EmblemIconBGPath", &f)?;
      } else {
        s.skip_field("EmblemIconBGPath")?;
      }
      if let Some(f) = self.EmblemBGPathJp() {
        s.serialize_field("EmblemBGPathJp", &f)?;
      } else {
        s.skip_field("EmblemBGPathJp")?;
      }
      if let Some(f) = self.EmblemBGPathKr() {
        s.serialize_field("EmblemBGPathKr", &f)?;
      } else {
        s.skip_field("EmblemBGPathKr")?;
      }
      if let Some(f) = self.EmblemEffectPath() {
        s.serialize_field("EmblemEffectPath", &f)?;
      } else {
        s.skip_field("EmblemEffectPath")?;
      }
      s.serialize_field("DisplayType", &self.DisplayType())?;
      if let Some(f) = self.DisplayStartDate() {
        s.serialize_field("DisplayStartDate", &f)?;
      } else {
        s.skip_field("DisplayStartDate")?;
      }
      if let Some(f) = self.DisplayEndDate() {
        s.serialize_field("DisplayEndDate", &f)?;
      } else {
        s.skip_field("DisplayEndDate")?;
      }
      s.serialize_field("DislpayFavorLevel", &self.DislpayFavorLevel())?;
      s.serialize_field("CheckPassType", &self.CheckPassType())?;
      s.serialize_field("EmblemParameter", &self.EmblemParameter())?;
      s.serialize_field("CheckPassCount", &self.CheckPassCount())?;
    s.end()
  }
}

pub struct EmblemExcelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EmblemExcelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_Id(&mut self, Id: i64) {
    self.fbb_.push_slot::<i64>(EmblemExcel::VT_ID, Id, 0);
  }
  #[inline]
  pub fn add_Category(&mut self, Category: EmblemCategory) {
    self.fbb_.push_slot::<EmblemCategory>(EmblemExcel::VT_CATEGORY, Category, EmblemCategory::None);
  }
  #[inline]
  pub fn add_Rarity(&mut self, Rarity: Rarity) {
    self.fbb_.push_slot::<Rarity>(EmblemExcel::VT_RARITY, Rarity, Rarity::N);
  }
  #[inline]
  pub fn add_DisplayOrder(&mut self, DisplayOrder: i64) {
    self.fbb_.push_slot::<i64>(EmblemExcel::VT_DISPLAYORDER, DisplayOrder, 0);
  }
  #[inline]
  pub fn add_LocalizeEtcId(&mut self, LocalizeEtcId: u32) {
    self.fbb_.push_slot::<u32>(EmblemExcel::VT_LOCALIZEETCID, LocalizeEtcId, 0);
  }
  #[inline]
  pub fn add_LocalizeCodeId(&mut self, LocalizeCodeId: u32) {
    self.fbb_.push_slot::<u32>(EmblemExcel::VT_LOCALIZECODEID, LocalizeCodeId, 0);
  }
  #[inline]
  pub fn add_UseAtLocalizeId(&mut self, UseAtLocalizeId: i64) {
    self.fbb_.push_slot::<i64>(EmblemExcel::VT_USEATLOCALIZEID, UseAtLocalizeId, 0);
  }
  #[inline]
  pub fn add_EmblemTextVisible(&mut self, EmblemTextVisible: bool) {
    self.fbb_.push_slot::<bool>(EmblemExcel::VT_EMBLEMTEXTVISIBLE, EmblemTextVisible, false);
  }
  #[inline]
  pub fn add_IconPath(&mut self, IconPath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EmblemExcel::VT_ICONPATH, IconPath);
  }
  #[inline]
  pub fn add_EmblemIconPath(&mut self, EmblemIconPath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EmblemExcel::VT_EMBLEMICONPATH, EmblemIconPath);
  }
  #[inline]
  pub fn add_EmblemIconNumControl(&mut self, EmblemIconNumControl: i32) {
    self.fbb_.push_slot::<i32>(EmblemExcel::VT_EMBLEMICONNUMCONTROL, EmblemIconNumControl, 0);
  }
  #[inline]
  pub fn add_EmblemIconBGPath(&mut self, EmblemIconBGPath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EmblemExcel::VT_EMBLEMICONBGPATH, EmblemIconBGPath);
  }
  #[inline]
  pub fn add_EmblemBGPathJp(&mut self, EmblemBGPathJp: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EmblemExcel::VT_EMBLEMBGPATHJP, EmblemBGPathJp);
  }
  #[inline]
  pub fn add_EmblemBGPathKr(&mut self, EmblemBGPathKr: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EmblemExcel::VT_EMBLEMBGPATHKR, EmblemBGPathKr);
  }
  #[inline]
  pub fn add_EmblemEffectPath(&mut self, EmblemEffectPath: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EmblemExcel::VT_EMBLEMEFFECTPATH, EmblemEffectPath);
  }
  #[inline]
  pub fn add_DisplayType(&mut self, DisplayType: EmblemDisplayType) {
    self.fbb_.push_slot::<EmblemDisplayType>(EmblemExcel::VT_DISPLAYTYPE, DisplayType, EmblemDisplayType::Always);
  }
  #[inline]
  pub fn add_DisplayStartDate(&mut self, DisplayStartDate: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EmblemExcel::VT_DISPLAYSTARTDATE, DisplayStartDate);
  }
  #[inline]
  pub fn add_DisplayEndDate(&mut self, DisplayEndDate: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EmblemExcel::VT_DISPLAYENDDATE, DisplayEndDate);
  }
  #[inline]
  pub fn add_DislpayFavorLevel(&mut self, DislpayFavorLevel: i32) {
    self.fbb_.push_slot::<i32>(EmblemExcel::VT_DISLPAYFAVORLEVEL, DislpayFavorLevel, 0);
  }
  #[inline]
  pub fn add_CheckPassType(&mut self, CheckPassType: EmblemCheckPassType) {
    self.fbb_.push_slot::<EmblemCheckPassType>(EmblemExcel::VT_CHECKPASSTYPE, CheckPassType, EmblemCheckPassType::None);
  }
  #[inline]
  pub fn add_EmblemParameter(&mut self, EmblemParameter: i64) {
    self.fbb_.push_slot::<i64>(EmblemExcel::VT_EMBLEMPARAMETER, EmblemParameter, 0);
  }
  #[inline]
  pub fn add_CheckPassCount(&mut self, CheckPassCount: i64) {
    self.fbb_.push_slot::<i64>(EmblemExcel::VT_CHECKPASSCOUNT, CheckPassCount, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EmblemExcelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EmblemExcelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EmblemExcel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EmblemExcel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EmblemExcel");
      ds.field("Id", &self.Id());
      ds.field("Category", &self.Category());
      ds.field("Rarity", &self.Rarity());
      ds.field("DisplayOrder", &self.DisplayOrder());
      ds.field("LocalizeEtcId", &self.LocalizeEtcId());
      ds.field("LocalizeCodeId", &self.LocalizeCodeId());
      ds.field("UseAtLocalizeId", &self.UseAtLocalizeId());
      ds.field("EmblemTextVisible", &self.EmblemTextVisible());
      ds.field("IconPath", &self.IconPath());
      ds.field("EmblemIconPath", &self.EmblemIconPath());
      ds.field("EmblemIconNumControl", &self.EmblemIconNumControl());
      ds.field("EmblemIconBGPath", &self.EmblemIconBGPath());
      ds.field("EmblemBGPathJp", &self.EmblemBGPathJp());
      ds.field("EmblemBGPathKr", &self.EmblemBGPathKr());
      ds.field("EmblemEffectPath", &self.EmblemEffectPath());
      ds.field("DisplayType", &self.DisplayType());
      ds.field("DisplayStartDate", &self.DisplayStartDate());
      ds.field("DisplayEndDate", &self.DisplayEndDate());
      ds.field("DislpayFavorLevel", &self.DislpayFavorLevel());
      ds.field("CheckPassType", &self.CheckPassType());
      ds.field("EmblemParameter", &self.EmblemParameter());
      ds.field("CheckPassCount", &self.CheckPassCount());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct EmblemExcelT {
  pub Id: i64,
  pub Category: EmblemCategory,
  pub Rarity: Rarity,
  pub DisplayOrder: i64,
  pub LocalizeEtcId: u32,
  pub LocalizeCodeId: u32,
  pub UseAtLocalizeId: i64,
  pub EmblemTextVisible: bool,
  pub IconPath: Option<String>,
  pub EmblemIconPath: Option<String>,
  pub EmblemIconNumControl: i32,
  pub EmblemIconBGPath: Option<String>,
  pub EmblemBGPathJp: Option<String>,
  pub EmblemBGPathKr: Option<String>,
  pub EmblemEffectPath: Option<String>,
  pub DisplayType: EmblemDisplayType,
  pub DisplayStartDate: Option<String>,
  pub DisplayEndDate: Option<String>,
  pub DislpayFavorLevel: i32,
  pub CheckPassType: EmblemCheckPassType,
  pub EmblemParameter: i64,
  pub CheckPassCount: i64,
}
impl Default for EmblemExcelT {
  fn default() -> Self {
    Self {
      Id: 0,
      Category: EmblemCategory::None,
      Rarity: Rarity::N,
      DisplayOrder: 0,
      LocalizeEtcId: 0,
      LocalizeCodeId: 0,
      UseAtLocalizeId: 0,
      EmblemTextVisible: false,
      IconPath: None,
      EmblemIconPath: None,
      EmblemIconNumControl: 0,
      EmblemIconBGPath: None,
      EmblemBGPathJp: None,
      EmblemBGPathKr: None,
      EmblemEffectPath: None,
      DisplayType: EmblemDisplayType::Always,
      DisplayStartDate: None,
      DisplayEndDate: None,
      DislpayFavorLevel: 0,
      CheckPassType: EmblemCheckPassType::None,
      EmblemParameter: 0,
      CheckPassCount: 0,
    }
  }
}
impl EmblemExcelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<EmblemExcel<'b>> {
    let Id = self.Id;
    let Category = self.Category;
    let Rarity = self.Rarity;
    let DisplayOrder = self.DisplayOrder;
    let LocalizeEtcId = self.LocalizeEtcId;
    let LocalizeCodeId = self.LocalizeCodeId;
    let UseAtLocalizeId = self.UseAtLocalizeId;
    let EmblemTextVisible = self.EmblemTextVisible;
    let IconPath = self.IconPath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EmblemIconPath = self.EmblemIconPath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EmblemIconNumControl = self.EmblemIconNumControl;
    let EmblemIconBGPath = self.EmblemIconBGPath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EmblemBGPathJp = self.EmblemBGPathJp.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EmblemBGPathKr = self.EmblemBGPathKr.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EmblemEffectPath = self.EmblemEffectPath.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DisplayType = self.DisplayType;
    let DisplayStartDate = self.DisplayStartDate.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DisplayEndDate = self.DisplayEndDate.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DislpayFavorLevel = self.DislpayFavorLevel;
    let CheckPassType = self.CheckPassType;
    let EmblemParameter = self.EmblemParameter;
    let CheckPassCount = self.CheckPassCount;
    EmblemExcel::create(_fbb, &EmblemExcelArgs{
      Id,
      Category,
      Rarity,
      DisplayOrder,
      LocalizeEtcId,
      LocalizeCodeId,
      UseAtLocalizeId,
      EmblemTextVisible,
      IconPath,
      EmblemIconPath,
      EmblemIconNumControl,
      EmblemIconBGPath,
      EmblemBGPathJp,
      EmblemBGPathKr,
      EmblemEffectPath,
      DisplayType,
      DisplayStartDate,
      DisplayEndDate,
      DislpayFavorLevel,
      CheckPassType,
      EmblemParameter,
      CheckPassCount,
    })
  }
}
